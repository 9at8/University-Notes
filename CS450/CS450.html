<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CS450 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso.light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body onload="highlight()">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-68271407-1', 'auto');
    ga('send', 'pageview');

  </script>
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/resume.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="https://www.linkedin.com/in/uberi/" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="https://twitter.com/anthony926535" class="contact">twitter</a></li>
    <span class="divider"></span>
    <li><a href="/anthony-zhang.asc" class="info">GPG key</a></li>
  </ul>
<p style="display:none"><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1 \right\rceil}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l'H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}^P)}
\]</span></p>
<h1 id="cs450">CS450</h1>
<p>Computer Architecture.</p>
<pre><code>Andrew Morton
Section 001
Email: andrew.morton@uwaterloo.ca
Website: https://www.student.cs.uwaterloo.ca/~cs450/w17/outline.shtml
Office Hours: Tuesdays/Thursdays 11:30am-12:30pm in EIT-4015
Tuesdays/Thursdays 1:00pm-2:20pm</code></pre>
<h1 id="section">3/1/16</h1>
<p>In this course, the main project (worth 30%) is to design a MIPS processor in Verilog. No required textbooks. The main topic is about how modern CPUs manage to achieve the performance that they do, building on top of the processor basics covered in earlier processor design courses.</p>
<p>There are also two written assignments (worth 20% total) and the final exam (worth 50%). Assignments have 4 grace days allowed.</p>
<p>Hardware description languages are used for modelling hardware, generally for the purpose of simulation or synthesis. Most complex digital hardware is designed using a hardware description language, which is then compiled and converted into specifications for FPGAs, ASICs, programmable logic, and so on.</p>
<p>The main hardware description languages in use today are System Verilog and VHDL. VHDL is more verbose and Ada-like, while Verilog is more minimalist and C-like. Most projects in industry use Verilog for this reason. System Verilog is a superset of plain Verilog, and all Verilog code works in System Verilog. There's also System C, which looks a lot more like C/C++, but it's not commonly used. In this course, we will be using Icarus Verilog (an implementation of System Verilog), version 10 or later (in order to get support for SystemVerilog).</p>
<p>The simplest/lowest-level of hardware modelling in System Verilog is <strong>gate-level modelling</strong>. At this level, we have logic gate primitives like AND/OR, and we can connect them together into circuits via <strong>wires</strong>:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"># <span class="ot">`a1</span>` is the name of the gate, which is optional but useful <span class="kw">for</span> labelling gates
# <span class="ot">`y</span>` is the gate <span class="dt">output</span>, <span class="dt">and</span> <span class="ot">`a</span>`/<span class="ot">`b</span>`/<span class="ot">`c</span>` are the gate inputs (<span class="ot">`and</span>` supports one <span class="dt">or</span> more of these inputs, <span class="dt">and</span> one <span class="dt">output</span>)
# the inputs <span class="dt">and</span> outputs are wires, identified by name - everywhere that same name is used can be thought of as being all connected together by a physical <span class="dt">wire</span>
<span class="dt">and</span> a1(y, a, b, c)

# every argument except the last are the NOT gate&#39;s outputs, <span class="dt">and</span> the last one is the <span class="dt">input</span>
<span class="dt">not</span> (y1, y2, a)</code></pre></div>
<h2 id="gate-level-modelling">Gate-level modelling</h2>
<p>In gate-level modelling, signal/wire values can be <code>0</code> (low), <code>1</code> (high), <code>x</code>/<code>X</code> (unknown/ignored value), or <code>z</code>/<code>Z</code> (high impedance).</p>
<p>Gate-level modelling for a full adder (addend bits as <code>a</code>/<code>b</code>, carry-in as <code>c_in</code>, carry-out as <code>c_out</code>, sum as <code>sum</code>):</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_gate_level_modelling.sv</span>
<span class="co">// for a full adder, `sum = a XOR b XOR c_in`, and `c_out = ((a XOR b) AND c_in) OR a AND b`</span>

<span class="kw">module</span> full_adder(<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> c_out, sum);
    <span class="co">// a `logic` is basically a connection/wire - here, we&#39;re declaring our wires</span>
    <span class="co">// a `wire` is equivalent to a `wire logic`, which is a logic that supports multiple drivers</span>
    <span class="co">// generally, we just use logic unless we need multiple drivers - the compiler will choose the best structure depending on how they&#39;re used</span>
    <span class="co">// there are also `bit` and `byte`, which are basically logics that can only be 0 or 1, not X or Z</span>
    logic w1, w2, w3; <span class="co">// these are wires that are used for connecting gates in the full adder together</span>
    <span class="dt">xor</span> x1(w1, a, b);
    <span class="dt">xor</span> x2(sum, w1, c_in);
    <span class="dt">and</span> a1(w2, a, b);
    <span class="dt">and</span> a2(w3, w1, c_in);
    <span class="dt">or</span> o1(c_out, w2, w3);
<span class="kw">endmodule</span></code></pre></div>
<p>This is a <strong>design module</strong>. It fully specifies the full adder as a self-contained unit.</p>
<p>While this looks like normal procedural code, with various function calls, it is more intuitive to think of this as a series of logical declarations - as if each of the <code>xor</code>/<code>and</code>/<code>or</code> lines were all continuously running at the same time.</p>
<p>A <strong>test bench</strong> is a set of definitions that instantiates the design module, and simulates the circuit under different input conditions to test for functional correctness. For our full adder example:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_test_bench.sv</span>
<span class="kw">module</span> full_adder_test_bench;
    logic carry_in, x, y;
    logic carry_out, z;

    <span class="co">// &quot;dut&quot; stands for &quot;device under test&quot;</span>
    <span class="co">// below, we&#39;re basically instantiating a full adder (defined in the code above) that&#39;s connected to our logics, for testing purposes</span>
    <span class="co">// the `.name(other_name)` syntax is a &quot;named port map&quot;, which lets us connect logics to devices by signal name</span>
    <span class="co">// alternatively, we can just map the signals in order, like `full_adder dut(x, y, carry_in, carry_out, z)`, but this can cause issues if we change the inputs/outputs of the full adder</span>
    full_adder dut(.c_out(carry_out), .sum(z), .c_in(carry_in), .a(x), .b(y));

    <span class="co">// this is a procedural block - inside, the statements are evaluated sequentially from top to bottom</span>
    <span class="kw">initial</span> <span class="kw">begin</span> <span class="co">// run once at time 0</span>
        carry_in = <span class="dv">0</span>; x = <span class="dv">0</span>; y = <span class="dv">0</span>;
        <span class="co">// delays must be used to ensure statements actually run sequentially - statements in between delays all execute in parallel</span>
        <span class="bn">#10</span> x = <span class="dv">1</span>; <span class="co">// delay 10 time units, then continue and set x to 1</span>
        <span class="bn">#10</span> y = <span class="dv">1</span>; <span class="co">// delay 10 time units, then continue and set y to 1</span>
        <span class="bn">#10</span> carry_in = <span class="dv">1</span>; <span class="co">// delay 10 time units, then continue and set carry_in to 1</span>
        <span class="bn">#10</span> <span class="dt">$stop</span>; <span class="co">// delay 10 time units, then stop the simulation (this will not compile if trying to generate hardware from this)</span>
    <span class="kw">end</span>

    <span class="co">// now we want to dump the signals out into waveforms so we can see them</span>
    <span class="kw">initial</span> <span class="dt">$dumpvars</span>(<span class="dv">0</span>, full_adder_test_bench); <span class="co">// the first parameter is the dump level (`0` means &quot;dump all variables in the module and in the modules that instantiate it&quot;), and the rest of the parameters are the module or variables to dump</span>
<span class="kw">endmodule</span></code></pre></div>
<p>To compile, run <code>iverilog -g2005-sv -s full_adder_test_bench.sv -o full_adder.vvp full_adder.sv full_adder_test_bench.sv</code>:</p>
<ul>
<li><code>iverilog</code> is the Icarus Verilog compiler.</li>
<li><code>-g2005-sv</code> specifies that the compiler should use the 2005 System Verilog standard.</li>
<li><code>-s full_adder_test_bench.sv</code> specifies the top-level/root module.</li>
<li><code>-o full_adder.vvp</code> specifies the output for the compiled Verilog.</li>
<li><code>full_adder.sv full_adder_test_bench.sv</code> specifies the modules to include in the compilation.</li>
</ul>
<p>To simulate, run <code>vvp -n full_adder.vvp -lx2</code>:</p>
<ul>
<li><code>vvp</code> is the Icarus Verilog simulation tool.</li>
<li><code>-n</code> specifies that <code>$stop</code> and Control-C should complete the simulation.</li>
<li><code>full_adder.vvp</code> is the compiled Verilog file for the full adder.</li>
<li><code>-lx2</code> specifies that the simulation should be written in LXT2 format, which is slower to process but more compact allows viewing waveforms while the simulation is running.</li>
</ul>
<p>To view the waveforms: <code>gtkwave dump.lx2</code>:</p>
<ul>
<li><code>gtkwave</code> is the GTK waveform visualizer tool.</li>
<li><code>dump.lx2</code> is the simulation result generated by <code>vvp</code>.</li>
</ul>
<h1 id="section-1">5/1/17</h1>
<p>Live demonstration of the above Verilog workflow, including an overview of GtkWave's features and a shell script that builds and simulates the module.</p>
<p><strong>Heirarchical design</strong> is the idea of using lower-level modules in higher-level modules. For example, a carry-lookahead adder module might instantiate a few ripple-carry adders, which in turn might instantiate a bunch of full-adders:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// adder_4_bit.sv</span>
<span class="kw">module</span> adder_4_bit(<span class="dt">output</span> c_out, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">input</span> c_in, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, b);
    logic [<span class="dv">3</span>:<span class="dv">1</span>] carry;
    full_adder fa0(.c_out(carry[<span class="dv">1</span>]), .sum(sum[<span class="dv">0</span>]), .c_in(c_in), .a(a[<span class="dv">0</span>]), .b(b[<span class="dv">0</span>]));
    full_adder fa0(.c_out(carry[<span class="dv">2</span>]), .sum(sum[<span class="dv">1</span>]), .c_in(carry[<span class="dv">1</span>]), .a(a[<span class="dv">1</span>]), .b(b[<span class="dv">1</span>]));
    full_adder fa0(.c_out(carry[<span class="dv">3</span>]), .sum(sum[<span class="dv">2</span>]), .c_in(carry[<span class="dv">2</span>]), .a(a[<span class="dv">2</span>]), .b(b[<span class="dv">2</span>]));
    full_adder fa0(.c_out(c_out), .sum(sum[<span class="dv">3</span>]), .c_in(carry[<span class="dv">3</span>]), .a(a[<span class="dv">3</span>]), .b(b[<span class="dv">3</span>]));
<span class="kw">endmodule</span></code></pre></div>
<p>Note that there's a lot of similar statements for the full adder definitions. In these cases, we can use generate statements to remove duplicated code. It looks somewhat like a loop, but it's more of a macro that gets expanded into multiple statements at compile time:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// adder_4_bit_generate.sv</span>
<span class="kw">module</span> adder_4_bit(<span class="dt">output</span> c_out, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">input</span> c_in, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, b);
    logic [<span class="dv">4</span>:<span class="dv">0</span>] carry;
    
    <span class="kw">generate</span>
        <span class="dt">genvar</span> i;
        <span class="kw">for</span>(i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i=i<span class="dv">+1</span>) <span class="kw">begin:</span><span class="dt"> adder</span>
            full_adder fa(.c_out(carry[i<span class="dv">+1</span>]), .sum(sum[i]), .c_in(carry[i]) ,.a(a[i]), .b(b[i]));
        <span class="kw">end</span>
    <span class="kw">endgenerate</span>

    <span class="co">// since it would be really inconvenient to specify our c_in and c_out in the generate statement, we just used extra indices in the carry wire, and then assign the inputs/outputs accordingly</span>
    <span class="kw">assign</span> carry[<span class="dv">0</span>] = c_in; <span class="co">// this is a continuous assignment statement - it&#39;s sort of like a one-way wire for the c_in signal in this case, but it can also do things like combinational logic with different gates and stuff</span>
    <span class="kw">assign</span> c_out = carry[<span class="dv">4</span>]; <span class="co">// since the assignment is unidirectional, the inputs are on the right side of the equal sign, and the outputs are on the left side</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Usually for loops are discouraged, but they're fine for generate statements - in other contexts, they might not compile to actual hardware.</p>
<h2 id="dataflow-modelling">Dataflow modelling</h2>
<p>Dataflow modelling is the next level of abstraction above gate-level modelling. Dataflow modelling deals only with combinational circuits, by representing them with continuous assignment statements.</p>
<p>Basically, we represent what logical operations the circuit needs to do, and the compiler will figure out what kind of gate layout we need. For example, for a full adder it might automatically decide to reuse the <code>xor(a, b)</code> gate.</p>
<p>For example, we might model a full adder using dataflow modelling as follows:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_dataflow.sv</span>
<span class="kw">module</span> full_adder(<span class="dt">output</span> c_out, sum, <span class="dt">input</span> c_in, a, b);
    <span class="co">// the value of `sum` is continuously updated based on the values of `a`, `b`, and `c_in` - whenever any of those change, `sum` reflects the new value</span>
    <span class="co">// this updating is not true of all continuous assignment statements, however</span>
    <span class="kw">assign</span> sum = a ^ b ^ c_in;
    <span class="kw">assign</span> c_out = ((a ^ b) &amp; c_in) | (a &amp; b);

    <span class="co">// actually, Verilog has a `+` operator, so it&#39;s really as simple as `assign {c_out, sum} = a + b + c_in`</span>
    <span class="co">// `assign` will truncate the result of evaluating the right hand side, if the right hand side has more bits than the left</span>
    <span class="co">// `assign` will zero-extend the result of evaluating the right hand side, if the right hand side has fewer bits than the left</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Some of the available operators are <code>!</code> (logical NOT), <code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR), <code>+</code> (two's complement addition), <code>-</code> (two's complement subtraction), <code>*</code> (multiplication), <code>/</code> (division), <code>%</code> (remainder), <code>**</code> (exponentiation), <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>~</code> (NOT), <code>&amp;</code> (AND), <code>|</code> (OR), <code>^</code> (XOR), <code>^~</code> (XNOR), <code>&lt;&lt;</code> (bit shift left), <code>&gt;&gt;</code> (bit shift right), <code>&gt;&gt;&gt;</code> (signed shift right - extends sign bit), <code>{a_1, ..., a_n}</code> (concatenate <code>a_1</code> through to <code>a_n</code>), <code>{n{a}}</code> (replicate <code>a</code> by <code>n</code> times - repeatedly concatenate <code>a</code>), <code>c?a:b</code> (MUX - select <code>a</code> if <code>c</code> is high, <code>b</code> otherwise). They generally have precedence similar to their equivalents in C and Python.</p>
<p>For example, the nibbles of a byte can be swapped with <code>assign {b[3:0], b[7:4]} = a[7:0]</code>, and an 8-bit signed integer can be sign-extended to 16 bits with <code>assign b[15:0] = {{8{a[7]}}, a[7:0]}</code>.</p>
<p>With all these useful operators, it's pretty straightforward to make a 4-bit adder:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_dataflow.sv</span>
<span class="kw">module</span> full_adder(<span class="dt">output</span> c_out, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">input</span> c_in, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, b);
    <span class="kw">assign</span> {c_out, sum} = a + b + c_in`
<span class="kw">endmodule</span></code></pre></div>
<h2 id="behaviour-modelling">Behaviour modelling</h2>
<p>Behaviour modelling is the next level of abstraction above dataflow-level modelling. It uses procedural blocks that are <code>initial</code>.</p>
<p>An <code>initial</code> block runs the statements inside of it once starting at time 0. An <code>always</code> block runs the statements inside of it whenever certain things change.</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">initial</span> <span class="co">// run once at time 0</span></code></pre></div>
<p>Here's a full adder implemented with behaviour modelling:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> full_adder(<span class="dt">input</span> c_in, a, b, <span class="dt">output</span> logic c_out, sum);
    <span class="co">// the `@ (c_in, a, b)` specifies the &quot;sensitivity list&quot;, which means the procedural block should be reevaluated whenever any of the logics in the list change</span>
    <span class="co">// in contrast, the `initial` statement doesn&#39;t have a sensitivity list because it simply runs once at the beginning</span>
    <span class="co">// the left hand sides of each assignment must be a `logic` or `reg` - that&#39;s why the outputs of this module are declared as `logic`</span>
    <span class="co">// we could also have written `always @ *` to make it re-evaluate the block whenever any of the signals on the right hand sides of any assignment statement changes</span>
    <span class="kw">always</span> @ (c_in, a, b) <span class="kw">begin</span>
        sum = a ^ b ^ c_in;
        c_out = ((a ^ b) &amp; c_in) | (a &amp; b);
    <span class="kw">end</span></code></pre></div>
<p>Alternatively:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> full_adder(<span class="dt">input</span> c_in, a, b, <span class="dt">output</span> logic c_out, sum);
    <span class="kw">always</span> @ (c_in, a, b) <span class="kw">begin</span>
        {c_out, sum}  = a + b + c_in;
    <span class="kw">end</span></code></pre></div>
<h1 id="section-2">10/1/17</h1>
<p>First assignment is posted, it shouldn't take more than 5 minutes to complete.</p>
<p>For behaviour modelling, we have a lot of useful SystemVerilog constructs:</p>
<ul>
<li>if-else: <code>if (expression) statement1 else statement2</code></li>
<li>case-swtich: <code>case (expression) expression1: statement1; expression2: statement2; default: statement4 endcase</code> (default case is optional)</li>
<li>for/while/repeat/forever: <code>repeat(10) begin statements end</code> (avoid these if at all possible - they aren't always sythesizable, only usable in simulations).</li>
</ul>
<p>Note that with if statements and other conditionals, if we don't explicitly set the value of a logic, then it retains its current value.</p>
<p>Let's implement a mux:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> mux_2_input(<span class="dt">output</span> logic d, <span class="dt">input</span> i0, i1, select);
    <span class="kw">always</span> @ *
        <span class="kw">case</span> (select)
            <span class="dv">0</span>: d = i0;
            <span class="dv">1</span>: d = i1;
            <span class="kw">default</span>: d = z; <span class="co">// the default case handles unknown and high impedance - we&#39;ll just turn the output off (high impedance)</span></code></pre></div>
<h2 id="synchronous-circuits">Synchronous Circuits</h2>
<p>Recall that a synchronous circuit is one that only updates on a clock edge. In this course our synchronous circuits are updated on the rising edge of the clock (CMOS is actually clocked on the falling edge).</p>
<p>A test bench for a synchronous circuit needs to generate a clock signal. This might look like the following:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> synchronous_test_bench;
    logic clk;
    <span class="kw">initial</span> <span class="kw">begin</span>
        clk = <span class="dv">1</span>;
        <span class="kw">forever</span> <span class="bn">#5</span> clk = ~clk;
    <span class="kw">end</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Blocks can be triggered on edge events, like <code>always @ (posedge clk)</code> (trigger on rising edge) or <code>always @ (negedge clk)</code>.</p>
<p>SystemVerilog actually has two assignment operators. <code>=</code> is a blocking assignment, where all updates happen in order (we use this for combinational logic). <code>&lt;=</code> is non-blocking assignment, where all the right hand sides are computed before the updates happen (this is used for register-like or latched output). For example, <code>a &lt;= b; b &lt;= a</code> swaps <code>a</code> and <code>b</code>, while <code>a = b; b = a</code> just sets <code>a</code> to <code>b</code>. Generally, we prefer <code>&lt;=</code> over <code>=</code> when possible, so everywhere outside of combinational logic (we generally want outputs to all update at once, at the end of an update).</p>
<p>System Verilog uses <strong>discrete event simulation</strong>. Simulations consist of concurrent processes, primitives, modules, procedural blocks, and continuous assignments. Changes to signals are <strong>update events</strong>, and processes respond to events they are sensitive to and add them to a process-specific event queue, which are then executed.</p>
<p>System Verilog lets us define constants with <code>parameter some_constant = 8</code>. This is often used to define how many bits a particular element is. There's also enumerations, like <code>enum bit[1:0] {IDLE, REQUEST, WAIT, RECEIVE} state</code>. Logics can also be defined as arrays, like <code>logic [7:0] some_array [0:3];</code> (array of 4 8-bit registers), and are accessed with <code>y = a[2]</code> and so on.</p>
<p>System Verilog has various &quot;system tasks&quot;, which trigger actions during simulations. For example, <code>$display(...)</code> outputs to console, <code>$monitor(...)</code> outputs to console whenever the given signals are updated, and <code>$stop</code> stops the simulation.</p>
<h1 id="section-3">12/1/17</h1>
<p>Complex number multiplier:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// recall that given two complex numbers $a$ and $b$, $p = a \times b = (\Re(a)\Re(b) - \Im(a)\Im(b)) + \imag (\Re(a)\Im(b) + \Im(a)\Re(b))$</span>
<span class="co">// this needs 4 multiplications, 1 subtract, and 1 add</span>
<span class="co">// we will use a synchronous circuit with one multiplier and one adder/subtractor to do this, in order to demonstrate synchronous design, and also to save space (at the expense of it being slower)</span>
<span class="co">// therefore, we break the operation into 5 steps, each one only using one multiplication or one addition: `pp1 &lt;= a_real * b_real`, `pp2 &lt;= a_imag * b_imag`, `p_real &lt;= pp1 - pp2`, `pp1 &lt;= a_real * b_imag`, `pp2 &lt;= a_imag * b_real`, and `p_imag = pp1 + pp2`, which we can implement with an FSM</span>
<span class="kw">module</span> complex_multiplier(
    <span class="dt">output</span> logic <span class="dt">signed</span> [<span class="dv">7</span>:-<span class="dv">24</span>] p_r, p_i, <span class="co">// this defines `pr_` and `p_i` as fixed-point numbers with 24 bits to the right of the decimal point, and 7 bits to the left (actual value is the value of `p_r`/`p_i` as a two&#39;s complement integer, divided by $2^{24}$)</span>
    <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:-<span class="dv">12</span>] a_r, a_i, b_r, b_i,
    <span class="dt">input</span> clk, reset, go <span class="co">// the clock input, reset signal, and the trigger that starts the multiplication</span>
);
    logic a_sel, b_sel, pp1_en, pp2_en, sub, p_r_en, p_i_en;
    logic <span class="dt">signed</span> [<span class="dv">3</span>:-<span class="dv">12</span>] a_operand, b_operand;
    logic <span class="dt">signed</span> [<span class="dv">7</span>:-<span class="dv">24</span>] pp, sum; <span class="co">// partial product, sum</span>
    logic <span class="dt">signed</span> [<span class="dv">7</span>:-<span class="dv">24</span>] pp1, pp2;
    
    <span class="co">// multiplier with two multiplexers for input, to select inputs between real/imaginary components of `a` and `b`</span>
    <span class="kw">assign</span> a_operand = ~a_sel ? a_r : a_i;
    <span class="kw">assign</span> b_operand = ~b_sel ? b_r : b_i;
    <span class="kw">assign</span> pp = a_operand * b_operand;

    <span class="co">// update pp1 and pp2 registers on clock edge</span>
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (pp1_en) pp1 &lt;= pp;
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (pp2_en) pp2 &lt;= pp;
    
    <span class="kw">assign</span> sum = ~sub ? pp1 + pp2 : pp1 - -pp2;
    
    <span class="co">// update output registers on clock edge</span>
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (p_r_en) p_r &lt;= sum;
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (p_i_en) p_i &lt;= sum;
    
    <span class="co">// finite state machine to drive the above hardware</span>
    enum bit [<span class="dv">2</span>:<span class="dv">0</span>] { step0, step1, step2, step3, step4 } current_state, next_state;
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk <span class="dt">or</span> <span class="kw">posedge</span> reset)
        <span class="kw">if</span> (reset) current_state &lt;= step0;
        <span class="kw">else</span> current_state &lt;= next_state;
    <span class="kw">always</span> @ * <span class="kw">begin</span> <span class="co">// update whenever go or current_state change</span>
        <span class="kw">case</span> (current_state)
            <span class="dv">step0:</span> next_state = go ? step1 : step0;
            <span class="dv">step1:</span> next_state = step2;
            <span class="dv">step2:</span> next_state = step3;
            <span class="dv">step3:</span> next_state = step4;
            <span class="dv">step4:</span> next_state = step0;
        <span class="kw">endcase</span>
    <span class="kw">end</span>
    <span class="kw">always</span> @ (current_state, reset) <span class="kw">begin</span>
        a_sel; b_sel = <span class="dv">0</span>; pp1_en = <span class="dv">0</span>; pp2_en = <span class="dv">0</span>;
        sub = <span class="dv">0</span>; p_r_en = <span class="dv">0</span>; p_i_en = <span class="dv">0</span>;
        <span class="kw">case</span> (current_state)
            <span class="dv">step0:</span> <span class="kw">begin</span> pp1_en = <span class="dv">0</span>; <span class="kw">end</span>
            <span class="dv">step1:</span> <span class="kw">begin</span> a_sel = <span class="dv">1</span>; b_sel = <span class="dv">1</span>; pp2_en = <span class="dv">1</span>; <span class="kw">end</span>
            <span class="dv">step2:</span> <span class="kw">begin</span> b_sel = <span class="dv">1</span>; pp1_en = <span class="dv">1</span>; sub = <span class="dv">1</span>; sub = <span class="dv">1</span>; p_r_en = <span class="dv">1</span>; <span class="kw">end</span>
            <span class="dv">step3:</span> <span class="kw">begin</span> a_sel = <span class="dv">1</span>; pp2_en = <span class="dv">1</span>; <span class="kw">end</span>
            <span class="dv">step4:</span> <span class="kw">begin</span> p_i_en = <span class="dv">1</span>; <span class="kw">end</span>
        <span class="kw">endcase</span>
    <span class="kw">end</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Verilog has sized literals for numbers. For example, <code>16'h0001</code> means a 16-bit hexadecimal value 1, <code>1'b1</code> means the 1-bit binary value 1, and <code>4'd8</code> means the 4-bit decimal value 8.</p>
<p>Overview of assignment 1. Assignment involves filling out Verilog module stubs and writing test benches.</p>
<h1 id="section-4">17/1/17</h1>
<p>Room has been moved to HH 1102, which should be a lot closer to campus than OPT.</p>
<h2 id="processor-design">Processor Design</h2>
<p>There are multiple levels of abstraction when talking about a processor design. From most abstract to least abstract, the main ones are:</p>
<ul>
<li>Instruction-set architecture (ISA) - defines functional behaviour like instruction format, addressing modes, hazards, registers, privileges, exceptions, etc. For example, IA32 (also known as x86), IA64/AMD64 (also known as x86-64), PowerPC, MIPS, ARM, RISC-V.</li>
<li>Microarchitecture - defines the hardware structure like pipeline structure, cache organization, branch prediction schemes. For example, Intel i386, Intel i486, Intel Skylake, MIPS R16000.</li>
<li>Implementation - defines physical realization like gate design, transistor technology, fabrication technology.</li>
</ul>
<p>In the 1980s the main focus in processor design was improving single core performance and clock speed. Today, focus is on more cores at a lower clock speed, and doing more with each cycle (modern Intel CPUs can do 4-8 instructions per cycle!). New microarchitecture-level techniques like instruction-level parallelism (parallelism within 1 thread) and hyperthreading (parallelism between multiple threads on one core), speculative execution (running both sides of a branch and then throwing away the wrong one once the branch is done), out of order execution (rearranging instructions to improve parallelism) have also resulted in significant performance gains. The main issue preventing more single core performance and clock speed is the <strong>power wall</strong>.</p>
<p><strong>Dynamic power consumption</strong> is the power consumed that depends on the processor workload. When a transistor switches, it must use energy proportional to the capacitive load times the voltage squared. So the power used (switching frequency times switching energy) quicky increases linearly with the switching frequency, resulting in increased cooling requirements and worse battery life. One technique modern processors use to try to get around this is to reduce the switching voltage to quadratically reduce the switching energy required - for example, a 15% reduction in voltage results in a 28% reduction in switching energy.</p>
<p>There's also <strong>static energy consumption</strong>, the power consumed regardless of the processor workload. As transistors get smaller, the leakage current increases (due to quantum tunneling in the transistor junctions), which means more power used per transistor.</p>
<p>Modern techniques involve thread-level parallelism (doing multiple tasks at once), and data-level parallelism (doing something to multiple pieces of data at once).</p>
<p><strong>Fynn's taxonomy</strong> characterizes four classes of parallelism:</p>
<ul>
<li>Single-instruction single-data - single processing unit acting on single pieces of data. For example, a core calculating one scalar value. For these, we can take advantage of instruction-level parallelism.</li>
<li>Single-instruction multiple-data - single processing unit acting on multiple pieces of data. For example, DSP units, GPUs, vector instructions. For these, we can take advantage of data-level and instruction-level parallelism.</li>
<li>Multiple-instruction single-data - multiple processing units acting on single pieces of data. Not really used in practice.</li>
<li>Multiple-instruction multiple-data - multiple processing units acting on multiple pieces of data. For example, multithreading and multiprocessing. For these, we can take advantage of thread-level, data-level, and instruction-level parallelism.</li>
</ul>
<p>Recall MIPS:</p>
<ul>
<li>32-bit instructions, in one of two formats. First format: 6 bits for opcode, 5 bits for register operand 1, 5 bits for register operand 2, upper 16 bits for immediate value. Second format: 6-bit opcode, 5 bits each for register operand 1, 2, and 3, 5-bit shift amount, and 6-bit shift type specifier. See CS241 notes for more details about MIPS instructions.</li>
<li>32 registers R0 to R31, R0 always has value 0.</li>
<li>In this course, we'll use a 5-stage pipeline for fetch, decode, execute, memory, and writeback. We can overlap up to 5 instructions at once.</li>
<li>Instruction flow is linear (statically scheduled), and one instruction is completed per cycle (ideally). In other words, instructions are run in whatever order they're stored as, and we don't dynamically rearrange to improve parallelism.</li>
</ul>
<h1 id="section-5">19/1/17</h1>
<p>Sometimes instructions in a pipeline depend on others. There are three main types of these dependencies:</p>
<ul>
<li>A read-after-write dependency is when an instruction needs to read out the value that some other instruction wrote - if the CPU ran both at once, we might read the wrong value. This is the only real dependency in scalar, statically-scheduled pipelines.</li>
<li>A write-after-read dependency is an anti-dependency - if the CPU reorders these instructions so that they're in the opposite order, we might read the wrong value.</li>
<li>A write-after-write dependency is an output dependency - if the CPU reorders these instructions so that they're in the opposite order, the final value of the register may be wrong.</li>
</ul>
<p>When instructions aren't dependent on each other, we can more-or-less freely rearrange them. This allows efficient pipelining and parallelism.</p>
<p><strong>Total sequential execution</strong> (TSE) is an assumption in our programming model that one instruction finishes before the next starts. TSE is sufficient but not necessary for semantic correctness. In fact, semantic correctness can be satisfied just by satisfying the inter-instruction dependencies of the original program - we can otherwise rearrange and overlap instructions however we want.</p>
<p>Since we have five stages (fetch, decode, execute, memory, writeback), an instruction that writes registers takes 4 cycles after it's been fetched before the write actually takes effect, assuming 1 cycle per pipeline stage. Likewise, an instruction that reads registers takes 1 cycle after fetching before actually performing the read.</p>
<p>A control dependency is basically a special case of a register dependency, where the register is the program counter. An instruction that branches (writes to the program counter) has its write take effect 1 cycle after being fetched (the MIPS datapath reads PC in fetch stage and writes in decode stage).</p>
<p>In the same way, an instruction that writes to memory has a memory dependency, and has its write take effect 3 cycles after being fetched.</p>
<p>Therefore, if we have two instructions <span class="math inline">\(A, B\)</span> that run at clock cycle <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, respectively, such that <span class="math inline">\(i &gt; j\)</span>:</p>
<ul>
<li>If there is a read-after-write register dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 1 &gt; i + 4\)</span>. Hazards occur if <span class="math inline">\(j - i \le 3\)</span>.</li>
<li>If there is a write-after-read register dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 4 &gt; i + 1\)</span>. Hazards are impossible without reordering instructions.</li>
<li>If there is a write-after-write register dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 4 &gt; i + 4\)</span>. Hazards are impossible without reordering instructions.</li>
<li>If there is a read-after-write control dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 0 &gt; i + 1\)</span>. Hazards occur if <span class="math inline">\(j - i \le 1\)</span>.</li>
<li>If there is a write-after-read control dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 1 &gt; i + 0\)</span>. Hazards are impossible without reordering instructions.</li>
<li>If there is a write-after-write control dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 1 &gt; i + 1\)</span>. Hazards are impossible without reordering instructions.</li>
<li>If there is a read-after-write memory dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 3 &gt; i + 3\)</span>. Hazards are impossible without reordering instructions.</li>
<li>If there is a write-after-read memory dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 3 &gt; i + 3\)</span>. Hazards are impossible without reordering instructions.</li>
<li>If there is a write-after-write memory dependency from <span class="math inline">\(B\)</span> on <span class="math inline">\(A\)</span>, we must satisfy <span class="math inline">\(j + 3 &gt; i + 3\)</span>. Hazards are impossible without reordering instructions.</li>
</ul>
<p>A <strong>hazard</strong> is a potential for a violated dependency (and therefore, violation of semantic correctness). In our pipelined, statically scheduled CPU, the hazards are a 3-cycle register read-after-write, and a 1-cycle control read-after-write.</p>
<p>To avoid hazards, we can insert no-op instructions - 3 NOP instructions after each register read-after-write, or 1 after every control read-after-write. These can be inserted either by the compiler, or the CPU can stall for the necessary number of cycles when the relevant dependencies are found. Compilers</p>
<p>However, a 3-cycle stall for a 3-cycle register read-after-write is quite long. We can shorten register/memory dependency stalls by using <strong>data forwarding</strong> - routing the output of later stages directly to earlier stages to avoid the need for a write/read - earlier stages can read directly from the later stages.</p>
<p>For our purposes, we can route the output of the memory stage to the execute stage (for <span class="math inline">\(j = i + 1\)</span>), the output of the writeback stage to the execute stage (for <span class="math inline">\(j = i + 2\)</span>), and the output of the writeback stage to the decode stage (for <span class="math inline">\(j = i + 3\)</span>). With that in place, each stage always has the data it needs, so we never have to stall.</p>
<p>To implement data forwarding in each stage, we can use multiplexers that choose between either reading/writing registers, or taking input directly from later stages.</p>
<p>Turns out, this can't eliminate all our stalls, though it does make a lot of them much shorter. Consider <code>lw R1, (R2)</code> followed by <code>add R4, R1, R1</code> - the load-word instruction doesn't have its result until the memory stage is done, so we must stall the <code>add</code> for 1 cycle so we can forward it from the write-back stage to the execute stage.</p>
<p>To solve the control dependency read-after-write stall (when we have a conditional branch), we might assume that the branch won't happen, keep executing the next instruction, and then squash/suppress it in the pipeline if we do end up taking the branch.</p>
<p>MIPS uses a different approach - the CPU will execute the instruction after the branch (the instruction after the branch is in a position called the <strong>branch delay slot</strong>), regardless of whether the branch is taken or not. The compiler will generally try to fill the branch delay slot with an instruction that doesn't depend on the branch, or NOP if it can't find one.</p>
<h1 id="section-6">24/1/17</h1>
<p>Recall that in <strong>static scheduling</strong>, instructions are executed in the order that they appear in, and the compiler is responsible for arranging instructions in a way that avoids hazards.</p>
<p>Code example with instruction reordering by the compiler for hazard avoidance.</p>
<p>The cycles per instruction (CPI) is a measure of CPU performance, and is ideally somewhere around 1 for our scalar processor. However, penalty cycles caused by hazards will increase this. For example, if we have 6 instructions that incur 3 penalty cycles, we get <span class="math inline">\(\frac{6 + 3}{6} = 1.5\)</span> as the CPI.</p>
<p>The program execution time is <span class="math inline">\(\frac{n \times \text{CPI}}{f}\)</span>, where <span class="math inline">\(n\)</span> is the number of instructions in the basic block, and <span class="math inline">\(f\)</span> is the clock frequency.</p>
<p><strong>Local scheduling</strong> is when the compiler rearranges instructions within a basic block. A <strong>basic block</strong> is a sequence of consecutive instructions such that if one instruction is executed, all of them are - that means only the first instruction can be the target of a branch instruction, and only the last instruction can be a branch instruction (or the second to last for MIPS, due to the branch delay slot).</p>
<p>To perform local scheduling, we first identify the hazards in the code, leaving slots to put other instructions in according to how many penalty cycles are present. For example, if we have a load followed by a dependent add instruction, we might have 1 penalty cycle in our architecture, so we would leave one slot for an instruction. Then, we try to fill in the slots with other instructions while keeping dependencies satisfied.</p>
<p><strong>Global scheduling</strong> is when the compiler rearranges instructions across multiple basic blocks.</p>
<p>A common example of this is loop unrolling, where the body of a loop known to execute <span class="math inline">\(n\)</span> times is simply duplicated <span class="math inline">\(n\)</span> times - this reduces branching overhead, and makes local scheduling better since it may result in larger basic blocks. While loop unrolling can make our code faster, it results in larger programs, which might cause more instruction cache misses. The compiler must make the tradeoff depending on what would be faster.</p>
<h1 id="section-7">26/1/17</h1>
<p>Project part 1 marks come out on Monday. Part 2 is out on the course website, building a 5-stage MIPS pipeline. In-class overview of assignment.</p>
<p>In the scalar pipelines we are looking at, exceptions are events that alter program flow. Exceptions are harder to handle than normal program flow because they can occur at any time, and we must make sure registers and memory are properly stored/restored to ensure the TPE assumption is upheld.</p>
<p>Exceptions can be generated by things like interrupts from peripherals, unusual cases for some instructions (invalid opcode, page fault), and trap instructions (instructions that invoke the OS).</p>
<p>Precise exceptions are those that are recoverable - we can return to thread after the exception is handled.</p>
<p>What if we have multiple instructions that generate exceptions simultaneously in the pipeline? For example, we might have a load instruction that tries to dereference a null pointer at the memory stage, while we're trying to decode an invalid instruction in the decode stage - the load instruction generates an exception from the memory stage, and the invalid instruction generates one at the decode stage. To make sure we handle all instructions in the pipeline, we only mark the instruction as having caused an error, then actually handle them in the write-back stage.</p>
<p>There are three types of exceptions:</p>
<ul>
<li><strong>Interrupts</strong> are asynchronous exceptions, usually caused by peripherals like keyboards and timers.
<ul>
<li>When an interrupt occurs: the pipeline stops fetching, runs until the pipeline is empty (the pipeline is <strong>drained</strong>), saves state, invokes the interrupt handler routine, restores state, and then jumps to the next instruction in the interrupted thread..</li>
</ul></li>
<li><strong>Faults</strong> are synchronous exceptions, handled in write-back stage.
<ul>
<li>When a fault occurs: the pipeline stops fetching, cancels all instructions in the pipeline (the pipeline is <strong>flushed</strong>), saves state, invokes the fault handler routine, restores state, and then jumps back to the instruction that caused the fault.</li>
</ul></li>
<li><strong>Traps</strong> are synchronous exceptions, detected in write-back stage.
<ul>
<li>When a fault occurs: the pipeline stops fetching, finishes the trap, cancels all instructions in the pipeline (the pipeline is <strong>flushed</strong>), saves state, invokes the trap handler routine, restores state, and then jumps to the instruction after the one that caused the trap.</li>
</ul></li>
</ul>
<p>Very Long Instruction Word (WLIV) architectures are architectures that have very large instructions, generally able to issue multiple operations at once. For example, Intel Itanium has 128-bit instructions, able to contain up to 3 operations each.</p>
<p>If and only if an architecture can handle multiple instructions per cycle, it is known as a <strong>superscalar architecture</strong>.</p>
<p>VLIW architectures are generally statically scheduled, where each instruction contains multiple scalar operations. They generally don't do hazard detection or even full data forwarding, instead relying on the compiler to schedule operations in a good way.</p>
<p>The advantage of VLIW architectures is that the compiler gets more control over the scheduling and how different functional units (FPUs, ALUs, etc.) are used, so we can devote more transistors to the actual functional units themselves, rather than hazard detection and so on.</p>
<p>Consider a VLIW architecture where each instruction contains two memory operations, two floating point operations, and one ALU/branch operation. Each operation can have its own pipeline, so we'll give memory operations the usual fetch/decode/execute/memory/writeback, floating point operations a fetch/decode/execute 1/execute 2/execute 3/writeback pipeline, and ALU/branch operations a fetch/decode/execute/writeback pipeline. We'll also say branches resolve in the decode stage for all types of operation, so we need 1 branch delay slot (since decode is 1 pipeline stage after fetch).</p>
<p>Fetches occur at the same time for every pipeline - one instruction is fetched for every cycle.</p>
<p>Assuming full data forwarding is implemented, the latency of memory operations could be up to 1 if the execute stage has a dependency on the memory stage, the latency of ALU/branch operations could be up to 1 if the decode stage has a dependency on the execute stage, and the latency of floating point operations could be up to 2 if the execute 1 stage has a dependency on the execute 3 stage.</p>
<p><strong>Slot utilization</strong> is how well the available operation slots for each instructions are filled, defined as <span class="math inline">\(\frac{\text{slots filled}}{\text{number of instructions} \times \text{slots per instruction}}\)</span>.</p>
<h1 id="section-8">31/1/17</h1>
<p>;wip: global scheduling, software pipelining, catch up on the rest, gotta run for interviews</p>
<h1 id="section-9">2/1/17</h1>
<p>VLIW processors have many techniques for improving throughput and parallelism.</p>
<p><strong>Speculative execution</strong> is basically just when we keep executing down the predicted path when we reach a branch, regardless of whether that path is actually taken or not, and then undoing the effects of that if we don't end up taking the predicted path. Implemented correctly, it eliminates branch delays when the branch predictor is right.</p>
<p><strong>Speculative loading</strong> is a technique in which the compiler tries to move memory load instructions upward to avoid memory latency, even if they possibly won't be needed, like if a branch isn't taken.</p>
<p>In the IA-64 architecture, the Advanced Load Address Table (ALAT) is a unit of bidirectional associative memory used to implement speculative loading.</p>
<p>In IA-64, we denote speculative instructions with the <code>.s</code> suffix - <code>ld8.s</code> is the speculative version of <code>ld8</code>. We denote an advanced load version of the load instruction with the <code>lw8.a</code> suffix, and the ALAT check version of loads with <code>lw8.c</code>. Each <code>lw8.a</code> instruction is paired up with a <code>lw8.c</code> instruction later on - the <code>lw8.a</code> instruction starts the actual data transfer into the ALAT, and then when the corresponding <code>lw8.c</code> instruction is encountered, we can just load it from the ALAT rather than making a trip all the way to memory. Cache entries are invalidated if their addresses are stored to in between those instructions.</p>
<p><strong>Deferred exceptions</strong> are a technique for making speculative execution easier. If we want to hoist an instruction above a conditional branch, and the exception causes an exception at runtime, we need a way to mark the instruction in a way that the exceptions are only handled if the conditional branch isn't taken, in order to make sure the hoisted code works the same as the original.</p>
<p>Consider a <code>LW R1, (R5)</code> instruction, which gets hoisted above a <code>BEQZ R4, L1</code> instrucion. To implement deferred exceptions, we can add a poison bit to each register, and if and only if the speculatively executed instruction raises an exception, we can set the poison bit instead. Then, when we reach the original instruction, we can check for the poison bit being set, and if it is, actually raise the exception there.</p>
<p>;wip: read textbook section 3.5.6</p>
<p><strong>Predicated execution</strong> is a technique in which instructoins only commit their results if some predicate is true. This is useful because we can often avoid branches and use predicates instead, therefore avoiding branch delays. IA-64, for example, has 64 1-bit predicate registers, which can be set by various operations like comparison, and used to enable/disable different instructions.</p>
<p>Predicated execution essentially lets the compiler turn control dependencies into data dependencies, by letting it change branches into predicated instructions. All of the instructions run, but only the ones with true predicates will actually have an effect. It's very useful when we have lots of small basic blocks.</p>
<p>For example, in IA-64, we can denote <code>p1 = r1 == 0; p2 = r1 !== 0</code> as <code>cmp.eq p1, p2 = 0, r1;;</code>, where <code>p1</code> to <code>p64</code> are the predicate registers. Then, we can do <code>(p1) add r4 = r4, 1</code> to increment <code>r4</code> if and only if predicate register <code>p1</code> is 1.</p>
<p>The Itanium architecture, IA-64, was also called an EPIC architecture (explicitly parallel instruction computing - VLIW with data forwarding and dynamic events like cache misses). It has 128 65-bit (64 bits, plus a poison bit, called the Not-A-Thing bit) integer registers, 128 82-bit floating point registers, and 64 1-bit predicate registers.</p>
<h1 id="section-10">7/2/17</h1>
<h2 id="out-of-order-pipelines">Out of order pipelines</h2>
<p>Out of order pipelines dyanmically schedule instructions. The benefit is that they can take advantage of instruction-level parallelism not available at compile time, and allow us to make compilers a lot simpler, at the expense of more complicated CPUs.</p>
<p>When we're designing these pipelines, we need to design around hazards in register data, memory data, and control flow.</p>
<p>Out of order execution is inherently superscalar - there's no point in doing dynamic scheduling unless we have multiple functional units.</p>
<p>Scheduling is usually done using Tomasulo's algorithm, an improved version of previous techniques like scoreboarding. It was invented around 1967 and used for an IBM FPU.</p>
<p>Tomasulo's FPU has two functional units - a 2-stage pipelined, 2-cycle floating point adder, and a non-pipelined, 3-cycle floating point multiplier. The adder has 3 <strong>reservation stations</strong>, and the multiplier has 2.</p>
<p>The FPU also has 3 sets of registers:</p>
<ul>
<li>Float Registers (FLR) F0, F2, F4, F6 are the floating point registers used for FPU computation.</li>
<li>Float Load Buffer (FLB) stores 6 operands read from memory.</li>
<li>Store Data Buffer (SDB) stores 3 results to be written to memory.</li>
</ul>
<p>The <strong>common data bus</strong> allows parts of the FPU to broadcast a float along with a 4-bit source tag to specify where it came from (like a reservation station or the FLB).</p>
<p>Units like reservation stations, the FLR, and the SDB hold data and the data's tag.</p>
<p>The key concept here is the reservation station, and the use of tags to</p>
<p>Here's the FPU's workflow:</p>
<ol style="list-style-type: decimal">
<li>Up to two instructions are dispatched (in their original order) to the reservation station.</li>
<li>Operands are copied to the reservation station.</li>
<li>The destination register number is compared to the reservation station number.</li>
<li>Instructions are sent to the functional unit (adder or multiplier) when all of its operands are ready and the functional unit is free.</li>
<li>After computing the result, the functional broadcasts the result on the CDB, and waiting units like the FLR, reservation stations, and SDB update their contents.</li>
</ol>
<p>;wip: what even is this, read https://en.wikipedia.org/wiki/Tomasulo_algorithm#Implementation_concepts</p>
<p>Tomasulo's algorithm has imprecise exceptions. For example, if register F4 is renamed by instruction X in cycle 1 and renamed by instruction Y in cycle 2, then W never writes its result to register F4, so if W faults, then recovery isn't possible since the semantics require the result be written. There's no real way to recover from this except to restart the computation from an earlier point.</p>
<p>An out of order pipeline looks something like the following:</p>
<ul>
<li>Fetch - retrieve multiple instructions per cycle (in order).</li>
<li>Decode - identify instruction boundaries, opcodes, operands (in order).
<ul>
<li>For Intel x86 processors, CISC instructions are translated into internal RISC instructions.</li>
</ul></li>
<li>Dispatch - send the decoded instructions off to the reservation stations (in order).</li>
<li>Issue - send instructions from reservation stations to the execution units (out of order).</li>
<li>Finish - broadcast result in the forwarding bus (out of order).</li>
<li>Commit - update destination registers in order (in order).</li>
<li>Retire - update memory-store instructions (in order).
<ul>
<li>This is where SW instructions actually take effect.</li>
</ul></li>
</ul>
<p>The <strong>re-order buffer</strong> (ROB) remembers program order, so we can put things back in order after the Issue stage. At the dispatch stage, each instruction gets an entry in the ROB. At the finish stage, the ROB entry is updated to ;wip. At the Commit stage, the ROB entry is removed.</p>
<p>The ROB also keeps track of which instructions raise exceptions, so we can handle them at the Commit stage of the pipeline (this is analogous to the Itanium case, where we used a poison bit to only raise exceptions when we reach the Writeback stage). This ensures that the processor state is correct/precise at the instruction that raised the exception, which allows us to recover from the exception.</p>
<p>The width of an out of order pipeline is the number of instructions dispatched/committed per cycle.</p>
<h1 id="section-11">9/2/17</h1>
<p>Assignment 1 (not project 1) is due after reading week. It's about scheduling instructions in a pipelined processor.</p>
<h3 id="register-renamingassignment">Register renaming/assignment</h3>
<p>Data dependencies within a block of code form a data-flow graph (DFG) in the processor, where each edge <span class="math inline">\(a \to b\)</span> represents the fact that <span class="math inline">\(b\)</span> depends on the result of <span class="math inline">\(a\)</span>, so <span class="math inline">\(b\)</span> shouldn't run before <span class="math inline">\(a\)</span>. To help us run Tomasulo's algorithm, we can draw out the DFG and arrange it to minimize height.</p>
<p>The longest path (also known as the critical path) within the dataflow graph is the minimum number of cycles we can execute those instructions in - this is called the <strong>dataflow limit</strong>. In other words, with one thread, it's impossible to execute faster than the length of the critical path of true dependencies.</p>
<p>Operations in the CPU produce values, which are then assigned to registers. The <strong>live range</strong> of a value is the range within the code starting from when the value is first written to a register, up to and including the last use (when the value is last read from the register).</p>
<p>DFGs can also have virtual dependencies between pairs of instructions, called <strong>false dependencies</strong>, which give us write-after-read or write-after-write hazards if we change the order of those instructions.</p>
<p>Since there are a limited number of registers, the compiler needs to recycle registers - the compiler can use a register for a new value after the current value has been read for the last time. However, reusing registers imposes write-after-read dependencies.</p>
<p><strong>Register renaming</strong> is a technique that tries to get rid of false data dependencies, which helps us get better parallelism. The</p>
<p>To implement this, each operation's output value is assigned to a temporary <strong>rename register</strong> within a rename register file. The actual destination register is associated with the rename register ID, and on the commit step, we can actually copy the value from the rename register to the destination register. If we have enough rename registers, we can essentially have single assignment for each register, eliminating false dependencies and allowing us to improve parallelism.</p>
<p>Register renaming is used by Tomasulo's algorithm.</p>
<p>In hardware, we have an <strong>ARF</strong> (architected register file), which maps architecture registers (R0-R31 in MIPS) to rename registers. The <strong>RRF</strong> (rename register file) has one entry for each ROB entry, and the</p>
<p>With ;wip, we replace the ARF with an RAT (register alias table), which maps registers R0-R31 to architected and rename register entries in the PRF. The RAT has two columns - the retirement RAT (which has indices of architected register in the PRF), and the front-end RAT (which points to renamed register indices in the PRF). In case of an exception, the retirement RAT is copied to the front-end RAT, which undoes any renames done by the instructions after the fault, allowing us to raise precise exceptions.</p>
<p>;wip: read textbook section 3.4.6 (or 5.3? dunno what the numbers mean) and https://en.wikipedia.org/wiki/Register_renaming</p>
<p>The PRF (physical register file) stores the actual contents of the architected and rename registers. The</p>
<p>Here's what this looks like:</p>
<ul>
<li>During dispatch:
<ul>
<li>Allocate an ROB entry</li>
<li>Allocate a reservation station entry</li>
<li>Rename the destination register of the operation in the PRF and RAT.</li>
<li>Copy operands from PRF (using front-end RAT) to reservation station (the values of the operands if the data is available, or the register number if not)</li>
<li>Rename the front-end RAT with the rename register number.</li>
</ul></li>
<li>On commit:
<ul>
<li>Update the retirement RAT.</li>
<li>Add the old PRF number to the PRF free list.</li>
</ul></li>
</ul>
<p><strong>Delayed read</strong> is a technique in which the reservation station only stored the operand tag and status of the data, rather than the data itself, reducing data duplication. It can also time instruction issuing to correspond with the broadcast of the result of the operation it depends on. ;wip: what</p>
<h1 id="section-12">14/2/17</h1>
<p>Register renaming is a technique for undoing the hazards caused by register recycling.</p>
<p>Speculative execution is a technique in which we predict the direction of a branch and start executing that path while the branch is being resolved. However, this presents issues for register renaming, because speculatively executed instructions need to rename registers too - we must make sure the effects of the renaming are undone if the branch turns out to be wrong. To do this, we can do either rollbacks or checkpointing.</p>
<p>To do rollbacks, we save frontend RAT entries into the ROB (reorder buffer) as soon as the speculative instruction is dispatched. To recover upon a mispredicted branch, we can copy back the rename register number from the ROB to the frontend RAT, one at a time, until the branch instruction is actually completed. This works, but it's quite slow because of all the copying we have to do over multiple cycles.</p>
<p>To do checkpointing, we save a full copy of the entire frontend RAT as soon as the speculative instruction is dispatched. The saved copy of the frontend RAT is copied back to the frontend RAT is copied back if we mispredict the branch. This can be a lot faster than rollbacks, but it requires more storage and hardware to support this, depending on how many branches we are speculating past.</p>
<p>For Intel Skylake chips, we have 224 ROB entries, 180-entry integer PRF, and 168-entry floating point PRF. Haswell chips support up to 48 checkpoints - the ability to speculatively execute 48 branches at once!</p>
<h2 id="memory-data-flow">Memory Data Flow</h2>
<p>Data in memory includes the data segments, stack, and heap. Loads usually start a chain of instructions, because they have to wait on RAM, which is slow compared to processors. How do these work with pipelined processors?</p>
<p>For store instructions:</p>
<ol style="list-style-type: decimal">
<li>Upon dispatch, calculate the effective address and store it with the data in the <strong>store buffer</strong> (SB).</li>
<li>After commit, write the store buffer entry out to the processor cache (so it gets written to RAM).</li>
</ol>
<p>For load instructions:</p>
<ol style="list-style-type: decimal">
<li>Upon dispatch, calculate the effective address, and read the data from either the store buffer (if available) or the processor cache (so it gets read from RAM).</li>
<li>After commit, broadcast the destination read on the forwarding bus, so the other units know that the destination register has been updated.</li>
</ol>
<p>We want to be able to issue store instructions out of order, to improve performance.</p>
<p>Speculative loads are loads performed under the assumption that they are unaliased to recent stores - loads that are done from the cache, not the store buffer. When we do speculative loads, we need to detect if the load gave a valid result, and if not, retry it.</p>
<p>The speculative load process:</p>
<ol style="list-style-type: decimal">
<li>Upon dispatch, calculate the effective address. If a committed store is in the store buffer, forward the data along the forwarding bus. Otherwise, get the data from the processor cache. Add the speculative load's location and effective address to the FLB (finished load buffer).</li>
<li>After commit, remove the created entry from the FLB.</li>
</ol>
<p>The store process, when using speculative loads, becomes:</p>
<ol style="list-style-type: decimal">
<li>Upon dispatch, calculate the effective address and store it with the data in the store buffer.</li>
<li>Upon commit, if aliased loads are present in the FLB, suppress those speculative loads. Write the store buffer entry out to the processor cache (so it gets written to RAM).</li>
</ol>
<p>This ensures that if a speculative load finishes before a store completes, the effect of the load gets undone.</p>
<p>Another technique for speeding up loads is <strong>data prefetching</strong>, where data gets loaded from RAM into the processor data cache before it's actually loaded, so when we actually load it, we can do so directly from the cache. For example, in AMD64 the the <code>prefetch</code> instruction does this.</p>
<p>Data prefetching can also be done automatically - hardware prefetchers might detect patterns of sequential access, strided access (access with a linear offset each time, like accessing the diagonals of a matrix or accessing the columns of a row-major ordered matrix). One downside of this is that it might bring in data we don't actually want, reducing cache hit rate. Some systems like SPARC have a separate cache for prefetched data, called the prefetch buffer, to avoid this issue.</p>
<h1 id="section-13">16/2/17</h1>
<p>Review of caching and memory (see ECE222 notes for more details):</p>
<ul>
<li>Cache lines store the tag (the other bits of the address, enough to reconstruct the address later), the flags (dirty, valid, etc.), and the data itself.</li>
<li>Direct-mapped caching: blocks of memory are mapped to cache lines according to their block index modulo the number of blocks.</li>
<li>Fully-associative caching: blocks of memory are mapped to cache lines in an LRU fashion, and associative memory allows lookup by block index.</li>
<li>Set-associative: the first few bits of the block index are used to determine which set of cache lines to map to, and each set of cache lines forms a fully associative cache (fully-associative caching can be thought of as 1-way set-associative caching, and direct-mapped caching can be thought of as all-way set-associative caching). Most instruction/data caches work best in practice at around 8-way set associative caching.</li>
<li>Three types of cache misses: compulsory (data has never been in the cache before), capacity (cache is too small to hold the data, so we kicked the data we needed earlier), conflict (the associativity is too low).</li>
<li>Suppose we have 32-bit addresses, and 1024 direct-mapped 64-byte cache lines. Then the first 16 bits of the address are stored as tags, the next 10 bits are used as the block index (because taking the bits before the block offset modulo 1024 is the same as just taking the last 10 bits), and the last 6 bits are for the offset within the block (addresses point to individual bytes).</li>
<li>Virtual memory provides protection against other processes modifying a given process' memory, and allows processes to work with a larger, virtual address space.</li>
<li>The MMU translates virtual to physical addresses. It translates the virtual page number to the physical segment number, and keeps the offset bits.</li>
<li>The MMU can use multiple different indexing modes:
<ul>
<li>PI/PT indexing (physical indexing, physical tagging) - MMU entries are indexed and tagged by physical addresses, which means translation from virtual to physical address completes before cache lookup starts - this is easy to implement but slow.</li>
<li>VI/PT indexing (virtual indexing, physical tagging) - MMU entries are indexed by virtual addresses but tagged by physical addresses, which means translation and cache lookup can occur in parallel. However, VI/PT results in the synonym problem, where physical blocks are cached in the MMU multiple times for shared memory, since each physical address can have a different virtual address for different processes. To solve this, the OS can do page colouring to make sure the virtual page number is always the same in all virtual address spaces. This is widely used in practice.</li>
<li>VI/VT (virtual indexing, virtual tagging) - MMU entries are indexed and tagged by virtual addresses, which means we only need to translate virtual page numbers to physical page numbers upon cache misses. This also has the synonym problem, but it also has the homonym problem, where the same virtual tag can refer to different possible physical blocks. OSs solve this by storing the process ID in the tag. This is rarely used in practice.</li>
</ul></li>
</ul>
<p>Intel's main competitive advantage nowadays is its superior branch prediction abilities.</p>
<p>In MIPS, control flow happens either as a branch instruction (which does PC-relative addressing), or as a jump (which does indirect addressing).</p>
<p>Speculative execution has three main concerns:</p>
<ul>
<li>Target speculation:
<ul>
<li>The <strong>branch target buffer</strong> maps branch instruction addresses to branch target addresses. It stores predictions for branches.</li>
<li>In the fetch stage for a branch instruction, if the branch target buffer has an entry for the address of this branch instruction, we load the branch target address into PC, giving us a 0-latency branch.</li>
<li>In the execute stage, the branch unit actually resolves the branch to validate whether the prediction is correct or not. If it correct, we can add/update the branch target buffer entry, or remove the branch target buffer entry if it wasn't correct (to delete the prediction).</li>
<li>This works well for branches, but not really for jumps, which use indirect addressing. For example, returning from a subroutine called from many places means that the branch target address will often change, causing frequent branch mispredictions.</li>
</ul></li>
</ul>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2017 Anthony Zhang.
</div>
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>
