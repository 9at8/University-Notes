<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CS450 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso.light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
</head>
<body onload="highlight()">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-68271407-1', 'auto');
    ga('send', 'pageview');

  </script>
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/resume.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="http://www.linkedin.com/pub/anthony-zhang/8b/aa5/7aa" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="https://twitter.com/anthony926535" class="contact">twitter</a></li>
    <span class="divider"></span>
    <li><a href="/anthony-zhang.asc" class="info">GPG key</a></li>
  </ul>
<p style="display:none"><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1 \right\rceil}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l'H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}^P)}
\]</span></p>
<h1 id="cs450">CS450</h1>
<p>Computer Architecture.</p>
<pre><code>Andrew Morton
Section 001
Email: andrew.morton@uwaterloo.ca
Website: https://www.student.cs.uwaterloo.ca/~cs450/w17/outline.shtml
Office Hours: Tuesdays/Thursdays 11:30am-12:30pm in EIT-4015
Tuesdays/Thursdays 1:00pm-2:20pm</code></pre>
<h1 id="section">3/1/16</h1>
<p>In this course, the main project (worth 30%) is to design a MIPS processor in Verilog. No required textbooks. The main topic is about how modern CPUs manage to achieve the performance that they do, building on top of the processor basics covered in earlier processor design courses.</p>
<p>There are also two written assignments (worth 20% total) and the final exam (worth 50%). Assignments have 4 grace days allowed.</p>
<p>Hardware description languages are used for modelling hardware, generally for the purpose of simulation or synthesis. Most complex digital hardware is designed using a hardware description language, which is then compiled and converted into specifications for FPGAs, ASICs, programmable logic, and so on.</p>
<p>The main hardware description languages in use today are System Verilog and VHDL. VHDL is more verbose and Ada-like, while Verilog is more minimalist and C-like. Most projects in industry use Verilog for this reason. System Verilog is a superset of plain Verilog, and all Verilog code works in System Verilog. There's also System C, which looks a lot more like C/C++, but it's not commonly used. In this course, we will be using Icarus Verilog (an implementation of System Verilog), version 10 or later (in order to get support for SystemVerilog).</p>
<p>The simplest/lowest-level of hardware modelling in System Verilog is <strong>gate-level modelling</strong>. At this level, we have logic gate primitives like AND/OR, and we can connect them together into circuits via <strong>wires</strong>:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"># <span class="ot">`a1</span>` is the name of the gate, which is optional but useful <span class="kw">for</span> labelling gates
# <span class="ot">`y</span>` is the gate <span class="dt">output</span>, <span class="dt">and</span> <span class="ot">`a</span>`/<span class="ot">`b</span>`/<span class="ot">`c</span>` are the gate inputs (<span class="ot">`and</span>` supports one <span class="dt">or</span> more of these inputs, <span class="dt">and</span> one <span class="dt">output</span>)
# the inputs <span class="dt">and</span> outputs are wires, identified by name - everywhere that same name is used can be thought of as being all connected together by a physical <span class="dt">wire</span>
<span class="dt">and</span> a1(y, a, b, c)

# every argument except the last are the NOT gate&#39;s outputs, <span class="dt">and</span> the last one is the <span class="dt">input</span>
<span class="dt">not</span> (y1, y2, a)</code></pre></div>
<h2 id="gate-level-modelling">Gate-level modelling</h2>
<p>In gate-level modelling, signal/wire values can be <code>0</code> (low), <code>1</code> (high), <code>x</code>/<code>X</code> (unknown/ignored value), or <code>z</code>/<code>Z</code> (high impedance).</p>
<p>Gate-level modelling for a full adder (addend bits as <code>a</code>/<code>b</code>, carry-in as <code>c_in</code>, carry-out as <code>c_out</code>, sum as <code>sum</code>):</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_gate_level_modelling.sv</span>
<span class="co">// for a full adder, `sum = a XOR b XOR c_in`, and `c_out = ((a XOR b) AND c_in) OR a AND b`</span>

<span class="kw">module</span> full_adder(<span class="dt">input</span> a, b, c_in, <span class="dt">output</span> c_out, sum);
    <span class="co">// a `logic` is basically a connection/wire - here, we&#39;re declaring our wires</span>
    <span class="co">// a `wire` is equivalent to a `wire logic`, which is a logic that supports multiple drivers</span>
    <span class="co">// generally, we just use logic unless we need multiple drivers - the compiler will choose the best structure depending on how they&#39;re used</span>
    <span class="co">// there are also `bit` and `byte`, which are basically logics that can only be 0 or 1, not X or Z</span>
    logic w1, w2, w3; <span class="co">// these are wires that are used for connecting gates in the full adder together</span>
    <span class="dt">xor</span> x1(w1, a, b);
    <span class="dt">xor</span> x2(sum, w1, c_in);
    <span class="dt">and</span> a1(w2, a, b);
    <span class="dt">and</span> a2(w3, w1, c_in);
    <span class="dt">or</span> o1(c_out, w2, w3);
<span class="kw">endmodule</span></code></pre></div>
<p>This is a <strong>design module</strong>. It fully specifies the full adder as a self-contained unit.</p>
<p>While this looks like normal procedural code, with various function calls, it is more intuitive to think of this as a series of logical declarations - as if each of the <code>xor</code>/<code>and</code>/<code>or</code> lines were all continuously running at the same time.</p>
<p>A <strong>test bench</strong> is a set of definitions that instantiates the design module, and simulates the circuit under different input conditions to test for functional correctness. For our full adder example:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_test_bench.sv</span>
<span class="kw">module</span> full_adder_test_bench;
    logic carry_in, x, y;
    logic carry_out, z;

    <span class="co">// &quot;dut&quot; stands for &quot;device under test&quot;</span>
    <span class="co">// below, we&#39;re basically instantiating a full adder (defined in the code above) that&#39;s connected to our logics, for testing purposes</span>
    <span class="co">// the `.name(other_name)` syntax is a &quot;named port map&quot;, which lets us connect logics to devices by signal name</span>
    <span class="co">// alternatively, we can just map the signals in order, like `full_adder dut(x, y, carry_in, carry_out, z)`, but this can cause issues if we change the inputs/outputs of the full adder</span>
    full_adder dut(.c_out(carry_out), .sum(z), .c_in(carry_in), .a(x), .b(y));

    <span class="co">// this is a procedural block - inside, the statements are evaluated sequentially from top to bottom</span>
    <span class="kw">initial</span> <span class="kw">begin</span> <span class="co">// run once at time 0</span>
        carry_in = <span class="dv">0</span>; x = <span class="dv">0</span>; y = <span class="dv">0</span>;
        <span class="co">// delays must be used to ensure statements actually run sequentially - statements in between delays all execute in parallel</span>
        <span class="bn">#10</span> x = <span class="dv">1</span>; <span class="co">// delay 10 time units, then continue and set x to 1</span>
        <span class="bn">#10</span> y = <span class="dv">1</span>; <span class="co">// delay 10 time units, then continue and set y to 1</span>
        <span class="bn">#10</span> carry_in = <span class="dv">1</span>; <span class="co">// delay 10 time units, then continue and set carry_in to 1</span>
        <span class="bn">#10</span> <span class="dt">$stop</span>; <span class="co">// delay 10 time units, then stop the simulation (this will not compile if trying to generate hardware from this)</span>
    <span class="kw">end</span>

    <span class="co">// now we want to dump the signals out into waveforms so we can see them</span>
    <span class="kw">initial</span> <span class="dt">$dumpvars</span>(<span class="dv">0</span>, full_adder_test_bench); <span class="co">// the first parameter is the dump level (`0` means &quot;dump all variables in the module and in the modules that instantiate it&quot;), and the rest of the parameters are the module or variables to dump</span>
<span class="kw">endmodule</span></code></pre></div>
<p>To compile, run <code>iverilog -g2005-sv -s full_adder_test_bench.sv -o full_adder.vvp full_adder.sv full_adder_test_bench.sv</code>:</p>
<ul>
<li><code>iverilog</code> is the Icarus Verilog compiler.</li>
<li><code>-g2005-sv</code> specifies that the compiler should use the 2005 System Verilog standard.</li>
<li><code>-s full_adder_test_bench.sv</code> specifies the top-level/root module.</li>
<li><code>-o full_adder.vvp</code> specifies the output for the compiled Verilog.</li>
<li><code>full_adder.sv full_adder_test_bench.sv</code> specifies the modules to include in the compilation.</li>
</ul>
<p>To simulate, run <code>vvp -n full_adder.vvp -lx2</code>:</p>
<ul>
<li><code>vvp</code> is the Icarus Verilog simulation tool.</li>
<li><code>-n</code> specifies that <code>$stop</code> and Control-C should complete the simulation.</li>
<li><code>full_adder.vvp</code> is the compiled Verilog file for the full adder.</li>
<li><code>-lx2</code> specifies that the simulation should be written in LXT2 format, which is slower to process but more compact allows viewing waveforms while the simulation is running.</li>
</ul>
<p>To view the waveforms: <code>gtkwave dump.lx2</code>:</p>
<ul>
<li><code>gtkwave</code> is the GTK waveform visualizer tool.</li>
<li><code>dump.lx2</code> is the simulation result generated by <code>vvp</code>.</li>
</ul>
<h1 id="section-1">5/1/17</h1>
<p>Live demonstration of the above Verilog workflow, including an overview of GtkWave's features and a shell script that builds and simulates the module.</p>
<p><strong>Heirarchical design</strong> is the idea of using lower-level modules in higher-level modules. For example, a carry-lookahead adder module might instantiate a few ripple-carry adders, which in turn might instantiate a bunch of full-adders:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// adder_4_bit.sv</span>
<span class="kw">module</span> adder_4_bit(<span class="dt">output</span> c_out, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">input</span> c_in, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, b);
    logic [<span class="dv">3</span>:<span class="dv">1</span>] carry;
    full_adder fa0(.c_out(carry[<span class="dv">1</span>]), .sum(sum[<span class="dv">0</span>]), .c_in(c_in), .a(a[<span class="dv">0</span>]), .b(b[<span class="dv">0</span>]));
    full_adder fa0(.c_out(carry[<span class="dv">2</span>]), .sum(sum[<span class="dv">1</span>]), .c_in(carry[<span class="dv">1</span>]), .a(a[<span class="dv">1</span>]), .b(b[<span class="dv">1</span>]));
    full_adder fa0(.c_out(carry[<span class="dv">3</span>]), .sum(sum[<span class="dv">2</span>]), .c_in(carry[<span class="dv">2</span>]), .a(a[<span class="dv">2</span>]), .b(b[<span class="dv">2</span>]));
    full_adder fa0(.c_out(c_out), .sum(sum[<span class="dv">3</span>]), .c_in(carry[<span class="dv">3</span>]), .a(a[<span class="dv">3</span>]), .b(b[<span class="dv">3</span>]));
<span class="kw">endmodule</span></code></pre></div>
<p>Note that there's a lot of similar statements for the full adder definitions. In these cases, we can use generate statements to remove duplicated code. It looks somewhat like a loop, but it's more of a macro that gets expanded into multiple statements at compile time:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// adder_4_bit_generate.sv</span>
<span class="co">// adder_4_bit.sv</span>
<span class="kw">module</span> adder_4_bit(<span class="dt">output</span> c_out, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">input</span> c_in, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, b);
    logic [<span class="dv">4</span>:<span class="dv">0</span>] carry;
    
    <span class="kw">generate</span>
        <span class="dt">genvar</span> i;
        <span class="kw">for</span>(i=<span class="dv">0</span>; i&lt;<span class="dv">4</span>; i=i<span class="dv">+1</span>) <span class="kw">begin:</span><span class="dt"> adder</span>
            full_adder fa(.c_out(carry[i<span class="dv">+1</span>]), .sum(sum[i]), .c_in(carry[i]) ,.a(a[i]), .b(b[i]));
        <span class="kw">end</span>
    <span class="kw">endgenerate</span>

    <span class="co">// since it would be really inconvenient to specify our c_in and c_out in the generate statement, we just used extra indices in the carry wire, and then assign the inputs/outputs accordingly</span>
    <span class="kw">assign</span> carry[<span class="dv">0</span>] = c_in; <span class="co">// this is a continuous assignment statement - it&#39;s sort of like a one-way wire for the c_in signal in this case, but it can also do things like combinational logic with different gates and stuff</span>
    <span class="kw">assign</span> c_out = carry[<span class="dv">4</span>]; <span class="co">// since the assignment is unidirectional, the inputs are on the right side of the equal sign, and the outputs are on the left side</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Usually for loops are discouraged, but they're fine for generate statements - in other contexts, they might not compile to actual hardware.</p>
<h2 id="dataflow-modelling">Dataflow modelling</h2>
<p>Dataflow modelling is the next level of abstraction above gate-level modelling. Dataflow modelling deals only with combinational circuits, by representing them with continuous assignment statements.</p>
<p>Basically, we represent what logical operations the circuit needs to do, and the compiler will figure out what kind of gate layout we need. For example, for a full adder it might automatically decide to reuse the <code>xor(a, b)</code> gate.</p>
<p>For example, we might model a full adder using dataflow modelling as follows:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_dataflow.sv</span>
<span class="kw">module</span> full_adder(<span class="dt">output</span> c_out, sum, <span class="dt">input</span> c_in, a, b);
    <span class="co">// the value of `sum` is continuously updated based on the values of `a`, `b`, and `c_in` - whenever any of those change, `sum` reflects the new value</span>
    <span class="co">// this updating is not true of all continuous assignment statements, however</span>
    <span class="kw">assign</span> sum = a ^ b ^ c_in;
    <span class="kw">assign</span> c_out = ((a ^ b) &amp; c_in) | (a &amp; b);

    <span class="co">// actually, Verilog has a `+` operator, so it&#39;s really as simple as `assign {c_out, sum} = a + b + c_in`</span>
    <span class="co">// `assign` will truncate the result of evaluating the right hand side, if the right hand side has more bits than the left</span>
    <span class="co">// `assign` will zero-extend the result of evaluating the right hand side, if the right hand side has fewer bits than the left</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Some of the available operators are <code>!</code> (logical NOT), <code>&amp;&amp;</code> (logical AND), <code>||</code> (logical OR), <code>+</code> (two's complement addition), <code>-</code> (two's complement subtraction), <code>*</code> (;wip), <code>/</code> (;wip), <code>%</code> (;wip), <code>**</code> (;wip), <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>, <code>~</code> (NOT), <code>&amp;</code> (AND), <code>|</code> (OR), <code>^</code> (XOR), <code>^~</code> (XNOR), <code>&lt;&lt;</code> (bit shift left), <code>&gt;&gt;</code> (bit shift right), <code>&lt;&lt;&lt;</code> (;wip), <code>&gt;&gt;&gt;</code> (signed shift right - extends sign bit), <code>{a_1, ..., a_n}</code> (concatenate <code>a_1</code> through to <code>a_n</code>), <code>{n{a}}</code> (replicate <code>a</code> by <code>n</code> times - repeatedly concatenate <code>a</code>), <code>c?a:b</code> (MUX - select <code>a</code> if <code>c</code> is high, <code>b</code> otherwise). They generally have precedence similar to their equivalents in C and Python.</p>
<p>For example, the nibbles of a byte can be swapped with <code>assign {b[3:0], b[7:4]} = a[7:0]</code>, and an 8-bit signed integer can be sign-extended to 16 bits with <code>assign b[15:0] = {{8{a[7]}}, a[7:0]}</code>.</p>
<p>With all these useful operators, it's pretty straightforward to make a 4-bit adder:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// full_adder_dataflow.sv</span>
<span class="kw">module</span> full_adder(<span class="dt">output</span> c_out, <span class="dt">output</span> [<span class="dv">3</span>:<span class="dv">0</span>] sum, <span class="dt">input</span> c_in, <span class="dt">input</span> [<span class="dv">3</span>:<span class="dv">0</span>] a, b);
    <span class="kw">assign</span> {c_out, sum} = a + b + c_in`
<span class="kw">endmodule</span></code></pre></div>
<h2 id="behaviour-modelling">Behaviour modelling</h2>
<p>Behaviour modelling is the next level of abstraction above dataflow-level modelling. It uses procedural blocks that are <code>initial</code>.</p>
<p>An <code>initial</code> block runs the statements inside of it once starting at time 0. An <code>always</code> block runs the statements inside of it whenever certain things change.</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">initial</span> <span class="co">// run once at time 0</span></code></pre></div>
<p>Here's a full adder implemented with behaviour modelling:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> full_adder(<span class="dt">input</span> c_in, a, b, <span class="dt">output</span> logic c_out, sum);
    <span class="co">// the `@ (c_in, a, b)` specifies the &quot;sensitivity list&quot;, which means the procedural block should be reevaluated whenever any of the logics in the list change</span>
    <span class="co">// in contrast, the `initial` statement doesn&#39;t have a sensitivity list because it simply runs once at the beginning</span>
    <span class="co">// the left hand sides of each assignment must be a `logic` or `reg` - that&#39;s why the outputs of this module are declared as `logic`</span>
    <span class="co">// we could also have written `always @ *` to make it re-evaluate the block whenever any of the signals on the right hand sides of any assignment statement changes</span>
    <span class="kw">always</span> @ (c_in, a, b) <span class="kw">begin</span>
        sum = a ^ b ^ c_in;
        c_out = ((a ^ b) &amp; c_in) | (a &amp; b);
    <span class="kw">end</span></code></pre></div>
<p>Alternatively:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> full_adder(<span class="dt">input</span> c_in, a, b, <span class="dt">output</span> logic c_out, sum);
    <span class="kw">always</span> @ (c_in, a, b) <span class="kw">begin</span>
        {c_out, sum}  = a + b + c_in;
    <span class="kw">end</span></code></pre></div>
<h1 id="section-2">10/1/17</h1>
<p>First assignment is posted, it shouldn't take more than 5 minutes to complete.</p>
<p>For behaviour modelling, we have a lot of useful SystemVerilog constructs:</p>
<ul>
<li>if-else: <code>if (expression) statement1 else statement2</code></li>
<li>case-swtich: <code>case (expression) expression1: statement1; expression2: statement2; default: statement4 endcase</code> (default case is optional)</li>
<li>for/while/repeat/forever: <code>repeat(10) begin statements end</code> (avoid these if at all possible - they aren't always sythesizable, only usable in simulations).</li>
</ul>
<p>Note that with if statements and other conditionals, if we don't explicitly set the value of a logic, then it retains its current value.</p>
<p>Let's implement a mux:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> mux_2_input(<span class="dt">output</span> logic d, <span class="dt">input</span> i0, i1, select);
    <span class="kw">always</span> @ *
        <span class="kw">case</span> (select)
            <span class="dv">0</span>: d = i0;
            <span class="dv">1</span>: d = i1;
            <span class="kw">default</span>: d = z; <span class="co">// the default case handles unknown and high impedance - we&#39;ll just turn the output off (high impedance)</span></code></pre></div>
<h2 id="synchronous-circuits">Synchronous Circuits</h2>
<p>Recall that a synchronous circuit is one that only updates on a clock edge. In this course our synchronous circuits are updated on the rising edge of the clock (CMOS is actually clocked on the falling edge).</p>
<p>A test bench for a synchronous circuit needs to generate a clock signal. This might look like the following:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="kw">module</span> synchronous_test_bench;
    logic clk;
    <span class="kw">initial</span> <span class="kw">begin</span>
        clk = <span class="dv">1</span>;
        <span class="kw">forever</span> <span class="bn">#5</span> clk = ~clk;
    <span class="kw">end</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Blocks can be triggered on edge events, like <code>always @ (posedge clk)</code> (trigger on rising edge) or <code>always @ (negedge clk)</code>.</p>
<p>SystemVerilog actually has two assignment operators. <code>=</code> is a blocking assignment, where all updates happen in order (we use this for combinational logic). <code>&lt;=</code> is non-blocking assignment, where all the right hand sides are computed before the updates happen (this is used for register-like or latched output). For example, <code>a &lt;= b; b &lt;= a</code> swaps <code>a</code> and <code>b</code>, while <code>a = b; b = a</code> just sets <code>a</code> to <code>b</code>. Generally, we prefer <code>&lt;=</code> over <code>=</code> when possible, so everywhere outside of combinational logic (we generally want outputs to all update at once, at the end of an update).</p>
<p>System Verilog uses <strong>discrete event simulation</strong>. Simulations consist of concurrent processes, primitives, modules, procedural blocks, and continuous assignments. Changes to signals are <strong>update events</strong>, and processes respond to events they are sensitive to and add them to a process-specific event queue, which are then executed.</p>
<p>System Verilog lets us define constants with <code>parameter some_constant = 8</code>. This is often used to define how many bits a particular element is. There's also enumerations, like <code>enum bit[1:0] {IDLE, REQUEST, WAIT, RECEIVE} state</code>. Logics can also be defined as arrays, like <code>logic [7:0] some_array [0:3];</code> (array of 4 8-bit registers), and are accessed with <code>y = a[2]</code> and so on.</p>
<p>System Verilog has various &quot;system tasks&quot;, which trigger actions during simulations. For example, <code>$display(...)</code> outputs to console, <code>$monitor(...)</code> outputs to console whenever the given signals are updated, and <code>$stop</code> stops the simulation.</p>
<h1 id="section-3">12/1/17</h1>
<p>Complex number multiplier:</p>
<div class="sourceCode"><pre class="sourceCode verilog"><code class="sourceCode verilog"><span class="co">// recall that given two complex numbers $a$ and $b$, $p = a \times b = (\Re(a)\Re(b) - \Im(a)\Im(b)) + \imag (\Re(a)\Im(b) + \Im(a)\Re(b))$</span>
<span class="co">// this needs 4 multiplications, 1 subtract, and 1 add</span>
<span class="co">// we will use a synchronous circuit with one multiplier and one adder/subtractor to do this, in order to demonstrate synchronous design, and also to save space (at the expense of it being slower)</span>
<span class="co">// therefore, we break the operation into 5 steps, each one only using one multiplication or one addition: `pp1 &lt;= a_real * b_real`, `pp2 &lt;= a_imag * b_imag`, `p_real &lt;= pp1 - pp2`, `pp1 &lt;= a_real * b_imag`, `pp2 &lt;= a_imag * b_real`, and `p_imag = pp1 + pp2`, which we can implement with an FSM</span>
<span class="kw">module</span> complex_multiplier(
    <span class="dt">output</span> logic <span class="dt">signed</span> [<span class="dv">7</span>:-<span class="dv">24</span>] p_r, p_i, <span class="co">// this defines `pr_` and `p_i` as fixed-point numbers with 24 bits to the right of the decimal point, and 7 bits to the left (actual value is the value of `p_r`/`p_i` as a two&#39;s complement integer, divided by $2^{24}$)</span>
    <span class="dt">input</span> <span class="dt">signed</span> [<span class="dv">3</span>:-<span class="dv">12</span>] a_r, a_i, b_r, b_i,
    <span class="dt">input</span> clk, reset, go <span class="co">// the clock input, reset signal, and the trigger that starts the multiplication</span>
);
    logic a_sel, b_sel, pp1_en, pp2_en, sub, p_r_en, p_i_en;
    logic <span class="dt">signed</span> [<span class="dv">3</span>:-<span class="dv">12</span>] a_operand, b_operand;
    logic <span class="dt">signed</span> [<span class="dv">7</span>:-<span class="dv">24</span>] pp, sum; <span class="co">// partial product, sum</span>
    logic <span class="dt">signed</span> [<span class="dv">7</span>:-<span class="dv">24</span>] pp1, pp2;
    
    <span class="co">// multiplier with two multiplexers for input, to select inputs between real/imaginary components of `a` and `b`</span>
    <span class="kw">assign</span> a_operand = ~a_sel ? a_r : a_i;
    <span class="kw">assign</span> b_operand = ~b_sel ? b_r : b_i;
    <span class="kw">assign</span> pp = a_operand * b_operand;

    <span class="co">// update pp1 and pp2 registers on clock edge</span>
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (pp1_en) pp1 &lt;= pp;
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (pp2_en) pp2 &lt;= pp;
    
    <span class="kw">assign</span> sum = ~sub ? pp1 + pp2 : pp1 - -pp2;
    
    <span class="co">// update output registers on clock edge</span>
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (p_r_en) p_r &lt;= sum;
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk)
        <span class="kw">if</span> (p_i_en) p_i &lt;= sum;
    
    <span class="co">// finite state machine to drive the above hardware</span>
    enum bit [<span class="dv">2</span>:<span class="dv">0</span>] { step0, step1, step2, step3, step4 } current_state, next_state;
    <span class="kw">always</span> @ (<span class="kw">posedge</span> clk <span class="dt">or</span> <span class="kw">posedge</span> reset)
        <span class="kw">if</span> (reset) current_state &lt;= step0;
        <span class="kw">else</span> current_state &lt;= next_state;
    <span class="kw">always</span> @ * <span class="kw">begin</span> <span class="co">// update whenever go or current_state change</span>
        <span class="kw">case</span> (current_state)
            <span class="dv">step0:</span> next_state = go ? step1 : step0;
            <span class="dv">step1:</span> next_state = step2;
            <span class="dv">step2:</span> next_state = step3;
            <span class="dv">step3:</span> next_state = step4;
            <span class="dv">step4:</span> next_state = step0;
        <span class="kw">endcase</span>
    <span class="kw">end</span>
    <span class="kw">always</span> @ (current_state, reset) <span class="kw">begin</span>
        a_sel; b_sel = <span class="dv">0</span>; pp1_en = <span class="dv">0</span>; pp2_en = <span class="dv">0</span>;
        sub = <span class="dv">0</span>; p_r_en = <span class="dv">0</span>; p_i_en = <span class="dv">0</span>;
        <span class="kw">case</span> (current_state)
            <span class="dv">step0:</span> <span class="kw">begin</span> pp1_en = <span class="dv">0</span>; <span class="kw">end</span>
            <span class="dv">step1:</span> <span class="kw">begin</span> a_sel = <span class="dv">1</span>; b_sel = <span class="dv">1</span>; pp2_en = <span class="dv">1</span>; <span class="kw">end</span>
            <span class="dv">step2:</span> <span class="kw">begin</span> b_sel = <span class="dv">1</span>; pp1_en = <span class="dv">1</span>; sub = <span class="dv">1</span>; sub = <span class="dv">1</span>; p_r_en = <span class="dv">1</span>; <span class="kw">end</span>
            <span class="dv">step3:</span> <span class="kw">begin</span> a_sel = <span class="dv">1</span>; pp2_en = <span class="dv">1</span>; <span class="kw">end</span>
            <span class="dv">step4:</span> <span class="kw">begin</span> p_i_en = <span class="dv">1</span>; <span class="kw">end</span>
        <span class="kw">endcase</span>
    <span class="kw">end</span>
<span class="kw">endmodule</span></code></pre></div>
<p>Verilog has sized literals for numbers. For example, <code>16'h0001</code> means a 16-bit hexadecimal value 1, <code>1'b1</code> means the 1-bit binary value 1, and <code>4'd8</code> means the 4-bit decimal value 8.</p>
<p>Overview of assignment 1. Assignment involves filling out Verilog module stubs and writing test benches.</p>
<h1 id="section-4">17/1/17</h1>
<p>Room has been moved to HH 1102, which should be a lot closer to campus than OPT.</p>
<h2 id="processor-design">Processor Design</h2>
<p>There are multiple levels of abstraction when talking about a processor design. From most abstract to least abstract, the main ones are:</p>
<ul>
<li>Instruction-set architecture (ISA) - defines functional behaviour like instruction format, addressing modes, hazards, registers, privileges, exceptions, etc. For example, IA32 (also known as x86), IA64/AMD64 (also known as x86-64), PowerPC, MIPS, ARM, RISC-V.</li>
<li>Microarchitecture - defines the hardware structure like pipeline structure, cache organization, branch prediction schemes. For example, Intel i386, Intel i486, Intel Skylake, MIPS R16000.</li>
<li>Implementation - defines physical realization like gate design, transistor technology, fabrication technology.</li>
</ul>
<p>In the 1980s the main focus in processor design was improving single core performance and clock speed. Today, focus is on more cores at a lower clock speed, and doing more with each cycle (modern Intel CPUs can do 4-8 instructions per cycle!). New microarchitecture-level techniques like instruction-level parallelism (parallelism within 1 thread) and hyperthreading (parallelism between multiple threads on one core), speculative execution (running both sides of a branch and then throwing away the wrong one once the branch is done), out of order execution (rearranging instructions to improve parallelism) have also resulted in significant performance gains. The main issue preventing more single core performance and clock speed is the <strong>power wall</strong>.</p>
<p><strong>Dynamic power consumption</strong> is the power consumed that depends on the processor workload. When a transistor switches, it must use energy proportional to the capacitive load times the voltage squared. So the power used (switching frequency times switching energy) quicky increases linearly with the switching frequency, resulting in increased cooling requirements and worse battery life. One technique modern processors use to try to get around this is to reduce the switching voltage to quadratically reduce the switching energy required - for example, a 15% reduction in voltage results in a 28% reduction in switching energy.</p>
<p>There's also <strong>static energy consumption</strong>, the power consumed regardless of the processor workload. As transistors get smaller, the leakage current increases (due to quantum tunneling in the transistor junctions), which means more power used per transistor.</p>
<p>Modern techniques involve thread-level parallelism (doing multiple tasks at once), and data-level parallelism (doing something to multiple pieces of data at once).</p>
<p><strong>Fynn's taxonomy</strong> characterizes four classes of parallelism:</p>
<ul>
<li>Single-instruction single-data - single processing unit acting on single pieces of data. For example, a core calculating one scalar value. For these, we can take advantage of instruction-level parallelism.</li>
<li>Single-instruction multiple-data - single processing unit acting on multiple pieces of data. For example, DSP units, GPUs, vector instructions. For these, we can take advantage of data-level and instruction-level parallelism.</li>
<li>Multiple-instruction single-data - multiple processing units acting on single pieces of data. Not really used in practice.</li>
<li>Multiple-instruction multiple-data - multiple processing units acting on multiple pieces of data. For example, multithreading and multiprocessing. For these, we can take advantage of thread-level, data-level, and instruction-level parallelism.</li>
</ul>
<p>Recall MIPS:</p>
<ul>
<li>32-bit instructions, in one of two formats. First format: 6 bits for opcode, 5 bits for register operand 1, 5 bits for register operand 2, upper 16 bits for immediate value. Second format: 6-bit opcode, 5 bits each for register operand 1, 2, and 3, 5-bit shift amount, and 6-bit shift type specifier. See CS241 notes for more details about MIPS instructions.</li>
<li>32 registers R0 to R31, R0 always has value 0.</li>
<li>In this course, we'll use a 5-stage pipeline for fetch, decode, execute, memory, and writeback. We can overlap up to 5 instructions at once.</li>
<li>Instruction flow is linear (statically scheduled), and one instruction is completed per cycle (ideally). In other words, instructions are run in whatever order they're stored as, and we don't dynamically rearrange to improve parallelism.</li>
</ul>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2017 Anthony Zhang.
</div>
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>