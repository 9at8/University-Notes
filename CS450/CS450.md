CS450
=====

Computer Architecture.

    Andrew Morton
    Section 001
    Email: andrew.morton@uwaterloo.ca
    Website: https://www.student.cs.uwaterloo.ca/~cs450/w17/outline.shtml
    Office Hours: Tuesdays/Thursdays 11:30am-12:30pm in EIT-4015
    Tuesdays/Thursdays 1:00pm-2:20pm

# 3/1/16

In this course, the main project (worth 30%) is to design a MIPS processor in Verilog. No required textbooks. The main topic is about how modern CPUs manage to achieve the performance that they do, building on top of the processor basics covered in earlier processor design courses.

There are also two written assignments (worth 20% total) and the final exam (worth 50%). Assignments have 4 grace days allowed.

Hardware description languages are used for modelling hardware, generally for the purpose of simulation or synthesis. Most complex digital hardware is designed using a hardware description language, which is then compiled and converted into specifications for FPGAs, ASICs, programmable logic, and so on.

The main hardware description languages in use today are System Verilog and VHDL. VHDL is more verbose and Ada-like, while Verilog is more minimalist and C-like. Most projects in industry use Verilog for this reason. System Verilog is a superset of plain Verilog, and all Verilog code works in System Verilog. There's also System C, which looks a lot more like C/C++, but it's not commonly used. In this course, we will be using Icarus Verilog (an implementation of System Verilog), version 10 or later (in order to get support for SystemVerilog).

The simplest/lowest-level of hardware modelling in System Verilog is **gate-level modelling**. At this level, we have logic gate primitives like AND/OR, and we can connect them together into circuits via **wires**:

```verilog
# `a1` is the name of the gate, which is optional but useful for labelling gates
# `y` is the gate output, and `a`/`b`/`c` are the gate inputs (`and` supports one or more of these inputs, and one output)
# the inputs and outputs are wires, identified by name - everywhere that same name is used can be thought of as being all connected together by a physical wire
and a1(y, a, b, c)

# every argument except the last are the NOT gate's outputs, and the last one is the input
not (y1, y2, a)
```

Gate-level modelling
--------------------

In gate-level modelling, signal/wire values can be `0` (low), `1` (high), `x`/`X` (unknown/ignored value), or `z`/`Z` (high impedance).

Gate-level modelling for a full adder (addend bits as `a`/`b`, carry-in as `c_in`, carry-out as `c_out`, sum as `sum`):

```verilog
// full_adder_gate_level_modelling.sv
// for a full adder, `sum = a XOR b XOR c_in`, and `c_out = ((a XOR b) AND c_in) OR a AND b`

module full_adder(input a, b, c_in, output c_out, sum);
    // a logic is basically a wire - here, we're declaring our wires
    logic w1, w2, w3; // these are wires that are used for connecting gates in the full adder together
    xor x1(w1, a, b);
    xor x2(sum, w1, c_in);
    and a1(w2, a, b);
    and a2(w3, w1, c_in);
    or o1(c_out, w2, w3);
endmodule
```

This is a **design module**. It fully specifies the full adder as a self-contained unit.

While this looks like normal procedural code, with various function calls, it is more intuitive to think of this as a series of logical declarations - as if each of the `xor`/`and`/`or` lines were all continuously running at the same time.

A **test bench** is a set of definitions that instantiates the design module, and simulates the circuit under different input conditions to test for functional correctness. For our full adder example:

```verilog
// full_adder_test_bench.sv
module full_adder_test_bench;
    logic carry_in, x, y;
    logic carry_out, z;

    // "dut" stands for "device under test"
    // below, we're basically instantiating a full adder (defined in the code above) that's connected to our logics, for testing purposes
    // the `.name(other_name)` syntax is a "named port map", which lets us connect logics to devices by signal name
    // alternatively, we can just map the signals in order, like `full_adder dut(x, y, carry_in, carry_out, z)`, but this can cause issues if we change the inputs/outputs of the full adder
    full_adder dut(.c_out(carry_out), .sum(z), .c_in(carry_in), .a(x), .b(y));

    // this is a procedural block - inside, the statements are evaluated sequentially from top to bottom
    initial begin // run once at time 0
        carry_in = 0; x = 0; y = 0;
        // delays must be used to ensure statements actually run sequentially - statements in between delays all execute in parallel
        #10 x = 1; // delay 10 time units, then continue and set x to 1
        #10 y = 1; // delay 10 time units, then continue and set y to 1
        #10 carry_in = 1; // delay 10 time units, then continue and set carry_in to 1
        #10 $stop; // delay 10 time units, then stop the simulation (this will not compile if trying to generate hardware from this)
    end

    // now we want to dump the signals out into waveforms so we can see them
    initial $dumpvars(0, full_adder_test_bench); // the first parameter is the dump level (`0` means "dump all variables in the module and in the modules that instantiate it"), and the rest of the parameters are the module or variables to dump
endmodule
```

To compile, run `iverilog -g2005-sv -s full_adder_test_bench.sv -o full_adder.vvp full_adder.sv full_adder_test_bench.sv`:

* `iverilog` is the Icarus Verilog compiler.
* `-g2005-sv` specifies that the compiler should use the 2005 System Verilog standard.
* `-s full_adder_test_bench.sv` specifies the top-level/root module.
* `-o full_adder.vvp` specifies the output for the compiled Verilog.
* `full_adder.sv full_adder_test_bench.sv` specifies the modules to include in the compilation.

To simulate, run `vvp -n full_adder.vvp -lx2`:

* `vvp` is the Icarus Verilog simulation tool.
* `-n` specifies that `$stop` and Control-C should complete the simulation.
* `full_adder.vvp` is the compiled Verilog file for the full adder.
* `-lx2` specifies that the simulation should be written in LXT2 format, which is slower to process but more compact allows viewing waveforms while the simulation is running.

To view the waveforms: `gtkwave dump.lx2`:

* `gtkwave` is the GTK waveform visualizer tool.
* `dump.lx2` is the simulation result generated by `vvp`.

# 5/1/17

Live demonstration of the above Verilog workflow, including an overview of GtkWave's features and a shell script that builds and simulates the module.

**Heirarchical design** is the idea of using lower-level modules in higher-level modules. For example, a carry-lookahead adder module might instantiate a few ripple-carry adders, which in turn might instantiate a bunch of full-adders:

```verilog
// adder_4_bit.sv
module adder_4_bit(output c_out, output [3:0] sum, input c_in, input [3:0] a, b);
    logic [3:1] carry;
    full_adder fa0(.c_out(carry[1]), .sum(sum[0]), .c_in(c_in), .a(a[0]), .b(b[0]));
    full_adder fa0(.c_out(carry[2]), .sum(sum[1]), .c_in(carry[1]), .a(a[1]), .b(b[1]));
    full_adder fa0(.c_out(carry[3]), .sum(sum[2]), .c_in(carry[2]), .a(a[2]), .b(b[2]));
    full_adder fa0(.c_out(c_out), .sum(sum[3]), .c_in(carry[3]), .a(a[3]), .b(b[3]));
endmodule
```

Note that there's a lot of similar statements for the full adder definitions. In these cases, we can use generate statements to remove duplicated code. It looks somewhat like a loop, but it's more of a macro that gets expanded into multiple statements at compile time:

```verilog
// adder_4_bit_generate.sv
// adder_4_bit.sv
module adder_4_bit(output c_out, output [3:0] sum, input c_in, input [3:0] a, b);
    logic [4:0] carry;
    
    generate
        genvar i;
        for(i=0; i<4; i=i+1) begin: adder
            full_adder fa(.c_out(carry[i+1]), .sum(sum[i]), .c_in(carry[i]) ,.a(a[i]), .b(b[i]));
        end
    endgenerate

    // since it would be really inconvenient to specify our c_in and c_out in the generate statement, we just used extra indices in the carry wire, and then assign the inputs/outputs accordingly
    assign carry[0] = c_in; // this is a continuous assignment statement - it's sort of like a one-way wire for the c_in signal in this case, but it can also do things like combinational logic with different gates and stuff
    assign c_out = carry[4]; // since the assignment is unidirectional, the inputs are on the right side of the equal sign, and the outputs are on the left side
endmodule
```

Dataflow modelling
------------------

Dataflow modelling is the next level of abstraction above gate-level modelling. Dataflow modelling deals only with combinational circuits, by representing them with continuous assignment statements.

Basically, we represent what logical operations the circuit needs to do, and the compiler will figure out what kind of gate layout we need. For example, for a full adder it might automatically decide to reuse the `xor(a, b)` gate.

For example, we might model a full adder using dataflow modelling as follows:

```verilog
// full_adder_dataflow.sv
module full_adder(output c_out, sum, input c_in, a, b);
    // the value of `sum` is continuously updated based on the values of `a`, `b`, and `c_in` - whenever any of those change, `sum` reflects the new value
    // this updating is not true of all continuous assignment statements, however
    assign sum = a ^ b ^ c_in;
    assign c_out = ((a ^ b) & c_in) | (a & b);

    // actually, Verilog has a `+` operator, so it's really as simple as `assign {c_out, sum} = a + b + c_in`
    // `assign` will truncate the result of evaluating the right hand side, if the right hand side has more bits than the left
    // `assign` will zero-extend the result of evaluating the right hand side, if the right hand side has fewer bits than the left
endmodule
```

Some of the available operators are `!` (logical NOT), `&&` (logical AND), `||` (logical OR), `+` (two's complement addition), `-` (two's complement subtraction), `*` (;wip), `/` (;wip), `%` (;wip), `**` (;wip), `<`, `>`, `<=`, `>=`, `==`, `!=`, `~` (NOT), `&` (AND), `|` (OR), `^` (XOR), `^~` (XNOR), `<<` (bit shift left), `>>` (bit shift right), `<<<` (;wip), `>>>` (signed shift right - extends sign bit), `{a_1, ..., a_n}` (concatenate `a_1` through to `a_n`), `{n{a}}` (replicate `a` by `n` times - repeatedly concatenate `a`), `c?a:b` (MUX - select `a` if `c` is high, `b` otherwise). They generally have precedence similar to their equivalents in C and Python.

For example, the nibbles of a byte can be swapped with `assign {b[3:0], b[7:4]} = a[7:0]`, and an 8-bit signed integer can be sign-extended to 16 bits with `assign b[15:0] = {{8{a[7]}}, a[7:0]}`.

With all these useful operators, it's pretty straightforward to make a 4-bit adder:

```verilog
// full_adder_dataflow.sv
module full_adder(output c_out, output [3:0] sum, input c_in, input [3:0] a, b);
    assign {c_out, sum} = a + b + c_in`
endmodule
```

Behaviour modelling
-------------------

Behaviour modelling is the next level of abstraction above dataflow-level modelling. It uses procedural blocks that are `initial`.

An `initial` block runs the statements inside of it once starting at time 0. An `always` block runs the statements inside of it whenever certain things change.

```verilog
initial // run once at time 0
```

Here's a full adder implemented with behaviour modelling:

```verilog
module full_adder(input c_in, a, b, output logic c_out, sum);
    // the `@ (c_in, a, b)` specifies the "sensitivity list", which means the procedural block should be reevaluated whenever any of the logics in the list change
    // in contrast, the `initial` statement doesn't have a sensitivity list because it simply runs once at the beginning
    // the left hand sides of each assignment must be a `logic` or `reg` - that's why the outputs of this module are declared as `logic`
    // we could also have written `always @ *` to make it re-evaluate the block whenever any of the signals on the right hand sides of any assignment statement changes
    always @ (c_in, a, b) begin
        sum = a ^ b ^ c_in;
        c_out = ((a ^ b) & c_in) | (a & b);
    end
```