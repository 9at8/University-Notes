<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CO487 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso.light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body onload="highlight()">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-68271407-1', 'auto');
    ga('send', 'pageview');

  </script>
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/resume.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="http://www.linkedin.com/pub/anthony-zhang/8b/aa5/7aa" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="https://twitter.com/anthony926535" class="contact">twitter</a></li>
    <span class="divider"></span>
    <li><a href="/anthony-zhang.asc" class="info">GPG key</a></li>
  </ul>
<p style="display:none"><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil#1 \right\rceil}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l'H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}^P)}
\]</span></p>
<h1 id="co487">CO487</h1>
<p>Applied cryptography.</p>
<pre><code>Alfred Menezes
Section 001
Email: ajmeneze@uwaterloo.ca
Office hours: Mondays 3:00pm-5:00pm, Fridays 1:00pm-3:00pm in MC 5026
Mondays/Wednesdays/Fridays 11:30pm-12:20pm</code></pre>
<h1 id="section">4/3/16</h1>
<p>All course resources are on LEARN. Course has 5 assignments (summing up to 20% of final grade), midterm (worth 30%), and a final exam (worth 50%). Midterm is March 8, 2017 at 7-9pm.</p>
<p>Cryptography is a tool we can use to secure communicatoins when there are malicious adversaries. Some of the fundaental goals of cyptography are:</p>
<ul>
<li>Confidentiality - data is secret to all people except authoeized parties.</li>
<li>Data Integrity - data is unaltered.</li>
<li>Origin authentication - data can be confirmed to be from a particular source.</li>
<li>Non-repudiation - once a statement is published, it is not possible to deny/revoke it later.</li>
</ul>
<p>Different applications might require different subsets of these goals.</p>
<p>In this course, we use Bob and Alice as placeholders to represent two parties trying to communicate securely. We use Eve or Mallory as a placeholder to represent one or more adversaries trying to attack the communications (by injecting data, eavesdropping, or other approaches, depending on the threat model)</p>
<p>Some famous early practical uses of cryptography was the enigma machine, which used multiple spinning rotors to encrypt/decrypt messages. In that cryptosystem, the German military leadership and the German U-boats had the role of Bob and Alice, trying to communicate confidentially, and Alan Turing and his team had the role of Eve, trying to break the confidentiality guarantees and read those communications.</p>
<p>However, cryptosystems like Enigma and its successor, Lorenz, are a far cry from modern cryptosystems, which have a much more mathematically sound foundation. Modern cryptography is what makes online banking, online shopping, and cellular networks possible.</p>
<p>For example, SSL, the protocol that makes online security possible, ensures origin authentication and confidentiality between a user and a website. SSL uses symmetric-key encryption to implement confidentiality, and a MAC scheme (HMAC) to implement origin authentication. Of course, to make this possible they both need to have the same secret key for the symmetric-key cryptography, and for the MAC. To confidentially and authentically share this secret key, we use public-key encryption. Of course, to make this possible we need a way to obtain authentic copies of the public keys of both parties - this is implemented using digital signatures, where trusted third parties known as certificate authorities keep track of public keys that are considered authentic (generally by vetting the site owner in the real world), and digitally sign them to confirm that they're authentic. The certificate authorities' public keys are pre-installed in the browser, which acts as a root of trust - if you trust that public key is authentic, and that the certificate authorities are correctly keeping track of authentic .</p>
<p>SSL is one of the most successful cryptosystems ever deployed, used for tons of sites on the internet. However, there are a number of possible weaknesses that might result in the guarantees being broken:</p>
<ul>
<li>The crpyotgraphy itself might be weak (e.g., previously, SSL supportied using RC4 for the symmetric-key encryption, which is nowadays easy to break).</li>
<li>Quantum computers can attack public-key encryption systems like RSA.</li>
<li>Random number generators used in the protocol might have weaknesses (e.g., Netscape's flawed RNG, NSA's backdoored EC-DRBG CSPRNG).</li>
<li>Certificate authorities (e.g., social engineering resulting in Verisign digitally signing non-authentic certificates).</li>
<li>Bugs in crpytographic code (e.g., Heartbleed)</li>
<li>Misuse of cryptography, like encrypting the wrong thing.</li>
<li>Phishing/social engineering attacks on users themselves.</li>
<li>The server itself leaking data - SSL only protects data in transit, not when it's on the server.</li>
</ul>
<p>This demonstrates some useful concepts:</p>
<ul>
<li>Symmetric-key encryption is used to ensure confidentiality.</li>
<li>MAC schemes are used to ensure authentication.</li>
<li>Public-key encryption is used to ensure confidentiality, integrity, authentication, and non-repudiation.</li>
<li>Digital signatures is used to ensure integrity, authentication, and non-repudiation.</li>
</ul>
<p>Cryptography is only one part of a large information security ecosystem, including other things like secure operating systems, auditing mechanisms, trusted computing, and risk analysis. In this context, cryptography provides a lot of useful and essential tools, but it's not all there is to security. Attackers will generally target the weakest part of the system, and if that link fails, it is possible that the entire system will.</p>
<p>This course focuses on breadth over depth. For depth, take CO 485 and try out the readings for this course as well.</p>
<h1 id="section-1">6/1/17</h1>
<p>SSL in more detail:</p>
<ol style="list-style-type: decimal">
<li>Client makes request to the website (not the full URL, just the host).</li>
<li>Server responds with the website's certificate, which contains the website identification info (like host and etc.).</li>
</ol>
<h2 id="symmetric-key-encryption">Symmetric-key encryption</h2>
<p>A <strong>symmetric key encryption scheme</strong> (SKES) is a definition containing:</p>
<ul>
<li>A plaintext space <span class="math inline">\(M\)</span>.</li>
<li>A ciphertext space <span class="math inline">\(C\)</span>.</li>
<li>A key space <span class="math inline">\(K\)</span>.</li>
<li>A family of encryption functions <span class="math inline">\(E_k: M \to C, \forall k \in K\)</span>.</li>
<li>A family of decryption functions <span class="math inline">\(D_k: C \to M, \forall k \in K\)</span>.</li>
</ul>
<p>To use one of these to implement message confidentiality, Alice and Bob agree on a particular <span class="math inline">\(k \in K\)</span> over a secure channel (so that nobody else knows about the value of <span class="math inline">\(k\)</span>). Then, Alice can compute <span class="math inline">\(c = E_k(m)\)</span>, where <span class="math inline">\(m\)</span> is the message, and then sends <span class="math inline">\(c\)</span> to Bob over an unsecure channel. Bob can read the message by then computing <span class="math inline">\(m = D_k(c)\)</span>, while anyone without <span class="math inline">\(k\)</span> would have to figure out the correct <span class="math inline">\(D_k\)</span> function to use. An SKES can be designed such that finding the correct <span class="math inline">\(D_k\)</span> would be very difficult.</p>
<p>A substitution cipher is an SKES, under this definition: <span class="math inline">\(M\)</span> is the set of all English messages, <span class="math inline">\(C\)</span> is the set of all encrypted messages, <span class="math inline">\(K\)</span> is the set of all permutations of the English alphabet, <span class="math inline">\(E_k\)</span> maps letters onto <span class="math inline">\(k\)</span> by index, and <span class="math inline">\(D_k\)</span> does the inverse mapping.</p>
<p>A <strong>security model</strong> defines what the adversay is capable of, like what they can do to the communicating parties. For example, there are passive attacks like <strong>ciphertext attacks</strong> (attacker can obtain ciphertext, like if they're listening on the same network), <strong>known-plaintext attacks</strong> (attacker knows some of the plaintext as well the resulting ciphertext, like knowing that someone always signs off their message with their name). There are also active attacks, like <strong>chosen-plaintext attacks</strong> (attacker can choose some part of the plaintext), <strong>clandestine attacks</strong> (attacker is willing to use bribery/blackmail/etc.), and <strong>side-channel attacks</strong> (power analysis, RF emissions analysis, timing attacks).</p>
<p>The security model also includes the attacker's computational abilities. For example, information-theoretic security models assume the attacker has infinite computational resources, complexity-theoretic security models assume the attacker has a turing machine capable of computing any polynomial-time algorithm efficiently, and computational-theoretic security models assume the attacker simply has a lot of computers available.</p>
<p>The attacker's goals, in decreasing order of priority: recovering the secret key, recovering plaintext from ciphertext (without the key), or learn some characteristics of the plaintext given ciphertext (besides message length).</p>
<p>An SKES is <strong>secure</strong> if and only if it is resistant to a chosen-plaintext attack by a computationally bounded adversary (computational-theoretic security). A secure SKES is necessary but not sufficient to guarantee confidentiality.</p>
<p>Additionally, we also assume that the adversaries know everything about the cryptosystem except the plaintext and the key, including the all the algorithms and communicatoin mechanisms.</p>
<p>An SKES should ideally be efficient (for encryption/decryption), have small keys (but not so small that it makes brute force attacks possible), and be secure (even against the designer of the SKES).</p>
<p>A <strong>work factor</strong> measures how hard a task is, in terms of how many computations are needed to complete it: <span class="math inline">\(2^{56}\)</span> operations is easy, <span class="math inline">\(2^{64}\)</span> is feasible, <span class="math inline">\(2^{80}\)</span> operations is barely feasible, and <span class="math inline">\(2^{128}\)</span> operations is infeasible. This will change as our computers get faster. For example, the entire bitcoin network is doing <span class="math inline">\(2^{61}\)</span> hashes per second. However, we use <span class="math inline">\(2^{128}\)</span> operations as infeasible because the Landauer limit tells us doing that many operations on a classical computer would take a significant fraction of the world's power output for a year.</p>
<p>For example, a substitution cipher is not secure, because it's trivially broken by a chosen-plaintext attack. By choosing the plaintext as the alphabet, the ciphertext is just the secret key. In fact, it's not even secure against ciphertext-only messages. Although it's infeasible to exhaustively try every permutation of the alphabet for valid-looking decrypted messages, we can simply use letter frequency analysis to try likely candidates first.</p>
<p>A polyalphabetic cipher uses multiple alphabet permutations for substitution, choosing between them with a particular algorithm. For example, a Vigenere cipher has a word with non-repeated letters added to the message's letters mod 26. This is nice because as the message grows longer, the letter frequency graph is a bit flatter. We can break that by using a chosen-plaintext attack with plaintext &quot;AAAAAAAAAAAAAAAAAA&quot;, so if &quot;A&quot; corresponds to the numerical value 0, the ciphertext is just the key. Therefore, the Vigenere cipher is not secure.</p>
<p>From now on, we assume plaintext, keys, and ciphertext are all binary strings. What happens when we apply the concept of a Vignere cipher, but with a uniformly random key that's as long as the entire message?</p>
<p>A <strong>one time pad</strong> XORs a random key with the plaintext (the key is as long as the message). However, it's important to not reuse keys, because <span class="math inline">\(c_1 = m_1 \xor k_1\)</span> and <span class="math inline">\(c_2 = m_2 \xor k_2\)</span> implies that <span class="math inline">\(c_1 \xor c_2 = m_1 \xor m_2\)</span>, which leaks a lot of information about the plaintext. If the key is uniformly randomly selected, every key is equally likely, so every ciphertext is also equally likely. This is information-theoretically secure - a one-time pad provably cannot be broken by a ciphertext-only attack even by attackers with infinite computational resources. While one-time pads have these nice properties, in practice they are hard to use because the key has to be as long as the ciphertext, making sharing keys a pain.</p>
<p>A <strong>stream cipher</strong> is like a one-time pad, but instead of a truly random key, we use a pseudorandom bit generator, where the PRNG's seed is the key. This is no longer perfectly secure because it depends on the quality of the randomness of the PRNG, but it's often a practical compromise since the key can be a lot shorter. Like with a one-time pad, we also shouldn't re-use keys, since that would give us some of the values of the PRNG's output by XORing the ciphertexts, which would make it easier to learn the PRNG's state. One example of a stream cipher is RC4.</p>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2017 Anthony Zhang.
</div>
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>