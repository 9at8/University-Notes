<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CS245 | Anthony Zhang</title>
  <style type="text/css">
  body {
    font-family: "Segoe UI", Verdana, Arial, Helvetica, sans-serif;
    background: #fffefe;
    padding: 5em;
  }
  
  pre {
    margin-left: 2em;
  }
  
  code {
    border: solid 1px black;
    background: #665555;
    color: white;
    padding: 0.1em;
    border-radius: 0.3em;
    display: inline-block;
  }
  
  pre code {
    padding: 1em;
    border-radius: 0.5em;
  }
  
  h1 {
    font-size: 4em;
  }
  
  table {
    margin: 0 auto;
  }
  
  td, th {
    padding: 0.5em;
    border: 1px solid grey;
  }
  
  tr {
    padding:: 0;
  }
  
  a.button {
    display: inline-block;
    padding: 1em;
    font-family: monospace;
    color: black;
    text-decoration: none;
    border: 0.2em solid black;
    border-radius: 0.5em;
    background: white;
  }
  
  a.button:hover, a.button:focus, a.button:active {
    background: black;
    color: white;
  }
  </style>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>
<body>
<a class="button" href="..">&#8666; Return to University Notes index</a>
<h1 id="cs-245">CS 245</h1>
<p>Logic and computation.</p>
<pre><code>Instructor: Daniela Maftuleac
Email: daniela.maftuleac@uwaterloo.ca
Office Hours: Tuesday 2-3pm, Wednesday 12-1pm Math Tutorial Center
Website: https://www.student.cs.uwaterloo.ca/~cs245/</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\]</span></p>
<p>Assignments are due at 1pm at the dropboxes on MC 4th floor, due on thursdays, posted on tuesdays, returned in tutorials. Remark requests must be done within a week after the marks are posted.</p>
<h2 id="logic">Logic</h2>
<p>Logic is the science of correct reasoning. It is concerned with determining whether things are true or false.</p>
<p>In <strong>symbolic logic</strong>, we use symbols to represent truth values and manipulate logical statements using certain logical rules.</p>
<p>This course deals with propositional logic, predicate logic, and program verification.</p>
<p>Prove that <span class="math">\(3 \mid (4^n + 5)\)</span> for all <span class="math">\(n \in \mb{N}\)</span>:</p>
<blockquote>
<p>Clearly, this is true for <span class="math">\(n = 0\)</span>, since <span class="math">\(3 \mid (1 + 5)\)</span>.<br />Assume for some <span class="math">\(k \ge 0\)</span> that <span class="math">\(3 \mid (4^k + 5)\)</span>.<br />So <span class="math">\(\exists p \in \mb{Z}, 3p = 4^k + 5\)</span> and <span class="math">\(4(3p) = 4(4^k + 5)\)</span>, so <span class="math">\(12p - 15 = 3(4p - 5) = 4^{k + 1} + 5\)</span>.<br />Let <span class="math">\(q = 4p - 5\)</span>. Since <span class="math">\(q \in \mb{Z}\)</span>, <span class="math">\(\exists q \in \mb{Z}, 3q = 4^{k + 1} + 5\)</span>.<br />So <span class="math">\(3 \mid 4^{k + 1} + 5\)</span>, and by induction, <span class="math">\(3 \mid 4^n + 5\)</span> for all <span class="math">\(n \in \mb{N}\)</span>.</p>
</blockquote>
<p>The idea is that with strong induction, we can use any of the previous cases to prove the inductive hypothesis.</p>
<h1 id="section">7/5/14</h1>
<p>;wip: do assignment 1</p>
<h2 id="propositional-logic">Propositional Logic</h2>
<p>The language of propositions is propositional logic.</p>
<p>A proposition is a declarative statement that is either true or false. It may depend on the context, like how the proposition <span class="math">\(x \ge 5\)</span> depends on the contextual variable <span class="math">\(x\)</span>.</p>
<p>We always assume that for any proposition with its context (the situation the proposition applies in), either the proposition is true, or it is false, and it cannot be both. If a statement is false, then its negation is true.</p>
<p>Propositions must be declarative. They must make sense when we ask, &quot;is it true that PROPOSITION?&quot;. It must be assignable to either true or false.</p>
<p><strong>Simple/atomic propositions</strong> are the building blocks of <strong>compound propositions</strong>. For example, &quot;It is currently raining in Waterloo&quot; and &quot;It is currently 12 degrees Celsius in Waterloo&quot; are simple propositions, and &quot;It is either raining or 12 degrees in Waterloo&quot; is a compound proposition.</p>
<p>Atomic ropositions are the smallest possible statements that are still propositions. They cannot be divided into smaller propositions.</p>
<h3 id="expression-syntax">Expression Syntax</h3>
<p>The propositional language is known as <span class="math">\(\mathcal{L}_P\)</span>. This language contains <strong>atoms</strong>, which are lowercase Latin characters such as <span class="math">\(p\)</span>, <span class="math">\(q\)</span>, and <span class="math">\(r\)</span>, optionally with subscripts. These all belong to the set <span class="math">\(\operatorname{Atom}(\mathcal{L}_P)\)</span>, so <span class="math">\(p \in \operatorname{Atom}(\mathcal{L}_P)\)</span>.</p>
<p>There are also <strong>punctuation</strong> symbols, the round parentheses &quot;(&quot; and &quot;)&quot;, which change the precendence of subexpressions.</p>
<p>There are also <strong>connectives</strong>, which are <span class="math">\(\neg, \wedge, \vee, \rightarrow, \leftrightarrow\)</span>.</p>
<p>An <strong>expression</strong> is a finite sequence of symbols. The length of an expression is the number of symbols it contains. Expressions may not necessarily be valid, like <span class="math">\(( \vee \neg \vee (\)</span>.</p>
<p>The empty expression (containing no symbols) is denoted <span class="math">\(\emptyset\)</span>.</p>
<h3 id="expression-operations">Expression Operations</h3>
<p>Let <span class="math">\(U, V, W\)</span> be expressions. Then <span class="math">\(U\)</span> and <span class="math">\(V\)</span> are equal (<span class="math">\(U = V\)</span>) if and only if they contain the same sequence of symbols.</p>
<p>Then <span class="math">\(UV\)</span> is the concatenation of <span class="math">\(U\)</span> and <span class="math">\(V\)</span> - the expression containing the entire sequence in <span class="math">\(U\)</span>, followed by the entire sequence in <span class="math">\(V\)</span>.</p>
<p>If <span class="math">\(U = W_1 V W_2\)</span>, then <span class="math">\(V\)</span> is a <strong>segment</strong> of <span class="math">\(U\)</span> - it is a sequence of symbols that <span class="math">\(U\)</span> also contains. All sequences contain the empty expression.</p>
<p>If <span class="math">\(V\)</span> is a segment of <span class="math">\(U\)</span> and <span class="math">\(V \ne U\)</span>, then <span class="math">\(V\)</span> is a <strong>proper segment</strong> of <span class="math">\(U\)</span>.</p>
<p>If <span class="math">\(U = VW\)</span>, then <span class="math">\(V\)</span> is an <strong>initial segment</strong> and <span class="math">\(W\)</span> is a <strong>terminal segment</strong>.</p>
<h3 id="expression-validity">Expression Validity</h3>
<p>The binary (two-parameter) connectives are <span class="math">\(\wedge, \vee, \rightarrow, \leftrightarrow\)</span>. In the following, <span class="math">\(\odot\)</span> will represent any arbitrary one of these binary connectives. The only connective that is not binary is the unary <span class="math">\(\neg\)</span> connective.</p>
<p>The set of <strong>formulas</strong> is the set of all valid/well-formed expressions, and is denoted <span class="math">\(\operatorname{Form}(\mathcal{L}_P)\)</span>. Given <span class="math">\(A, B \in \operatorname{Form}(\mathcal{L}_P)\)</span>, we can define <span class="math">\(\operatorname{Form}(\mathcal{L}_P)\)</span> as follows:</p>
<ul>
<li><span class="math">\(\operatorname{Atom}(\mathcal{L}_P) \subseteq \operatorname{Form}(\mathcal{L}_P)\)</span> - all atoms are formulas.</li>
<li><span class="math">\(\neg A \in \operatorname{Form}(\mathcal{L}_P)\)</span> - the negation of any formula is also a formula (the set of formulas are closed under negation).</li>
<li><span class="math">\(A \odot B \in \operatorname{Form}(\mathcal{L}_P)\)</span> - binary connectives applied to two formulas are also formulas (the set of formulas is closed under all the binary connectives).</li>
</ul>
<p>Formulas are often represented using Roman capital letters.</p>
<p>Theorem 2.2.3 states the obvious consequences of the definition: all formulas of <span class="math">\(\mathcal{L}_P\)</span> are atoms, or of the form <span class="math">\(\neg A, A \wedge B, A \vee B, A \rightarrow B, A \leftrightarrow B\)</span>.</p>
<p>Let <span class="math">\(R(n)\)</span> be a property (true if the property holds for <span class="math">\(n\)</span>, false otherwise). Theorem 2.2.4 states that if <span class="math">\(\forall p \in \operatorname{Atom}(\mathcal{L}_P), R(p)\)</span> and <span class="math">\(\forall A \in \operatorname{Form}(\mathcal{L}_P), R(A) \implies R(\neg A)\)</span> and <span class="math">\(\forall A, B \in \operatorname{Form}(\mathcal{L}_P), R(A) \wedge R(B) \implies R(A \odot B)\)</span>, then <span class="math">\(\forall A \in \operatorname{Form}(\mathcal{L}_P), R(A)\)</span>.</p>
<p>In other words, if a property holds for all the forms of formulas, then it holds for all formulas.</p>
<p>The <strong>type</strong> of a formula is determined by its top-level operator. For example, <span class="math">\(\neg A\)</span> is a negation, <span class="math">\(A \wedge B\)</span> is conjunction, <span class="math">\(A \vee b\)</span> is a disjunction, <span class="math">\(A \rightarrow B\)</span> is an implication, <span class="math">\(A \leftrightarrow B\)</span> is an equivalence. According to theorem 2.3.3, all formulas must be one of these forms.</p>
<p>We want to be able to look at any expression and determine whether it is well formed. For example, <span class="math">\(\neg()\)</span> is not a well formed formula (WFF) because it is not obtainable through the rules that define an element in the set of formulas.</p>
<p>Is <span class="math">\((\neg a) \wedge (b \vee c)\)</span> well formed?</p>
<blockquote>
<p>We can first notice that this is of the form <span class="math">\(P \wedge Q\)</span>, where <span class="math">\(P = \neg a\)</span> and <span class="math">\(Q = b \vee c\)</span>. By the rules, we know that the whole thing is well formed if and only if <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are both well formed.<br />Now we check if <span class="math">\(P\)</span> is well formed. Clearly, it is of the form <span class="math">\(\neg R\)</span>, where <span class="math">\(R = a\)</span>, and <span class="math">\(a\)</span> is an atom (which is, by definition, well formed), so by the rules, <span class="math">\(\neg a\)</span> is well formed.<br />Now we check if <span class="math">\(Q\)</span> is well formed. Clearly, it is of the form <span class="math">\(S \vee T\)</span>, where <span class="math">\(S = b\)</span> and <span class="math">\(T = c\)</span>. By the rules, <span class="math">\(Q\)</span> is well formed if and only if <span class="math">\(S\)</span> and <span class="math">\(T\)</span> are. Since they are atoms, they are both well formed by definition.<br />Since <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are well formed, <span class="math">\(P \wedge Q\)</span> is well formed and so is <span class="math">\((\neg a) \wedge (b \vee c)\)</span>.</p>
</blockquote>
<h1 id="section-1">12/5/14</h1>
<h2 id="parse-trees">Parse Trees</h2>
<p>The other way of testing for well-formedness is by constructing a parse tree out of the symbols in the formula. The top-level operator or atom is the root node of the tree, and the operands are its children. This is repeated until all the symbols have been added to the tree. Parentheses simply change the arrangement of the nodes and are not included in the parse tree.</p>
<p>For example, the expression <span class="math">\((((\neg p) \wedge q) \rightarrow (p \wedge (q \vee (\neg r))))\)</span> has the following parse tree:</p>
<pre><code>      \implies
       /   \
      /     \
  \wedge   \wedge
   /  \     /  \
\neg   q   p  \vee
  |           /  \
  p          q  \neg
                  |
                  r</code></pre>
<p>Every parse tree is unique. The rules for a valid formula can be applied to a parse tree to test for well-formedness:</p>
<ul>
<li>Tree nodes must be either atoms or connectives.</li>
<li>If a node is an atom, it cannot have any children - if a node has children, it must be a connective.</li>
<li>If a node is the unary connective (<span class="math">\(\neg\)</span>), then it must have exactly one child.</li>
<li>If the node is a binary connective, then it must have exactly two children.</li>
<li>If a tree is empty, then it is not a well formed formula.</li>
</ul>
<p>An algorithm for testing if an expression <span class="math">\(U\)</span> is a well formed formula is given below</p>
<ol style="list-style-type: decimal">
<li>If <span class="math">\(U\)</span> is empty, produce False.</li>
<li>If <span class="math">\(U \in \operatorname{Atom}(\mathcal{L}_P)\)</span>, then produce True.</li>
<li>If the expression does not begin with a <span class="math">\((\)</span> symbol, produce False.</li>
<li>If the second symbol is <span class="math">\(\neg\)</span>, then let <span class="math">\(V\)</span> be an expression such that <span class="math">\(U = (\neg V)\)</span>. Apply this algorithm again with <span class="math">\(V\)</span> as the expression, and if it is false, produce False.</li>
<li>Otherwise (the second symbol is not <span class="math">\(\neg\)</span>), apply this algorithm again with all the symbols starting from and including the second symbol, except doing nothing in step 7. If it results in False, return False. Otherwise, let <span class="math">\(V\)</span> be the well formed formula from the second symbol to wherever the algorithm run ended. If the next symbol after this is not a binary connective, produce False. Do the formula thing again to get a well formed formula <span class="math">\(W\)</span>, or produce False.</li>
<li>If the symbol after the place <span class="math">\(W\)</span> ended is not a <span class="math">\()\)</span> symbol, produce False.</li>
<li>If the expression does not end after the <span class="math">\()\)</span> symbol, produce False.</li>
<li>Produce True.</li>
</ol>
<p>This algorithm gets applied a finite number of times, proportional to the depth of the tree.</p>
<p>The <strong>height</strong> of a parse tree is the length of the longest path from the root to a leaf.</p>
<h3 id="precedence">Precedence</h3>
<p>We now introduce a system of precedence. The logical connectives listed by priority, from highest to lowest, are <span class="math">\(\neg\)</span>, <span class="math">\(\wedge\)</span>, <span class="math">\(\vee\)</span>, <span class="math">\(\rightarrow\)</span>, and <span class="math">\(\leftrightarrow\)</span>.</p>
<p>Precedence is the idea that some connectives get higher priority than others. For example, <span class="math">\(p \vee q \wedge r\)</span> could potentially mean either <span class="math">\(((p \vee q) \wedge r)\)</span>, or <span class="math">\((p \vee (q \wedge r))\)</span>. But since <span class="math">\(\wedge\)</span> has a higher precedence than <span class="math">\(\vee\)</span>, we define <span class="math">\(p \vee q \wedge r\)</span> to mean <span class="math">\((p \vee (q \wedge r))\)</span>.</p>
<p>When there are multiple ambiguities, we start with the ones with highest precedence. For example, <span class="math">\(\neg p \wedge q \vee r\)</span> is resolved to <span class="math">\((neg p) \wedge q \vee r\)</span>, then <span class="math">\((((neg p) \wedge q) \vee r)\)</span>.</p>
<p><strong>Course of values induction</strong> is a type of strong induction where the inductive hypothesis used to prove the inductive conclusion is the conjunction of all the previous cases.</p>
<p>In other words, we do course of values induction by proving a property holds for <span class="math">\(M(1)\)</span>, and then by proving that <span class="math">\(M(1) \wedge \ldots \wedge M(k) \implies M(k + 1)\)</span> for any <span class="math">\(k \ge 1\)</span>. By the principal of strong induction, <span class="math">\(M(n)\)</span> therefore holds for all <span class="math">\(n \ge 1\)</span>.</p>
<p>Sometimes we want to use induction on the height of the parse tree. This is often useful for proving things about propositional formulas, due to the recursive nature of formulas.</p>
<p>If a formula <span class="math">\(C\)</span> contains the segment <span class="math">\((\neg A)\)</span>, where <span class="math">\(A\)</span> is another formula, then <span class="math">\(A\)</span> is the <strong>scope</strong> of the <span class="math">\(\neg\)</span> within <span class="math">\(C\)</span>. The scope is the area where the <span class="math">\(\neg\)</span> applies.</p>
<p>For binary connectives, if <span class="math">\(C\)</span> contains <span class="math">\((A \odot B)\)</span> where <span class="math">\(\odot\)</span> is a binary connective, then <span class="math">\(A\)</span> and <span class="math">\(B\)</span> are the left and right scopes, respectively, of the binary connective within <span class="math">\(C\)</span>.</p>
<p>A scope is unique to the operator. Two operators cannot have the exact same scope, though the scopes themselves can be equal.</p>
<hr>
<p>Copyright 2013 Anthony Zhang</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>