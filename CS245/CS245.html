<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CS245 | Anthony Zhang</title>
  <style type="text/css">
  body {
    font-family: "Segoe UI", Verdana, Arial, Helvetica, sans-serif;
    background: #fffefe;
    padding: 5em;
  }
  
  pre {
    margin-left: 2em;
  }
  
  code {
    border: solid 1px black;
    background: #665555;
    color: white;
    padding: 0.1em;
    border-radius: 0.3em;
    display: inline-block;
  }
  
  pre code {
    padding: 1em;
    border-radius: 0.5em;
  }
  
  h1 {
    font-size: 4em;
  }
  
  table {
    margin: 0 auto;
  }
  
  td, th {
    padding: 0.5em;
    border: 1px solid grey;
  }
  
  tr {
    padding:: 0;
  }
  
  a.button {
    display: inline-block;
    padding: 1em;
    font-family: monospace;
    color: black;
    text-decoration: none;
    border: 0.2em solid black;
    border-radius: 0.5em;
    background: white;
  }
  
  a.button:hover, a.button:focus, a.button:active {
    background: black;
    color: white;
  }
  </style>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>
<body>
<a class="button" href="..">&#8666; Return to University Notes index</a>
<h1 id="cs-245">CS 245</h1>
<p>Logic and computation.</p>
<pre><code>Instructor: Daniela Maftuleac
Email: daniela.maftuleac@uwaterloo.ca
Office Hours: Tuesday 2-3pm, Wednesday 12-1pm Math Tutorial Center
Website: https://www.student.cs.uwaterloo.ca/~cs245/</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\]</span></p>
<p>Assignments are due at 1pm at the dropboxes on MC 4th floor, due on thursdays, posted on tuesdays, returned in tutorials. Remark requests must be done within a week after the marks are posted.</p>
<h2 id="logic">Logic</h2>
<p>Logic is the science of correct reasoning. It is concerned with determining whether things are true or false.</p>
<p>In <strong>symbolic logic</strong>, we use symbols to represent truth values and manipulate logical statements using certain logical rules.</p>
<p>This course deals with propositional logic, predicate logic, and program verification.</p>
<p>Prove that <span class="math">\(3 \mid (4^n + 5)\)</span> for all <span class="math">\(n \in \mb{N}\)</span>:</p>
<blockquote>
<p>Clearly, this is true for <span class="math">\(n = 0\)</span>, since <span class="math">\(3 \mid (1 + 5)\)</span>.<br />Assume for some <span class="math">\(k \ge 0\)</span> that <span class="math">\(3 \mid (4^k + 5)\)</span>.<br />So <span class="math">\(\exists p \in \mb{Z}, 3p = 4^k + 5\)</span> and <span class="math">\(4(3p) = 4(4^k + 5)\)</span>, so <span class="math">\(12p - 15 = 3(4p - 5) = 4^{k + 1} + 5\)</span>.<br />Let <span class="math">\(q = 4p - 5\)</span>. Since <span class="math">\(q \in \mb{Z}\)</span>, <span class="math">\(\exists q \in \mb{Z}, 3q = 4^{k + 1} + 5\)</span>.<br />So <span class="math">\(3 \mid 4^{k + 1} + 5\)</span>, and by induction, <span class="math">\(3 \mid 4^n + 5\)</span> for all <span class="math">\(n \in \mb{N}\)</span>.</p>
</blockquote>
<p>The idea is that with strong induction, we can use any of the previous cases to prove the inductive hypothesis.</p>
<h1 id="section">7/5/14</h1>
<p>;wip: do assignment 1</p>
<h2 id="propositional-logic">Propositional Logic</h2>
<p>The language of propositions is propositional logic.</p>
<p>A proposition is a declarative statement that is either true or false. It may depend on the context, like how the proposition <span class="math">\(x \ge 5\)</span> depends on the contextual variable <span class="math">\(x\)</span>.</p>
<p>We always assume that for any proposition with its context (the situation the proposition applies in), either the proposition is true, or it is false, and it cannot be both. If a statement is false, then its negation is true.</p>
<p>Propositions must be declarative. They must make sense when we ask, &quot;is it true that PROPOSITION?&quot;. It must be assignable to either true or false.</p>
<p><strong>Simple/atomic propositions</strong> are the building blocks of <strong>compound propositions</strong>. For example, &quot;It is currently raining in Waterloo&quot; and &quot;It is currently 12 degrees Celsius in Waterloo&quot; are simple propositions, and &quot;It is either raining or 12 degrees in Waterloo&quot; is a compound proposition.</p>
<p>Atomic ropositions are the smallest possible statements that are still propositions. They cannot be divided into smaller propositions.</p>
<h3 id="expression-syntax">Expression Syntax</h3>
<p>The propositional language is known as <span class="math">\(\mathcal{L}_P\)</span>. This language contains <strong>atoms</strong>, which are lowercase Latin characters such as <span class="math">\(p\)</span>, <span class="math">\(q\)</span>, and <span class="math">\(r\)</span>, optionally with subscripts. These all belong to the set <span class="math">\(\operatorname{Atom}(\mathcal{L}_P)\)</span>, so <span class="math">\(p \in \operatorname{Atom}(\mathcal{L}_P)\)</span>.</p>
<p>There are also <strong>punctuation</strong> symbols, the round parentheses &quot;(&quot; and &quot;)&quot;, which change the precendence of subexpressions.</p>
<p>There are also <strong>connectives</strong>, which are <span class="math">\(\neg, \wedge, \vee, \rightarrow, \leftrightarrow\)</span>.</p>
<p>An <strong>expression</strong> is a finite sequence of symbols. The length of an expression is the number of symbols it contains. Expressions may not necessarily be valid, like <span class="math">\(( \vee \neg \vee (\)</span>.</p>
<p>The empty expression (containing no symbols) is denoted <span class="math">\(\emptyset\)</span>.</p>
<h3 id="expression-operations">Expression Operations</h3>
<p>Let <span class="math">\(U, V, W\)</span> be expressions. Then <span class="math">\(U\)</span> and <span class="math">\(V\)</span> are equal (<span class="math">\(U = V\)</span>) if and only if they contain the same sequence of symbols.</p>
<p>Then <span class="math">\(UV\)</span> is the concatenation of <span class="math">\(U\)</span> and <span class="math">\(V\)</span> - the expression containing the entire sequence in <span class="math">\(U\)</span>, followed by the entire sequence in <span class="math">\(V\)</span>.</p>
<p>If <span class="math">\(U = W_1 V W_2\)</span>, then <span class="math">\(V\)</span> is a <strong>segment</strong> of <span class="math">\(U\)</span> - it is a sequence of symbols that <span class="math">\(U\)</span> also contains. All sequences contain the empty expression.</p>
<p>If <span class="math">\(V\)</span> is a segment of <span class="math">\(U\)</span> and <span class="math">\(V \ne U\)</span>, then <span class="math">\(V\)</span> is a <strong>proper segment</strong> of <span class="math">\(U\)</span>.</p>
<p>If <span class="math">\(U = VW\)</span>, then <span class="math">\(V\)</span> is an <strong>initial segment</strong> and <span class="math">\(W\)</span> is a <strong>terminal segment</strong>.</p>
<h3 id="expression-validity">Expression Validity</h3>
<p>The binary (two-parameter) connectives are <span class="math">\(\wedge, \vee, \rightarrow, \leftrightarrow\)</span>. In the following, <span class="math">\(\odot\)</span> will represent any arbitrary one of these binary connectives. The only connective that is not binary is the unary <span class="math">\(\neg\)</span> connective.</p>
<p>The set of <strong>formulas</strong> is the set of all valid/well-formed expressions, and is denoted <span class="math">\(\operatorname{Form}(\mathcal{L}_P)\)</span>. Given <span class="math">\(A, B \in \operatorname{Form}(\mathcal{L}_P)\)</span>, we can define <span class="math">\(\operatorname{Form}(\mathcal{L}_P)\)</span> as follows:</p>
<ul>
<li><span class="math">\(\operatorname{Atom}(\mathcal{L}_P) \subseteq \operatorname{Form}(\mathcal{L}_P)\)</span> - all atoms are formulas.</li>
<li><span class="math">\(\neg A \in \operatorname{Form}(\mathcal{L}_P)\)</span> - the negation of any formula is also a formula (the set of formulas are closed under negation).</li>
<li><span class="math">\(A \odot B \in \operatorname{Form}(\mathcal{L}_P)\)</span> - binary connectives applied to two formulas are also formulas (the set of formulas is closed under all the binary connectives).</li>
</ul>
<p>Formulas are often represented using Roman capital letters.</p>
<p>Theorem 2.2.3 states the obvious consequences of the definition: all formulas of <span class="math">\(\mathcal{L}_P\)</span> are atoms, or of the form <span class="math">\(\neg A, A \wedge B, A \vee B, A \rightarrow B, A \leftrightarrow B\)</span>.</p>
<p>Let <span class="math">\(R(n)\)</span> be a property (true if the property holds for <span class="math">\(n\)</span>, false otherwise). Theorem 2.2.4 states that if <span class="math">\(\forall p \in \operatorname{Atom}(\mathcal{L}_P), R(p)\)</span> and <span class="math">\(\forall A \in \operatorname{Form}(\mathcal{L}_P), R(A) \implies R(\neg A)\)</span> and <span class="math">\(\forall A, B \in \operatorname{Form}(\mathcal{L}_P), R(A) \wedge R(B) \implies R(A \odot B)\)</span>, then <span class="math">\(\forall A \in \operatorname{Form}(\mathcal{L}_P), R(A)\)</span>.</p>
<p>In other words, if a property holds for all the forms of formulas, then it holds for all formulas.</p>
<p>The <strong>type</strong> of a formula is determined by its top-level operator. For example, <span class="math">\(\neg A\)</span> is a negation, <span class="math">\(A \wedge B\)</span> is conjunction, <span class="math">\(A \vee b\)</span> is a disjunction, <span class="math">\(A \rightarrow B\)</span> is an implication, <span class="math">\(A \leftrightarrow B\)</span> is an equivalence.</p>
<p>We want to be able to look at any expression and determine whether it is well formed. For example, <span class="math">\(\neg()\)</span> is not a well formed formula (WFF) because it is not obtainable through the rules that define an element in the set of formulas.</p>
<p>Is <span class="math">\((\neg a) \wedge (b \vee c)\)</span> well formed?</p>
<blockquote>
<p>We can first notice that this is of the form <span class="math">\(P \wedge Q\)</span>, where <span class="math">\(P = \neg a\)</span> and <span class="math">\(Q = b \vee c\)</span>. By the rules, we know that the whole thing is well formed if and only if <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are both well formed.<br />Now we check if <span class="math">\(P\)</span> is well formed. Clearly, it is of the form <span class="math">\(\neg R\)</span>, where <span class="math">\(R = a\)</span>, and <span class="math">\(a\)</span> is an atom (which is, by definition, well formed), so by the rules, <span class="math">\(\neg a\)</span> is well formed.<br />Now we check if <span class="math">\(Q\)</span> is well formed. Clearly, it is of the form <span class="math">\(S \vee T\)</span>, where <span class="math">\(S = b\)</span> and <span class="math">\(T = c\)</span>. By the rules, <span class="math">\(Q\)</span> is well formed if and only if <span class="math">\(S\)</span> and <span class="math">\(T\)</span> are. Since they are atoms, they are both well formed by definition.<br />Since <span class="math">\(P\)</span> and <span class="math">\(Q\)</span> are well formed, <span class="math">\(P \wedge Q\)</span> is well formed and so is <span class="math">\((\neg a) \wedge (b \vee c)\)</span>.</p>
</blockquote>
<hr>
<p>Copyright 2013 Anthony Zhang</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>