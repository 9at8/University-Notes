<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>ECE124 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso.light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>
function highlight() { // highlight all code blocks using HighlightJS
  var code_blocks = document.getElementsByTagName("code");
  for (var i = 0; i < code_blocks.length; i++)
    hljs.highlightBlock(code_blocks[i]);
}
</script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body onload="highlight()">
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/Résumé.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="http://www.linkedin.com/pub/anthony-zhang/8b/aa5/7aa" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.mesecons.net/">mesecons</a></li>
    <span class="divider"></span>
    <li><a href="http://www.autohotkey.net/~Uberi/">autohotkey.net</a></li>
  </ul>
<h1 id="ece124">ECE124</h1>
<p>Digital circuits and systems.</p>
<pre><code>Instructor: Andrew Kennings
Website: http://sifaka.uwaterloo.ca/~akenning/courses/ece124/</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}_P)}
\]</span></p>
<h1 id="section">5/1/15</h1>
<p>The assignments and other course resources can be found on the course website. They will not be posted to LEARN.</p>
<h2 id="boolean-algebra">Boolean Algebra</h2>
<p>See the CS245 notes for description of Boolean algebra.</p>
<p>Binary functions are defined using a truth table, or a Boolean logic formula. An example of a binary function is <span class="math">\(f = f(x, y)\)</span>. Problem with truth tables is that they're big, and hard to manipulate.</p>
<p>Boolean AND is represented with <span class="math">\(x \cdot y\)</span>, <span class="math">\(xy\)</span>, or <span class="math">\(x \wedge y\)</span>. The schematic symbol for this operation is a rectangle with one side completely rounded into a semicircle with the output wire, and the other flat and with input wires.</p>
<p>Boolean OR is represented with <span class="math">\(x + y\)</span>. The schematic symbol for this operation is a rectangle with one side completely rounded into a semicircle with the output wire, with the other side curved inward and has input wires leading into it.</p>
<p>Boolean NOT is represented with <span class="math">\(\overline x\)</span>, <span class="math">\(!x\)</span>, <span class="math">\(x&#39;\)</span>, or <span class="math">\(\neg x\)</span>. The schematic symbol for this operation is a triangle with a circle on the pointed end, which has the output wire, and the input wire is on the other end.</p>
<p>There is also an order of operations for these operations. From highest precedence to lowest, the operators are NOT, AND, and OR.</p>
<h1 id="section-1">7/1/15</h1>
<h2 id="mintermsmaxterms">Minterms/Maxterms</h2>
<p>A <strong>minterm</strong> is a particular Boolean expression for a particular input to an <span class="math">\(n\)</span>-input function. The minterm is special because it is easy to construct algorithmically from a truth table.</p>
<p>The minterm <span class="math">\(m_i\)</span> of a truth table's row <span class="math">\(i\)</span> is the an OR expression with an operand for each function input where each operand is <span class="math">\(x_i\)</span> if <span class="math">\(x_i = 1\)</span> for that row and <span class="math">\(\neg x_i\)</span> if <span class="math">\(x_i = 0\)</span>.</p>
<p>Given a truth table, we can construct an expression that is equivalent to the function it represents as follows:</p>
<ol style="list-style-type: decimal">
<li>Create an empty expression <span class="math">\(m\)</span>.</li>
<li>For each row <span class="math">\(x_0, \ldots, x_n, f\)</span> in the truth table:</li>
<li>Create an empty expression <span class="math">\(m_i\)</span>.</li>
<li>For all <span class="math">\(1 \le i \le n\)</span>:
<ol style="list-style-type: decimal">
<li>If <span class="math">\(x_i = 0\)</span>, let <span class="math">\(m_i\)</span> become <span class="math">\(m_i \cdot \neg x_i\)</span>.</li>
<li>If <span class="math">\(x_i = 1\)</span>, let <span class="math">\(m_i\)</span> become <span class="math">\(m_i \cdot x_i\)</span>.</li>
</ol></li>
<li>If and only if <span class="math">\(f = 1\)</span>, let <span class="math">\(m\)</span> become <span class="math">\(m \vee m_i\)</span>. Note that <span class="math">\(m_i\)</span> is true if and only if the inputs match those in the current row of the truth table.</li>
<li>Note that <span class="math">\(m\)</span> is true if and only if <span class="math">\(f = 1\)</span>, since there is an <span class="math">\(m_i\)</span> term for all the rows in the truth table that are true, and none of them match any rows in the truth table that are not true.</li>
</ol>
<p>Here, each <span class="math">\(m_i\)</span> is a minterm. <span class="math">\(m\)</span> is the sum of minterms/canonical sum of products, defined below.</p>
<p>The <strong>canonical sum of products/sum of minterms</strong> is when we OR all the minterms (<span class="math">\(m_i\)</span>) that have <span class="math">\(f = 1\)</span> for their corresponding truth table rows, in order.</p>
<p>The <strong>maxterms</strong> of a function are the duals of the minterms - similar to the minterms, but with AND instead of OR, and <span class="math">\(\neg x\)</span> and <span class="math">\(x\)</span> where we used to have <span class="math">\(x\)</span> and <span class="math">\(\neg x\)</span>.</p>
<p>The maxterm <span class="math">\(M_i\)</span> of a truth table's row <span class="math">\(i\)</span> is the an OR expression with an operand for each function input where each operand is <span class="math">\(x_i\)</span> if <span class="math">\(x_i = 1\)</span> for that row and <span class="math">\(\neg x_i\)</span> if <span class="math">\(x_i = 0\)</span>.</p>
<p>The maxterm is true if and only if the inputs <em>do not match the inputs in the corresponding row in the truth table</em>. This is the opposite of a minterm being true if and only if the inputs do match the inputs.</p>
<p>The <strong>canonical product of sums/product of maxterms</strong> is when we AND all the maxterms that have <span class="math">\(f = 0\)</span> for their corresponding truth table rows, in order. In other words, it is an expression that ensures that the inputs do not match the first row resulting in 0, and do not match the second row resulting in 0, and so on.</p>
<p>The sum of minterms and product of maxterms are special because it is exactly equivalent to the original function. The term <strong>canonical</strong> means that they are unique - there is only one way to write it correctly.</p>
<p>Minterms determine when we need to turn the function on. Maxterms determine when we need to turn the function off.</p>
<p>A <span class="math">\(n\)</span>-level expression is an expression that has a maximum tree depth of <span class="math">\(n\)</span>. <span class="math">\(xy + z\)</span> is a 2-level expression, and when we draw the circuit, it has 2 levels of gates - the depth of the circuit tree. The level of a circuit is the length of the longest path from a circuit input to an output.</p>
<p>For example, if a 2-input function has the following truth table:</p>
<table>
<thead>
<tr class="header">
<th align="left">x</th>
<th align="left">y</th>
<th align="left">f</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>The minterms are <span class="math">\(\neg x \neg y\)</span> and <span class="math">\(x y\)</span>, and the maxterms are <span class="math">\(x \neg y\)</span> and <span class="math">\(\neg x y\)</span>. As a result, we can write <span class="math">\(f\)</span> as <span class="math">\(\neg x \neg y + x y\)</span> (sum of minterms) or <span class="math">\((x + \neg y)(\neg x + y)\)</span> (product of maxterms).</p>
<p>Our goal is to use the simplest possible circuits. We can choose whether to use the sum of minterms or product of maxterms, but we can also use Boolean algebra to further simplify any expression.</p>
<h2 id="boolean-algebra-1">Boolean Algebra</h2>
<p>Axioms of Boolean algebra:</p>
<ol style="list-style-type: decimal">
<li>Closure over operations: given <span class="math">\(x, y \in \set{0, 1}\)</span>, <span class="math">\(x \cdot y, x + y, \neg x \in \set{0, 1}\)</span>.</li>
<li>Operation identities: given <span class="math">\(x \in \set{0, 1}\)</span>, <span class="math">\(x + 0 = x\)</span> and <span class="math">\(x \cdot 1 = x\)</span>. <span class="math">\(0\)</span> is the OR identity and <span class="math">\(1\)</span> is the AND identity.</li>
<li>Commutativity: given <span class="math">\(x, y \in \set{0, 1}\)</span>, <span class="math">\(x + y = y + x\)</span> and <span class="math">\(x \cdot y = y \cdot x\)</span>.</li>
<li>Distributivity: <span class="math">\(x + y \cdot z = (x + y) \cdot (x + z)\)</span> (distributivity over OR) and <span class="math">\(x \cdot (y + z) = x \cdot y + x \cdot z\)</span>.</li>
<li>Negation existance: given <span class="math">\(x \in \set{0, 1}\)</span>, there must exist an element <span class="math">\(\neg x\)</span> such that <span class="math">\(x + \neg x = 1\)</span> and <span class="math">\(x \cdot \neg x = 0\)</span>.</li>
<li>Unique elements: there must exist <span class="math">\(x, y \in \set{0, 1}\)</span> such that <span class="math">\(x \ne y\)</span>.</li>
</ol>
<p>We can now prove theorems using truth tables, or using axioms:</p>
<p>Additional theorems:</p>
<ol style="list-style-type: decimal">
<li><span class="math">\(x + x = x\)</span> and <span class="math">\(x \cdot x = x\)</span></li>
<li><span class="math">\(x + 1 = 1\)</span> and <span class="math">\(x \cdot 0 = 0\)</span></li>
<li><span class="math">\(\neg \neg x = x\)</span> (double negation)</li>
<li><span class="math">\(x + (y + z) = (x + y) + z\)</span> and <span class="math">\(x \cdot (y \cdot z) = (x \cdot y) \cdot z\)</span> (associativity)</li>
<li><span class="math">\(\neg (x + y) = \neg x \cdot \neg y\)</span> and <span class="math">\(\neg (x \cdot y) = \neg x + \neg y\)</span> (De Morgan's Law)</li>
<li><span class="math">\(x + x \cdot y = x\)</span> and <span class="math">\(x \cdot (x + y) = x\)</span> (adsorption)</li>
</ol>
<h1 id="section-2">9/1/15</h1>
<p>Simplify <span class="math">\(\overline{\overline{cd} + a} + a + cd + ab\)</span>:</p>
<blockquote>
<p><span class="math">\[
\begin{align*}
\overline{\overline{cd} + a} + a + cd + ab &amp;= \overline{\overline{c}}d\overline{a} + a + cd + ab = cd\overline{a} + a + cd + ab \\
&amp;= cd(\overline{a} + 1) + a + ab = cd + a + ab = cd + a(1 + b) = cd + a
\end{align*}
\]</span><br />Note that this is still a <strong>sum of products</strong> (SOP), although it isn't necessarily unique. A product of sums (POS) is what we would get if we worked with maxterms. A sum of products is always a 2-level circuit.</p>
</blockquote>
<p>We can use Boolean algebra to convert the sum of minterms or product of maxterms into a simplified expression. This allows us to convert a truth table into a sinple Boolean expression.</p>
<p>We can also represent a sum of minterms like <span class="math">\(m_{a_1} + \ldots + m_{a_n}\)</span> using the shorthand notation <span class="math">\(\sum(a_1, \ldots, a_n)\)</span>. For example, <span class="math">\(f = m_3 + m_5 + m_6 + m_7\)</span> can also be written as <span class="math">\(\sum(3, 5, 6, 7)\)</span>.</p>
<p>Likewise, maxterms have a shorthand as well: <span class="math">\(M_{a_1} + \ldots + M_{a_n}\)</span> can be written as <span class="math">\(\prod(a_1, \ldots, a_n)\)</span>.</p>
<p>Each logical operation has a physical cost when we build the circuit in real life. For now, each gate costs 1 unit, each gate input costs 1 unit, and the inverters at inputs are free. For example, <span class="math">\(xy + yz\)</span> has a 2-input OR, and two 2-input ANDs, so it has a cost of <span class="math">\((1 + 2) + 2 \cdot (1 + 2) = 9\)</span>.</p>
<p>To convert between a sum of products and a product of sums, invert it twice and apply De Morgan's laws. For example, let <span class="math">\(f = \sum(1, 4, 7)\)</span>:</p>
<blockquote>
<p>Clearly, <span class="math">\(f = m_1 + m_4 + m_7 = \overline{\overline{f}}\)</span>.<br />Clearly, <span class="math">\(\overline{f} = m_0 + m_2 + m_3 + m_5 + m_6\)</span>, the minterms that are not part of the function.<br />So <span class="math">\(f = \overline{m_0 + m_2 + m_3 + m_5 + m_6} = \overline{m_0}\overline{m_2}\overline{m_3}\overline{m_5}\overline{m_6}\)</span>, by De Morgan's laws.<br />Note that <span class="math">\(\overline{m_i} = M_i\)</span> - a maxterm is the negation of its corresponding minterm.<br />So <span class="math">\(f = \overline{m_0}\overline{m_2}\overline{m_3}\overline{m_5}\overline{m_6} = M_0 M_2 M_3 M_5 M_6\)</span>, a product of sums, as required.</p>
</blockquote>
<h1 id="section-3">12/1/15</h1>
<h2 id="other-logic-gates">Other Logic Gates</h2>
<p>The NAND gate is an AND gate with an inverted output, written <span class="math">\(x \uparrow y\)</span>. The NOR gate is an OR gate with an inverted output, written <span class="math">\(x \downarrow y\)</span>.</p>
<p>When we invert an input or an output, we can just put a hollow small bubble/circle inline with the wire, conventionally touching the gate.</p>
<p>Note that NAND and NOR are not associative, so two NAND/NOR gates chained together is different from a three-input NAND/NOR gate.</p>
<p>These gates are extremely useful for circuits built using technology such as CMOS. In CMOS, the cheapest construct is the NAND gate, so we tend to make other constructs in terms of NAND gates.</p>
<p>However, we generally want to work with normal gates like AND and OR, and convert it into NAND at the end. Since NAND and NOR are universal, any combinatorial circuit can be represented using just one of these gates.</p>
<p>To convert sums of products into NAND logic, simply negate the whole thing twice and apply De Morgan's law. For example, <span class="math">\(f = a \overline b + \overline b + c = \overline{\overline f} = \overline{\overline{a \overline b} \overline{\overline a b} \overline c}\)</span>, and the final result is all NAND gates. This can also be done recursively on subexpressions. This also works for converting products of sums into NOR logic.</p>
<p>Alternatively, we can also just replace each individual gate with its NAND equivalent. For reference, <span class="math">\(x + y = (x \uparrow x) \uparrow (y \uparrow y)\)</span>, <span class="math">\(xy = (x \uparrow y) \uparrow (x \uparrow y)\)</span>, and <span class="math">\(\overline x = x \uparrow x\)</span>.</p>
<p>This also works graphically. In a circuit schematic, simply insert two back-to-back inverters inline to wires, until it is possible to see NAND forms. By moving one of a pair of inserted inverters into the output for an AND gate, for example, we can replace the AND and NOT with a NAND gate.</p>
<p>Essentially, we first insert pairs of inverters until all gates have been converted into NAND, then remove any remaining back-to-back inverters (since they cancel each other out) and replace any remaining single inverters with their NAND forms.</p>
<h1 id="section-4">13/1/15</h1>
<p>Boolean XOR is represented with <span class="math">\(x \oplus y\)</span>. The schematic symbol for this operation is an OR gate, but with the concave side having two lines. It has the same precedence in Boolean algebra as the AND gate.</p>
<p>Boolean XOR essentially is true if and only if there are an odd number of operands that are true. For two inputs this is useful as an inequality operator <span class="math">\(\ne\)</span>.</p>
<p><span class="math">\(x \oplus y = \overline x y + x \overline y\)</span>. This pattern appears quite often in practical Boolean algebra, and so using XOR can often simplify formulas quite a bit. Plus, in technologies like CMOS, XOR can be implemented significantly cheaper than its long, SOP form, so we can save on cost too by using this.</p>
<p>Boolean NXOR (also known as XNOR) is simply XOR inverted. For two inputs this is useful as an equality operator <span class="math">\(=\)</span>.</p>
<p>A <strong>buffer</strong> is a special identity gate, <span class="math">\(f = x\)</span>, which has the same output as it does input. It has the same symbol as the inverter, but without the circle at the output.</p>
<p>This is useful for amplifying signals and supplying current when there are a lot of branches. Additionally, it can act as a diode (in 3-level logic) when placed in a real circuit. Plus, sometimes we use it for slowing down a signal slightly to improve timing synchronocity. Mathematically, it does not serve any purpose.</p>
<p>A tri-state buffer is similar, but has another input called Enable coming out of one side. When the Enable wire is high, the output is the same as the input. When enable is low, the output is disconnected from the input - the value of the output is not specified.</p>
<p>Tri-state buffers are useful if we want to connect multiple sources to the same destination. For example, in RAM we might have one per RAM cell, and selectively connect and disconnect the RAM cell such that only one cell is actually connected to the destination at a given time. This is important, since if we have two RAM cells connected at the same time, one with 0's and one with 1's, there would be a short circuit.</p>
<h2 id="karnaugh-maps">Karnaugh Maps</h2>
<p>Karnaugh maps (K-maps) are a way of describing Boolean functions with around 5 or less inputs (for larger inputs, it becomes impractical, as the number of table cells grows with <span class="math">\(2^n\)</span>).</p>
<p>K-maps are also useful because they can be used to minimise functions by graphically performing Boolean algebra.</p>
<p>Consider K-map for the function <span class="math">\(f = \overline x \overline y + \overine x y + x y\)</span>:</p>
<table>
<thead>
<tr class="header">
<th align="left"><span class="math">\(y\)</span>$x$</th>
<th align="left">0</th>
<th align="left">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>0</strong></td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left"><strong>1</strong></td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Note that each normal box (rectangle) corresponds to a row in the truth table for the function, and each 1 in a normal box corresponds to a minterm.</p>
<p>Note that the bottom two are both 1. That means that the value of <span class="math">\(x\)</span> does not influence the bottom row, so we can draw a rectangle around the bottom two, which represents <span class="math">\(y\)</span>.</p>
<p>Note that we can do the same for the leftmost row of two 1's, a rectangle around the two representing <span class="math">\(\overline x\)</span>.</p>
<p>If we want to minimise a function, the goal of K-mapping is to find the smallest possible number of the largest possible rectangles that cover all the 1 boxes and do not cover any 0 boxes (floating boxes don't matter). In each step, we try to draw a rectangle that encloses as many 1's as possible without enclosing any 0's.</p>
<p>This implies that there may be multiple optimal minimal versions of the function, with the same cost. This is represented by multiple minimal rectangle possibilities in the table, or multiple factoring possibilities in the Boolean expression</p>
<p>All rectangles must have side lengths that are powers of 2.</p>
<p>Mathematically, when we draw a rectangle we are duplicating a term and then factoring an input out. The boxes we drew above corresponded to the operations <span class="math">\(f = \overline x \overline y + \overline x y + xy = \overline x \overline y + \overline x y + xy + \overline x y = \overline x(\overline y + y) + y(x + \overline x) = \overline x + y\)</span>.</p>
<p>Basically, every rectangle duplicates and factors two terms, repeatedly for larger rectangles. This is the reason rectangles need to have dimensions that are powers of 2. Larger rectangles result in products with fewer factors. Fewer rectangles result in fewer products.</p>
<p>The above technique resulted in a sum of products. To get a product of sums, draw maximum rectangles that cover all 0's but no 1's. Rather than a product, each rectangle has a corresponding sum, made up of the inverted inputs that actually matter in making the function 0.</p>
<p>For example, if there is a 0 at <span class="math">\(x_1 = 0, x_2 = 0, x_3 = 1, x_4 = 1\)</span>, the rectangle surrounding just that 0 is associated with <span class="math">\(x_1 + x_2 + \overline{x_3} + \overline{x_4}\)</span>. The minimized product of sums is simply the product of the sum associated with each rectangle.</p>
<p>Also, the sides are labelled using grey code, and the rectangles can wrap around the sides of the table.</p>
<h1 id="section-5">14/1/15</h1>
<p>When doing K-maps, we can read off the answer from the rectangles by looking at which variables did not change within the minterms in a given rectangle. If all the minterms in a rectangle have <span class="math">\(x_1\)</span> equal to 0, but all other variables may change, then the rectangle represents the term <span class="math">\(\overline x_1\)</span>.</p>
<p>If we look at the table and see that no rectangles can be expanded, that means that in the Boolean expression, there is no more factoring or collapsing left to be done.</p>
<p>For K-maps of larger dimensions, we label the rows and columns using grey code - a binary counting system in which only one bit changes when incrementing or decrementing a value. The grey code is recursively defined. The 1-bit grey code is <code>grey_code(1) = [0, 1]</code>. The <span class="math">\(n\)</span>-bit grey code is <code>grey_code[n] = map(grey_code[n - 1], lambda code: 0 .. code) + map(reversed(grey_code[n - 1]), lambda code: 1 .. code)</code>.</p>
<p>In other words, to get the next grey code, we prepend a 0 to every binary string in the current grey code, and prepend a 1 to the reversed version of the current grey code, then put these two together.</p>
<p>Every variable splits the output space of a function in half. Let <span class="math">\(f(x_1, \ldots, x_n)\)</span> be a Boolean function. Let <span class="math">\(f_0\)</span> represent <span class="math">\(f(0, x_2, \ldots, x_n)\)</span> and <span class="math">\(f_1\)</span> represent <span class="math">\(f(1, x_2, \ldots, x_n)\)</span>.</p>
<h1 id="section-6">16/1/15</h1>
<h3 id="more-dimensions">More Dimensions</h3>
<p>The 5-input K-map is 3-dimensional. This is because the rectangles in 2D can only factor up to 2 variables per dimension.</p>
<p>As a result, it is difficult to visualize. Instead, what we can do is <span class="math">\(f = \overline x f_0 + x f_1\)</span>, and then do one K-map for <span class="math">\(f_0\)</span> and one for <span class="math">\(f_1\)</span> side by side. This represents a 4 by 4 by 2 cuboid. Now, instead of finding rectangles, we find cuboids - we can join rectangles that are adjacent across their K-map, but also between the two K-maps:</p>
<table>
<thead>
<tr class="header">
<th align="left"><span class="math">\(x_3 x_4\)</span>$x_1 x_2, x_5 = 0$</th>
<th align="left">00</th>
<th align="left">01</th>
<th align="left">11</th>
<th align="left">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>00</strong></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left"><strong>01</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left"><strong>11</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left"><strong>10</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left"><span class="math">\(x_3 x_4\)</span>$x_1 x_2$ <span class="math">\(x_5 = 1\)</span></th>
<th align="left">00</th>
<th align="left">01</th>
<th align="left">11</th>
<th align="left">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>00</strong></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left"><strong>01</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left"><strong>11</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left"><strong>10</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>There is a 2x2x2 cuboid at the middle, a 2x1x2 cuboid at the top corners, a 1x2x1 cuboid at the right side of the right K-map, and a 1x2x2 cuboid at the second-to-leftmost row at the bottom of the tables. This corresponds to the terms <span class="math">\(x_2 x_4\)</span>, <span class="math">\(\overline{x_2} \overline{x_3} \overline{x_4}\)</span>, <span class="math">\(x_1 \overline{x_2} x_3 x_5\)</span>, <span class="math">\(\overline{x_1} x_2 x_3\)</span>.</p>
<p>Potentially, we could also do 6 variable maps by making 4 4-input K-maps, but this is much more difficult to visualize.</p>
<h3 id="extensions">Extensions</h3>
<p>Sometimes, the output of a function doesn't matter, like when we have inputs that will never occur. When this is the case, we can say that the value of the function is a <strong>don't care</strong>. In truth tables and other situations, this is represented as &quot;x&quot;. The don't cares are part of the specifications of a circuit.</p>
<p>For example, suppose we have a binary to decimal converter, a circuit that accepts 4 inputs and 10 outputs that interprets the 4 inputs as a 4-bit binary number and turns on 1 of the 10 inputs depending on the binary value of the input being between 0 and 9 inclusive. In this case, we can assume that the input binary value will never be above 9, since the circuit wouldn't work then anyways, and all the outputs for those inputs would be don't cares.</p>
<p>In a K-map, we can include don't cares in rectangles if we want to, but it's not required - we can include them in rectangles if it helps us make rectangles larger, but we can leave don't cares outside of rectangles if they don't help.</p>
<p>The minimized function resulting from the K-map is functionally equivalent - both implementations do what we want them to - but they might not be logically equivalent, when we use don't cares.</p>
<p>When we want to minimise a function with multiple outputs, we could try to minimise each output individually as functions with only one output, but this is not necessarily the lowest cost circuit, since there are a lot of logical signals that get duplicated.</p>
<p>In the K-map, this translates to sometimes not expanding rectangles when it is possible to. Sometimes, with multiple sums of products, the best overall solution is one where the individual sums of products are not necessarily best.</p>
<p>Essentially, we can sometimes do <strong>product term sharing</strong> to lower overall cost when multiple SOPs use the same ones. We can sometimes do this in Boolean algebra by factoring to find common products.</p>
<p>Finding the best overall solution is a problem known as multiple output minimization, and is an NP-hard problem.</p>
<h3 id="math-background">Math Background</h3>
<p>A product term <span class="math">\(a\)</span> <strong>covers</strong> a product term <span class="math">\(b\)</span> if and only if <span class="math">\(b = 1 \implies a = 1\)</span>.</p>
<p>A product term is an <strong>implicant</strong> of a function <span class="math">\(f\)</span> if and only if <span class="math">\(f = 1\)</span> for all minterms covered by the product term - all the minterms that the product term covers are those that correspond to truth table rows that are 1. In a K-map, an implicant is a rectangle of 1's and possibly don't cares.</p>
<p>A <strong>prime implicant</strong> is an implicant in which no variable can be removed without making it a non-implicant - it is an implicant that cannot be simplified by removing variables. In a K-map, these are the largest possible rectangles of 1's.</p>
<h1 id="section-7">19/1/15</h1>
<p>An <strong>essential prime implicant</strong> is a prime implicant that covers a minterm that is not in any other prime implicant.</p>
<p>Functions implemented with prime implicants tend to be cheaper, since the AND gates have as few inputs as possible, and the bigger the area an implicant covers, the less other 1's we need to include. As a result, the minimum sum of products is an implementation of the function using as few prime implicants as possible, and each one as large as possible.</p>
<p>Every function can be implemented as a set of prime implicants, all OR'd together. We must include all the essential prime implicants, but we might also have prime implicants that would be prime if they didn't overlap. We must therefore choose rectangles from the remaining non-essential implicants such that we cover all the 1's, with as few rectangles as possible.</p>
<h2 id="cmos">CMOS</h2>
<p>CMOS is one of the most popular technologies around for implementing logic gates. In CMOS, the cheapest 2-input gates are NAND and NOR, which uses the fewest transistors possible. The two types of transistors in CMOS are NMOS and PMOS.</p>
<h3 id="nmos">NMOS</h3>
<p>An <strong>NMOS</strong> (N-channel MOSFET) has a source <span class="math">\(S\)</span> (often connected to a lower voltage), a drain <span class="math">\(D\)</span> (often connected to a higher voltage), and a gate <span class="math">\(G\)</span> (which controls the current flowing from the drain to the source):</p>
<div class="figure">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjYwIiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NCI+PHJlY3QgeD0iMCIgeT0iMCIgZmlsbD0id2hpdGUiIHdpZHRoPSI2MHB4IiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NHB4Ii8+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEwLDEwKSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGlkPSJwYXRoMzgxMyIgZD0ibTIxLDE5LjkyNSwzLTIsMCw0LTMtMnoiIGZpbGw9Im5vbmUiLz4KPC9nPjwvc3ZnPg==" alt="NMOS Transistor" /><p class="caption">NMOS Transistor</p>
</div>
<p>Another common schematic symbol for an NMOS is a <span class="math">\(\pi\)</span>-shape (with straight legs) with a bar on top connected to the gate, where the legs of the <span class="math">\(\pi\)</span> are the source and drain.</p>
<p>If we set the gate voltage <span class="math">\(V_G\)</span> to a voltage greater than some threshold voltage <span class="math">\(V_T\)</span> (like 2V, for example), so <span class="math">\(V_G &gt; V_T\)</span>, the NMOS just acts like a short circuit between the drain and the ground (the drain is &quot;pulled down&quot; to ground). If we we set it to ground (0V), the NMOS just acts like an open circuit between the drain and the source.</p>
<p>Basically, <strong>an NMOS is a tri-state buffer, with input 1 that works best on the low side</strong>, with the drain being the input, the source being the output, and the gate being the enable pin.</p>
<h3 id="pmos">PMOS</h3>
<p>A <strong>PMOS</strong> (P-channel MOSFET) has a source (often connected to a higher voltage), a drain (often connected to a lower voltage), and a gate (which controls the current flowing from the drain to the source).</p>
<div class="figure">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjYwIiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NCI+PHJlY3QgeD0iMCIgeT0iMCIgZmlsbD0id2hpdGUiIHdpZHRoPSI2MHB4IiBoZWlnaHQ9IjYxLjQyMTg3NDA0NjMyNTY4NHB4Ii8+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMCwxMCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZ2F0ZSBkcmFpbiBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+cG1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4JPHJlY3QgaWQ9InJlY3QyMTYyIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIHZpc2liaWxpdHk9ImhpZGRlbiIgZmlsbD0ibm9uZSIvPgogIDxyZWN0IGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDIzOTgiIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgaWQ9InRleHQyODIzIiBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MjciIGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODMxIiBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBpZD0icGF0aDI4OTEiIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM0IiBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNiIgZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzOCIgZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDIiIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ0IiBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NiIgZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDgiIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBpZD0icGF0aDI5NTIiIGQ9Im0yNiwxNy45MjUsMywyLTMsMiwwLTR6IiBmaWxsPSJub25lIi8+CgogIDwvZz48L3N2Zz4=" alt="PMOS Transistor" /><p class="caption">PMOS Transistor</p>
</div>
<p>Another common schematic symbol for a PMOS is a <span class="math">\(\pi\)</span>-shape (with straight legs) with a bar on top connected to the gate by a bubble (like an inverting bubble on the input), where the legs of the <span class="math">\(\pi\)</span> are the source and drain. This is the same as the alternate symbol for the NMOS, but with a bubble on the gate input.</p>
<p>If <span class="math">\(V_G - V_S &lt; -V_T\)</span> (source-gate voltage lower than threshold), the PMOS acts like a short circuit between the source and the drain. If <span class="math">\(V_G = V_S\)</span>, then the PMOS acts like an open circuit between the source and the drain.</p>
<p>Basically, <strong>a PMOS is a tri-state buffer with input 1, that works best on the high side</strong>, with source being the input, the drain being the output, and the enable pin being the inverted value of the gate.</p>
<h3 id="cmos-logic">CMOS Logic</h3>
<p>We can implement a NOT gate very simply using NMOS and PMOS:</p>
<div class="figure">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjE2NS4xNDA2MjUiIGhlaWdodD0iMTQ3LjUiPjxyZWN0IHg9IjAiIHk9IjAiIGZpbGw9IndoaXRlIiB3aWR0aD0iMTY1LjE0MDYyNXB4IiBoZWlnaHQ9IjE0Ny41cHgiLz48ZyBjb25uZWN0cz0iMTAsMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0id2lyZSIgY2xhc3M9Im5hbWV3aXJlIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5OTk5OTk5OTk5OTksMCwwLDAuOTk5OTk5OTk5OTk5OTk5OSw4OS45OTk5OTk5OTk5OTk4OSwxOS45OTk5OTk5OTk5OTk4ODYpIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjEwIiB5PSIyMCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPndpcmU8L3d0eDppZD4KICAgIDx3dHg6dHlwZT53aXJlPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5uYW1ld2lyZTwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnBvd2VyPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXAvPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cmVjdCB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHg9IjAiIHk9IjAiIGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIi8+CiAgICA8cGF0aCBkPSJNIDkuODQ1MzU1NywwLjc1MTU1MTMyIEwgOS43ODg5ODYxLDIwLjAyNjA5IiBpZD0icGF0aDM2OTQiLz4KICAgIDxwYXRoIGQ9Ik0gNi44OTg0MDk1LDYuMDQwMDU2NyBMIDkuNzc2Njc5LDAuNjU4MzY3NDMgTCAxMy4xMTYxNTUsNS45MjE0Njc1IiBpZD0icGF0aDUwODkiLz4KCiAgPC9nPjxnIGNvbm5lY3RzPSIxMCwwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9IkduZCIgY2xhc3M9Imdyb3VuZCIgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTk5OTk5OTk5OTk5OTk5LDAsMCwwLjk5OTk5OTk5OTk5OTk5OTksODkuOTk5OTk5OTk5OTk5ODksMTE5Ljk5OTk5OTk5OTk5OTg5KSI+CjxtZXRhZGF0YT4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjEwIiB5PSIwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+Z25kPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+Z25kPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5ncm91bmQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT5wb3dlcjwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDpmbGlwLz4KICAgIDx3dHg6dmFsdWUvPgogICAgPHd0eDpsYWJlbC8+CiAgICA8d3R4OnNwaWNlLz4KICAgIDx3dHg6bW9kZWwvPgo8L3d0eDpwYXJ0Pgo8L21ldGFkYXRhPgoKICAgIDxwYXRoIGQ9Ik0gMTAsMCBMIDEwLDExIiBpZD0icGF0aDM2OTQiLz4KICAgIDxwYXRoIGQ9Ik0gMC41MDAwMDAwNiwxMS44MzQxNTMgTCAxOS42NzEyNzUsMTEuODM0MTUzIiBpZD0icGF0aDM2OTYiLz4KICAgIDxwYXRoIGQ9Ik0gMi42NDgwODIzLDE0LjUgTCAxNy43MzI4ODEsMTQuNSIgaWQ9InBhdGgzNjk4Ii8+CiAgICA8cGF0aCBkPSJNIDUuODAyODczLDE3LjUgTCAxNC42NDgwODIsMTcuNSIgaWQ9InBhdGgzNzAwIi8+CiAgPC9nPjxjaXJjbGUgY3g9IjY5Ljk5OTk5OTk5OTk5OTk0IiBjeT0iODAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5OTk5OTk5OTk5OTksMCwwLDAuOTk5OTk5OTk5OTk5OTk5OSw2OS45OTk5OTk5OTk5OTk4OSw3OS45OTk5OTk5OTk5OTk4OSkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZHJhaW4gZ2F0ZSBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgoJICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMzAiIHk9IjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSIwIiB5PSIyMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjMiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjQiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPm08L3d0eDppZD4KICAgIDx3dHg6dHlwZT5tPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5ubW9zZmV0PC93dHg6bmFtZT4KICAgIDx3dHg6Y2F0ZWdvcnk+dHJhbnNpc3RvcnM8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6dmFsdWUvPgogICAgPHd0eDpsYWJlbC8+CiAgICA8d3R4OnNwaWNlLz4KICAgIDx3dHg6ZmxpcD50cnVlPC93dHg6ZmxpcD4KICAgIDx3dHg6bW9kZWwvPgo8L3d0eDpwYXJ0Pgo8L21ldGFkYXRhPiAgPHJlY3QgaWQ9InJlY3QyMTYyIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjM5OCIgZmlsbD0ibm9uZSIgZD0iTTE5Ljg3NywxMi4wOHoiLz4KICA8dGV4dCBpZD0idGV4dDI4MjMiIGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgyNyIgZm9udC1zaXplPSI4LjAwMDgzMTZweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjcuNDIwODMyMiIgeD0iMzIuMDcyNzIxIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RDwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MzEiIGZvbnQtc2l6ZT0iOC4wNDg0NTcxNXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMzkuNDE0OTc4IiB4PSIzMi4zMzM0ODciIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5TPC90ZXh0PgogIDxwYXRoIGlkPSJwYXRoMjg5MSIgZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzQiIGQ9Im0yMCwyNi45MjUsMTAsMCwwLDEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM2IiBkPSJtMjAsMTkuOTI1LDEwLDAsMCw3IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM4IiBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0MiIgZD0ibTIwLDIzLjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDQiIGQ9Ik0yMCwxNS45MjUsMjAsOS45MjU1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ2IiBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0OCIgZD0ibTE3LDE5LjkyNS0xNywwIiBmaWxsPSJub25lIi8+CiA8cGF0aCBpZD0icGF0aDM4MTMiIGQ9Im0yMSwxOS45MjUsMy0yLDAsNC0zLTJ6IiBmaWxsPSJub25lIi8+CjwvZz48ZyBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJwbW9zZmV0IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5OTk5OTk5OTk5OTksMCwwLDAuOTk5OTk5OTk5OTk5OTk5OSw2OS45OTk5OTk5OTk5OTk4OSwzOS45OTk5OTk5OTk5OTk4ODYpIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGlkPSJyZWN0MjE2MiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGZpbGw9Im5vbmUiLz4KICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KCiAgPHBhdGggaWQ9InBhdGgyOTUyIiBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PHRleHQgeD0iMTQ4LjQ1ODMyODI0NzA3MDMiIHk9IjgzLjk3OTE0ODg2NDc0NjEiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+RjwvdGV4dD48dGV4dCB4PSIyMC43NTAwMTUyNTg3ODkwNjIiIHk9Ijg0LjYwNDE0ODg2NDc0NjEiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+QTwvdGV4dD48bGluZSB4MT0iOTkuOTk5OTk5OTk5OTk5OTQiIHkxPSI4MCIgeDI9IjEzOS45OTk5OTk5OTk5OTk5NCIgeTI9IjgwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMzkuOTk5OTk5OTk5OTk5OTQiIHkxPSI4MCIgeDI9IjY5Ljk5OTk5OTk5OTk5OTk0IiB5Mj0iODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2OS45OTk5OTk5OTk5OTk5NCIgeTE9IjgwIiB4Mj0iNjkuOTk5OTk5OTk5OTk5OTQiIHkyPSIxMDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2OS45OTk5OTk5OTk5OTk5NCIgeTE9IjYwIiB4Mj0iNjkuOTk5OTk5OTk5OTk5OTQiIHkyPSI4MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PC9zdmc+" alt="NOT gate" /><p class="caption">NOT gate</p>
</div>
<p>We can analyze this by considering the cases. When the input <span class="math">\(V_x\)</span> is low, the PMOS is enabled and the NMOS is disabled, pulling the output high. When <span class="math">\(V_x\)</span> is high, the PMOS is disabled and the NMOS is disabled, pulling the output low.</p>
<p>A NAND gate extends this concept slightly:</p>
<div class="figure">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjIwOC4yNjU2MjUiIGhlaWdodD0iMTkxLjQyMTg3NSI+PHJlY3QgeD0iMCIgeT0iMCIgZmlsbD0id2hpdGUiIHdpZHRoPSIyMDguMjY1NjI1cHgiIGhlaWdodD0iMTkxLjQyMTg3NXB4Ii8+PHRleHQgeD0iMTkxLjU4MzI4MjQ3MDcwMzE4IiB5PSIxMDMuNTYyNDY5NDgyNDIxODgiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+RjwvdGV4dD48dGV4dCB4PSIyNi45OTk5ODQ3NDEyMTA5OTQiIHk9Ijk0LjE4NzQ2OTQ4MjQyMTg4IiBmb250LXNpemU9IjEyIiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwcHgiPkI8L3RleHQ+PHRleHQgeD0iMjQuOTE2NjQxMjM1MzUxNjIiIHk9IjYxLjg5NTgxMjk4ODI4MTI1IiBmb250LXNpemU9IjEyIiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwcHgiPkE8L3RleHQ+PGNpcmNsZSBjeD0iNzAuMDAwMDAwMDAwMDAwMDYiIGN5PSI2MCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI3MC4wMDAwMDAwMDAwMDAwNiIgY3k9IjE2MCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI4MC4wMDAwMDAwMDAwMDAwNiIgY3k9IjkwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjEyMC4wMDAwMDAwMDAwMDAwNiIgY3k9IjkwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjE1MC4wMDAwMDAwMDAwMDAwNiIgY3k9IjEwMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48ZyBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJwbW9zZmV0IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDEyMC4wMDAwMDAwMDAwMDAwNiw0MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZ2F0ZSBkcmFpbiBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+cG1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4JPHJlY3QgaWQ9InJlY3QyMTYyIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIHZpc2liaWxpdHk9ImhpZGRlbiIgZmlsbD0ibm9uZSIvPgogIDxyZWN0IGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDIzOTgiIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgaWQ9InRleHQyODIzIiBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MjciIGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODMxIiBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBpZD0icGF0aDI4OTEiIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM0IiBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNiIgZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzOCIgZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDIiIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ0IiBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NiIgZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDgiIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBpZD0icGF0aDI5NTIiIGQ9Im0yNiwxNy45MjUsMywyLTMsMiwwLTR6IiBmaWxsPSJub25lIi8+CgogIDwvZz48Y2lyY2xlIGN4PSIxMTAuMDAwMDAwMDAwMDAwMDYiIGN5PSIxMDAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDgwLjAwMDAwMDAwMDAwMDA2LDE0MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZHJhaW4gZ2F0ZSBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgoJICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMzAiIHk9IjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSIwIiB5PSIyMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjMiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjQiIHg9IjMwIiB5PSI0MCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPm08L3d0eDppZD4KICAgIDx3dHg6dHlwZT5tPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5ubW9zZmV0PC93dHg6bmFtZT4KICAgIDx3dHg6Y2F0ZWdvcnk+dHJhbnNpc3RvcnM8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6dmFsdWUvPgogICAgPHd0eDpsYWJlbC8+CiAgICA8d3R4OnNwaWNlLz4KICAgIDx3dHg6ZmxpcD50cnVlPC93dHg6ZmxpcD4KICAgIDx3dHg6bW9kZWwvPgo8L3d0eDpwYXJ0Pgo8L21ldGFkYXRhPiAgPHJlY3QgaWQ9InJlY3QyMTYyIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjM5OCIgZmlsbD0ibm9uZSIgZD0iTTE5Ljg3NywxMi4wOHoiLz4KICA8dGV4dCBpZD0idGV4dDI4MjMiIGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgyNyIgZm9udC1zaXplPSI4LjAwMDgzMTZweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjcuNDIwODMyMiIgeD0iMzIuMDcyNzIxIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RDwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MzEiIGZvbnQtc2l6ZT0iOC4wNDg0NTcxNXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMzkuNDE0OTc4IiB4PSIzMi4zMzM0ODciIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5TPC90ZXh0PgogIDxwYXRoIGlkPSJwYXRoMjg5MSIgZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzQiIGQ9Im0yMCwyNi45MjUsMTAsMCwwLDEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM2IiBkPSJtMjAsMTkuOTI1LDEwLDAsMCw3IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM4IiBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0MiIgZD0ibTIwLDIzLjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDQiIGQ9Ik0yMCwxNS45MjUsMjAsOS45MjU1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ2IiBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0OCIgZD0ibTE3LDE5LjkyNS0xNywwIiBmaWxsPSJub25lIi8+CiA8cGF0aCBpZD0icGF0aDM4MTMiIGQ9Im0yMSwxOS45MjUsMy0yLDAsNC0zLTJ6IiBmaWxsPSJub25lIi8+CjwvZz48ZyBjb25uZWN0cz0iMCwyMDszMCwwOzMwLDQwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJubW9zZmV0IiBmbGlwcGFibGU9InRydWUiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsODAuMDAwMDAwMDAwMDAwMDYsMTAwKSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGlkPSJwYXRoMzgxMyIgZD0ibTIxLDE5LjkyNSwzLTIsMCw0LTMtMnoiIGZpbGw9Im5vbmUiLz4KPC9nPjxnIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0ibSIgY2xhc3M9InBtb3NmZXQiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsODAuMDAwMDAwMDAwMDAwMDYsNDApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGlkPSJyZWN0MjE2MiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiB2aXNpYmlsaXR5PSJoaWRkZW4iIGZpbGw9Im5vbmUiLz4KICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KCiAgPHBhdGggaWQ9InBhdGgyOTUyIiBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PGcgY29ubmVjdHM9IjEwLDIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9IndpcmUiIGNsYXNzPSJuYW1ld2lyZSIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMDAuMDAwMDAwMDAwMDAwMDYsMjApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjEwIiB5PSIyMCIvPgogICAgICAgIDwvd3R4OmFuYWxvZz4KICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPndpcmU8L3d0eDppZD4KICAgIDx3dHg6dHlwZT53aXJlPC93dHg6dHlwZT4KICAgIDx3dHg6bmFtZT5uYW1ld2lyZTwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnBvd2VyPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXAvPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cmVjdCB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHg9IjAiIHk9IjAiIGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIi8+CiAgICA8cGF0aCBkPSJNIDkuODQ1MzU1NywwLjc1MTU1MTMyIEwgOS43ODg5ODYxLDIwLjAyNjA5IiBpZD0icGF0aDM2OTQiLz4KICAgIDxwYXRoIGQ9Ik0gNi44OTg0MDk1LDYuMDQwMDU2NyBMIDkuNzc2Njc5LDAuNjU4MzY3NDMgTCAxMy4xMTYxNTUsNS45MjE0Njc1IiBpZD0icGF0aDUwODkiLz4KCiAgPC9nPjxsaW5lIHgxPSI0MC4wMDAwMDAwMDAwMDAwNiIgeTE9IjYwIiB4Mj0iNzAuMDAwMDAwMDAwMDAwMDYiIHkyPSI2MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjcwLjAwMDAwMDAwMDAwMDA2IiB5MT0iNjAiIHgyPSI3MC4wMDAwMDAwMDAwMDAwNiIgeTI9IjE2MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjQwLjAwMDAwMDAwMDAwMDA2IiB5MT0iOTAiIHgyPSI4MC4wMDAwMDAwMDAwMDAwNiIgeTI9IjkwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iODAuMDAwMDAwMDAwMDAwMDYiIHkxPSI5MCIgeDI9IjgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNzAuMDAwMDAwMDAwMDAwMDYiIHkxPSI2MCIgeDI9IjgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iNjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MC4wMDAwMDAwMDAwMDAwNiIgeTE9IjE2MCIgeDI9IjgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTYwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iODAuMDAwMDAwMDAwMDAwMDYiIHkxPSI5MCIgeDI9IjEyMC4wMDAwMDAwMDAwMDAwNiIgeTI9IjkwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTIwLjAwMDAwMDAwMDAwMDA2IiB5MT0iNjAiIHgyPSIxMjAuMDAwMDAwMDAwMDAwMDYiIHkyPSI5MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MC4wMDAwMDAwMDAwMDAwNiIgeTE9IjgwIiB4Mj0iMTUwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTUwLjAwMDAwMDAwMDAwMDA2IiB5MT0iMTAwIiB4Mj0iMTgwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTEwLjAwMDAwMDAwMDAwMDA2IiB5MT0iMTAwIiB4Mj0iMTUwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTEwLjAwMDAwMDAwMDAwMDA2IiB5MT0iNDAiIHgyPSIxNTAuMDAwMDAwMDAwMDAwMDYiIHkyPSI0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMC4wMDAwMDAwMDAwMDAwNiIgeTE9IjgwIiB4Mj0iMTEwLjAwMDAwMDAwMDAwMDA2IiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48L3N2Zz4=" alt="NAND gate" /><p class="caption">NAND gate</p>
</div>
<p>When either <span class="math">\(V_x\)</span> or <span class="math">\(V_y\)</span> are 0, at least one PMOS will be enabled and the output will the pulled up (since they are in parallel), while at least one NMOS is disabled, preventing the output from getting pulled down (since they are in series). When both <span class="math">\(V_x\)</span> and <span class="math">\(V_y\)</span> are 1, both PMOSs are disabled, and the NMOSs are both enabled, allowing the output to be pulled down.</p>
<p>A NOR gate works in a similar fashion, but with the NMOSs in parallel and the PMOSs in series. It is now easy to make other gates such as AND and OR by combining these with NOT gates on the outputs.</p>
<p>The following is a <strong>transmission gate</strong>:</p>
<div class="figure">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjE2Mi4wMTU2MjUiIGhlaWdodD0iMTgxIj48cmVjdCB4PSIwIiB5PSIwIiBmaWxsPSJ3aGl0ZSIgd2lkdGg9IjE2Mi4wMTU2MjVweCIgaGVpZ2h0PSIxODFweCIvPjx0ZXh0IHg9IjI2IiB5PSI4NCIgZm9udC1zaXplPSIxMiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMHB4Ij5BPC90ZXh0Pjx0ZXh0IHg9IjE0NCIgeT0iODQiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+QjwvdGV4dD48dGV4dCB4PSI4MiIgeT0iMTY4IiBmb250LXNpemU9IjEyIiBmaWxsPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIwcHgiPkU8L3RleHQ+PGcgY29ubmVjdHM9IjAsMjA7NDAsMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0iRyIgY2xhc3M9Im5vdCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw1MCwyMCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgogICAgPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmRpZ2l0YWw+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSI0MCIgeT0iMjAiLz4KICAgICAgICA8L3d0eDpkaWdpdGFsPgoKICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPmludjwvd3R4OmlkPgoKICAgIDx3dHg6dHlwZT5pbnY8L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5vdDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PmRpZ2l0YWw8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6ZmxpcC8+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4Om1vZGVsLz4KICAgIDwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cGF0aCBkPSJNIDMxLjg2NDc3NCwyMC4wNzE0MjkgTCA4Ljc1Mzg4OCw0MC4zNTcxNDMgTCA4Ljc1Mzg4OCwwLjUgTCAzMS45ODI2NjMsMjAuNDE4NTY4IEwgMzkuODgyODE0LDIwLjQxODU2OCIgaWQ9InBhdGgxODg3IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNIDguNzUzODg4LDIwLjM1NzE0MyBMIDAuNSwyMC4zNTcxNDMiIGlkPSJwYXRoMTk3MCIvPgogICAgPHBhdGggZD0iTSAzNC4xNTUyOTIsMTkuOTk4OTkxIEMgMzQuMTU1NTk2LDIxLjg1MzQ4NCAzMy4zMzcyNDIsMjMuMzU3MTQzIDMyLjMyNzY0NiwyMy4zNTcxNDMgQyAzMS4zMTgwNSwyMy4zNTcxNDMgMzAuNDk5Njk2LDIxLjg1MzQ4NCAzMC41LDE5Ljk5ODk5MSBDIDMwLjQ5OTY5NiwxOC4xNDQ0OTggMzEuMzE4MDUsMTYuNjQwODM5IDMyLjMyNzY0NiwxNi42NDA4MzkgQyAzMy4zMzcyNDIsMTYuNjQwODM5IDM0LjE1NTU5NiwxOC4xNDQ0OTggMzQuMTU1MjkyLDE5Ljk5ODk5MSB6IiBpZD0icGF0aDE5NzIiIGZpbGw9Im5vbmUiLz4KICA8L2c+PGxpbmUgeDE9IjkwIiB5MT0iMTIwIiB4Mj0iOTAiIHkyPSIxNjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI1MCIgeTE9IjEyMCIgeDI9IjkwIiB5Mj0iMTIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNTAiIHkxPSI0MCIgeDI9IjUwIiB5Mj0iMTIwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTEwIiB5MT0iODAiIHgyPSIxNDAiIHkyPSI4MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMCIgeTE9IjgwIiB4Mj0iMTEwIiB5Mj0iOTAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSIxMTAiIHkxPSI3MCIgeDI9IjExMCIgeTI9IjgwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNDAiIHkxPSI4MCIgeDI9IjcwIiB5Mj0iODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjgwIiB4Mj0iNzAiIHkyPSI5MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjcwIiB5MT0iNzAiIHgyPSI3MCIgeTI9IjgwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48Y2lyY2xlIGN4PSI5MCIgY3k9IjEyMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI1MCIgY3k9IjEyMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48ZyBjb25uZWN0cz0iMCwyMDszMCwwOzMwLDQwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjJweCIgaWQ9Im0iIGNsYXNzPSJubW9zZmV0IiBmbGlwcGFibGU9InRydWUiIHRyYW5zZm9ybT0ibWF0cml4KC0xLjgzNjk3MDI3ODg3Nzc1MThlLTE2LC0xLDEsLTEuODM2OTcwMjc4ODc3NzUxOGUtMTYsNzAsMTIwKSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCBpZD0icmVjdDIxNjIiIHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyMzk4IiBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGlkPSJ0ZXh0MjgyMyIgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODI3IiBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGlkPSJ0ZXh0MjgzMSIgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggaWQ9InBhdGgyODkxIiBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNCIgZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzYiIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5MzgiIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQyIiBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NCIgZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDYiIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ4IiBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGlkPSJwYXRoMzgxMyIgZD0ibTIxLDE5LjkyNSwzLTIsMCw0LTMtMnoiIGZpbGw9Im5vbmUiLz4KPC9nPjxjaXJjbGUgY3g9IjExMCIgY3k9IjgwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjcwIiBjeT0iODAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoNi4xMjMyMzM2MDExODEzNDllLTE3LDEsLTEsNi4xMjMyMzM2MDExODEzNDllLTE3LDExMCw0MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgo8d3R4OnBhcnQgeG1sbnM6d3R4PSJodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2VidHJvbmljcyI+CiAgICA8d3R4OnBpbnM+CiAgICAgICAgPHd0eDphbmFsb2c+CjwhLS1waW4gb3JkZXIgaXMgZ2F0ZSBkcmFpbiBzb3VyY2Ugc3Vic3RyYXRlIApzdWJzdHJhdGUgaXMgY29ubmVjdGVkIHRvIHNvdXJjZS0tPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+cG1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4JPHJlY3QgaWQ9InJlY3QyMTYyIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIHZpc2liaWxpdHk9ImhpZGRlbiIgZmlsbD0ibm9uZSIvPgogIDxyZWN0IGlkPSJyZWN0MjE2MiIgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDIzOTgiIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgaWQ9InRleHQyODIzIiBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBpZD0idGV4dDI4MjciIGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgaWQ9InRleHQyODMxIiBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBpZD0icGF0aDI4OTEiIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTM0IiBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzNiIgZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjkzOCIgZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDIiIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggaWQ9InBhdGgyOTQ0IiBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGlkPSJwYXRoMjk0NiIgZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBpZD0icGF0aDI5NDgiIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBpZD0icGF0aDI5NTIiIGQ9Im0yNiwxNy45MjUsMywyLTMsMiwwLTR6IiBmaWxsPSJub25lIi8+CgogIDwvZz48L3N2Zz4=" alt="Transmission gate" /><p class="caption">Transmission gate</p>
</div>
<p>This gate happens to be very useful in making XOR gates. When <span class="math">\(E\)</span> is low, the PMOS's gate is high and the NMOS's gate is low, so no current can flow. When <span class="math">\(E\)</span> is high, the PMOS's gate is low and the NMOS's gate is high, so current can pass through in either direction through one transistor or the other.</p>
<p>To make a 3 or more input NAND gate, we can simply add more PMOSs in parallel and more NMOSs in series. Note that we can't extend these arbitrarily, since there is a voltage drop across each transistor - they aren't perfect open or closed circuits. Basically, in series the voltage will eventually drop too low to use, and in parallel, there will eventually be too much current leaking through closed transistors. As a rule of thumb, we can put no more than 4 transistors in series or parallel at a time.</p>
<h1 id="section-8">21/1/15</h1>
<p>The transmission gate has a schematic symbol as well - two overlapping triangles facing opposite horizontal directions, with a bubble on the top middle. We often put a NOT gate on the top input and connect it to the bottom input to make it act like a bidirectional tri-state buffer.</p>
<h3 id="xor-gates">XOR Gates</h3>
<p>Now we can implement XOR. Since <span class="math">\(a \oplus b = \overline a b + a \overline b\)</span>, we can just implement it with NAND gates, with 16 transistors. However, it is possible to do better using the transmission gate:</p>
<p><a href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyA/Pgo8IS0tQ3JlYXRlZCBieSB3ZWJ0cm9uaWNzIDAuMS0tPgo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjIxNi4zNDM3NSIgaGVpZ2h0PSIxOTMiPjxyZWN0IHg9IjAiIHk9IjAiIGZpbGw9IndoaXRlIiB3aWR0aD0iMjE2LjM0Mzc1cHgiIGhlaWdodD0iMTkzcHgiLz48ZyBjb25uZWN0cz0iMCwyMDs0MCwyMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJHIiBjbGFzcz0ibm90IiB0cmFuc2Zvcm09Im1hdHJpeCgxLDAsMCwxLDcwLDM5Ljk5OTk5OTk5OTk5OTk4NikiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgogICAgPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmRpZ2l0YWw+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSI0MCIgeT0iMjAiLz4KICAgICAgICA8L3d0eDpkaWdpdGFsPgoKICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPmludjwvd3R4OmlkPgoKICAgIDx3dHg6dHlwZT5pbnY8L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5vdDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PmRpZ2l0YWw8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6ZmxpcC8+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4Om1vZGVsLz4KICAgIDwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cGF0aCBkPSJNIDMxLjg2NDc3NCwyMC4wNzE0MjkgTCA4Ljc1Mzg4OCw0MC4zNTcxNDMgTCA4Ljc1Mzg4OCwwLjUgTCAzMS45ODI2NjMsMjAuNDE4NTY4IEwgMzkuODgyODE0LDIwLjQxODU2OCIgaWQ9InBhdGgxODg3IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNIDguNzUzODg4LDIwLjM1NzE0MyBMIDAuNSwyMC4zNTcxNDMiIGlkPSJwYXRoMTk3MCIvPgogICAgPHBhdGggZD0iTSAzNC4xNTUyOTIsMTkuOTk4OTkxIEMgMzQuMTU1NTk2LDIxLjg1MzQ4NCAzMy4zMzcyNDIsMjMuMzU3MTQzIDMyLjMyNzY0NiwyMy4zNTcxNDMgQyAzMS4zMTgwNSwyMy4zNTcxNDMgMzAuNDk5Njk2LDIxLjg1MzQ4NCAzMC41LDE5Ljk5ODk5MSBDIDMwLjQ5OTY5NiwxOC4xNDQ0OTggMzEuMzE4MDUsMTYuNjQwODM5IDMyLjMyNzY0NiwxNi42NDA4MzkgQyAzMy4zMzcyNDIsMTYuNjQwODM5IDM0LjE1NTU5NiwxOC4xNDQ0OTggMzQuMTU1MjkyLDE5Ljk5ODk5MSB6IiBpZD0icGF0aDE5NzIiIGZpbGw9Im5vbmUiLz4KICA8L2c+PGcgY29ubmVjdHM9IjAsMjA7NDAsMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0iRyIgY2xhc3M9Im5vdCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSw4MCw4MCkiPgo8bWV0YWRhdGEgY2xhc3M9InBhcnQiPgogICAgPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmRpZ2l0YWw+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMSIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIyIiB4PSI0MCIgeT0iMjAiLz4KICAgICAgICA8L3d0eDpkaWdpdGFsPgoKICAgIDwvd3R4OnBpbnM+CiAgICA8d3R4OmlkPmludjwvd3R4OmlkPgoKICAgIDx3dHg6dHlwZT5pbnY8L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5vdDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PmRpZ2l0YWw8L3d0eDpjYXRlZ29yeT4KICAgIDx3dHg6ZmxpcC8+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4Om1vZGVsLz4KICAgIDwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CiAgICA8cGF0aCBkPSJNIDMxLjg2NDc3NCwyMC4wNzE0MjkgTCA4Ljc1Mzg4OCw0MC4zNTcxNDMgTCA4Ljc1Mzg4OCwwLjUgTCAzMS45ODI2NjMsMjAuNDE4NTY4IEwgMzkuODgyODE0LDIwLjQxODU2OCIgaWQ9InBhdGgxODg3IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBkPSJNIDguNzUzODg4LDIwLjM1NzE0MyBMIDAuNSwyMC4zNTcxNDMiIGlkPSJwYXRoMTk3MCIvPgogICAgPHBhdGggZD0iTSAzNC4xNTUyOTIsMTkuOTk4OTkxIEMgMzQuMTU1NTk2LDIxLjg1MzQ4NCAzMy4zMzcyNDIsMjMuMzU3MTQzIDMyLjMyNzY0NiwyMy4zNTcxNDMgQyAzMS4zMTgwNSwyMy4zNTcxNDMgMzAuNDk5Njk2LDIxLjg1MzQ4NCAzMC41LDE5Ljk5ODk5MSBDIDMwLjQ5OTY5NiwxOC4xNDQ0OTggMzEuMzE4MDUsMTYuNjQwODM5IDMyLjMyNzY0NiwxNi42NDA4MzkgQyAzMy4zMzcyNDIsMTYuNjQwODM5IDM0LjE1NTU5NiwxOC4xNDQ0OTggMzQuMTU1MjkyLDE5Ljk5ODk5MSB6IiBpZD0icGF0aDE5NzIiIGZpbGw9Im5vbmUiLz4KICA8L2c+PGxpbmUgeDE9IjYwIiB5MT0iMTAwIiB4Mj0iNjAiIHkyPSIxODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2MCIgeTE9IjEwMCIgeDI9IjgwIiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iNjAiIHkxPSIxODAiIHgyPSIxMzAiIHkyPSIxODAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2MCIgeTE9IjIwIiB4Mj0iMTMwIiB5Mj0iMjAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjgwIiB4Mj0iNzAiIHkyPSIxMzAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjEzMCIgeDI9IjExMCIgeTI9IjEzMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjEyMCIgeTE9IjEwMCIgeDI9IjEzMCIgeTI9IjEwMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjEwMCIgeDI9IjE5MCIgeTI9IjEwMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjEwMCIgeDI9IjE1MCIgeTI9IjEzMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjcwIiB4Mj0iMTUwIiB5Mj0iMTAwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMTUwIiB5MT0iNTAiIHgyPSIxNTAiIHkyPSI3MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMCIgeTE9IjEzMCIgeDI9IjExMCIgeTI9IjE1MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIiBpZD0iIi8+PGxpbmUgeDE9IjE1MCIgeTE9IjEzMCIgeDI9IjE1MCIgeTI9IjE1MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjExMCIgeTE9IjUwIiB4Mj0iMTEwIiB5Mj0iNzAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI2MCIgeTE9IjIwIiB4Mj0iNjAiIHkyPSIxMDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiIvPjxsaW5lIHgxPSI3MCIgeTE9IjYwIiB4Mj0iNzAiIHkyPSI4MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGxpbmUgeDE9IjMwIiB5MT0iNjAiIHgyPSI3MCIgeTI9IjYwIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiLz48bGluZSB4MT0iMzAiIHkxPSIxMDAiIHgyPSI2MCIgeTI9IjEwMCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIi8+PGNpcmNsZSBjeD0iNjAiIGN5PSIxODAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGNpcmNsZSBjeD0iNzAiIGN5PSIxMzAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PGNpcmNsZSBjeD0iMTUwIiBjeT0iMTAwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjE1MCIgY3k9IjcwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxnIGNvbm5lY3RzPSIwLDIwOzMwLDA7MzAsNDAiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMnB4IiBpZD0ibSIgY2xhc3M9Im5tb3NmZXQiIGZsaXBwYWJsZT0idHJ1ZSIgdHJhbnNmb3JtPSJtYXRyaXgoLTEuODM2OTcwMjc4ODc3NzUxOGUtMTYsLTEsMSwtMS44MzY5NzAyNzg4Nzc3NTE4ZS0xNiwxMTAsMTc5Ljk5OTk5OTk5OTk5OTk3KSI+CjxtZXRhZGF0YSBjbGFzcz0icGFydCI+Cjx3dHg6cGFydCB4bWxuczp3dHg9Imh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJ0cm9uaWNzIj4KICAgIDx3dHg6cGlucz4KICAgICAgICA8d3R4OmFuYWxvZz4KPCEtLXBpbiBvcmRlciBpcyBkcmFpbiBnYXRlIHNvdXJjZSBzdWJzdHJhdGUgCnN1YnN0cmF0ZSBpcyBjb25uZWN0ZWQgdG8gc291cmNlLS0+CgkgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPm5tb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+ICA8cmVjdCB2aXNpYmlsaXR5PSJoaWRkZW4iIGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGZpbGw9Im5vbmUiIGQ9Ik0xOS44NzcsMTIuMDh6Ii8+CiAgPHRleHQgZm9udC1zaXplPSI4LjE5MDMxMjM5cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIxOC4xMTM3OTQiIHg9IjEuMDc4NjQ2MiIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkc8L3RleHQ+CiAgPHRleHQgZm9udC1zaXplPSI4LjAwMDgzMTZweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjcuNDIwODMyMiIgeD0iMzIuMDcyNzIxIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RDwvdGV4dD4KICA8dGV4dCBmb250LXNpemU9IjguMDQ4NDU3MTVweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjM5LjQxNDk3OCIgeD0iMzIuMzMzNDg3IiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+UzwvdGV4dD4KICA8cGF0aCBkPSJtMjAsMTIuOTI1LDEwLDAsMC0xMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwyNi45MjUsMTAsMCwwLDEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDE5LjkyNSwxMCwwLDAsNyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwxNi45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDIzLjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJNMjAsMTUuOTI1LDIwLDkuOTI1NSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Ik0xNyw5LjkyNTUsMTcsMjkuOTI1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTE3LDE5LjkyNS0xNywwIiBmaWxsPSJub25lIi8+CiA8cGF0aCBkPSJtMjEsMTkuOTI1LDMtMiwwLDQtMy0yeiIgZmlsbD0ibm9uZSIvPgo8L2c+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoNi4xMjMyMzM2MDExODEzNDllLTE3LDEsLTEsNi4xMjMyMzM2MDExODEzNDllLTE3LDE1MCwxMDApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgdmlzaWJpbGl0eT0iaGlkZGVuIiBmaWxsPSJub25lIi8+CiAgPHJlY3QgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PGcgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0icG1vc2ZldCIgdHJhbnNmb3JtPSJtYXRyaXgoNi4xMjMyMzM2MDExODEzNDllLTE3LDEsLTEsNi4xMjMyMzM2MDExODEzNDllLTE3LDE1MCwxOS45OTk5OTk5OTk5OTk5ODYpIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGdhdGUgZHJhaW4gc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIxIiB4PSIzMCIgeT0iMCIvPgogICAgICAgICAgICA8d3R4Om5vZGUgaW5kZXg9IjIiIHg9IjAiIHk9IjIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMyIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iNCIgeD0iMzAiIHk9IjQwIi8+CiAgICAgICAgPC93dHg6YW5hbG9nPgogICAgPC93dHg6cGlucz4KICAgIDx3dHg6aWQ+bTwvd3R4OmlkPgogICAgPHd0eDp0eXBlPm08L3d0eDp0eXBlPgogICAgPHd0eDpuYW1lPnBtb3NmZXQ8L3d0eDpuYW1lPgogICAgPHd0eDpjYXRlZ29yeT50cmFuc2lzdG9yczwvd3R4OmNhdGVnb3J5PgogICAgPHd0eDp2YWx1ZS8+CiAgICA8d3R4OmxhYmVsLz4KICAgIDx3dHg6c3BpY2UvPgogICAgPHd0eDpmbGlwPnRydWU8L3d0eDpmbGlwPgogICAgPHd0eDptb2RlbC8+Cjwvd3R4OnBhcnQ+CjwvbWV0YWRhdGE+CTxyZWN0IGhlaWdodD0iNDAiIHdpZHRoPSI0MCIgeT0iMCIgeD0iMCIgdmlzaWJpbGl0eT0iaGlkZGVuIiBmaWxsPSJub25lIi8+CiAgPHJlY3QgdmlzaWJpbGl0eT0iaGlkZGVuIiBoZWlnaHQ9IjQwIiB3aWR0aD0iNDAiIHk9IjAiIHg9IjAiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBmaWxsPSJub25lIiBkPSJNMTkuODc3LDEyLjA4eiIvPgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4xOTAzMTIzOXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMTguMTEzNzk0IiB4PSIxLjA3ODY0NjIiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5HPC90ZXh0PgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4wMDA4MzE2cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSI3LjQyMDgzMjIiIHg9IjMyLjA3MjcyMSIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPkQ8L3RleHQ+CiAgPHRleHQgZm9udC1zaXplPSI4LjA0ODQ1NzE1cHgiIGZvbnQtZmFtaWx5PSJCaXRzdHJlYW0gVmVyYSBTYW5zIiB5PSIzOS40MTQ5NzgiIHg9IjMyLjMzMzQ4NyIgc3Ryb2tlLXdpZHRoPSIwcHgiIGZvbnQtc3R5bGU9Im5vcm1hbCIgZmlsbD0iYmxhY2siPlM8L3RleHQ+CiAgPHBhdGggZD0ibTIwLDEyLjkyNSwxMCwwLDAtMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMjYuOTI1LDEwLDAsMCwxMyIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwxOS45MjUsMTAsMCwwLDciIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMTYuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0yMCwyMy45MjUsMCw2IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0iTTIwLDE1LjkyNSwyMCw5LjkyNTUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJNMTcsOS45MjU1LDE3LDI5LjkyNSIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Im0xNywxOS45MjUtMTcsMCIgZmlsbD0ibm9uZSIvPgoKICA8cGF0aCBkPSJtMjYsMTcuOTI1LDMsMi0zLDIsMC00eiIgZmlsbD0ibm9uZSIvPgoKICA8L2c+PGcgY29ubmVjdHM9IjAsMjA7MzAsMDszMCw0MCIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIycHgiIGlkPSJtIiBjbGFzcz0ibm1vc2ZldCIgZmxpcHBhYmxlPSJ0cnVlIiB0cmFuc2Zvcm09Im1hdHJpeCgtMS44MzY5NzAyNzg4Nzc3NTE4ZS0xNiwtMSwxLC0xLjgzNjk3MDI3ODg3Nzc1MThlLTE2LDExMCwxMDApIj4KPG1ldGFkYXRhIGNsYXNzPSJwYXJ0Ij4KPHd0eDpwYXJ0IHhtbG5zOnd0eD0iaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3dlYnRyb25pY3MiPgogICAgPHd0eDpwaW5zPgogICAgICAgIDx3dHg6YW5hbG9nPgo8IS0tcGluIG9yZGVyIGlzIGRyYWluIGdhdGUgc291cmNlIHN1YnN0cmF0ZSAKc3Vic3RyYXRlIGlzIGNvbm5lY3RlZCB0byBzb3VyY2UtLT4KCSAgICA8d3R4Om5vZGUgaW5kZXg9IjEiIHg9IjMwIiB5PSIwIi8+CiAgICAgICAgICAgIDx3dHg6bm9kZSBpbmRleD0iMiIgeD0iMCIgeT0iMjAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSIzIiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICAgICAgPHd0eDpub2RlIGluZGV4PSI0IiB4PSIzMCIgeT0iNDAiLz4KICAgICAgICA8L3d0eDphbmFsb2c+CiAgICA8L3d0eDpwaW5zPgogICAgPHd0eDppZD5tPC93dHg6aWQ+CiAgICA8d3R4OnR5cGU+bTwvd3R4OnR5cGU+CiAgICA8d3R4Om5hbWU+bm1vc2ZldDwvd3R4Om5hbWU+CiAgICA8d3R4OmNhdGVnb3J5PnRyYW5zaXN0b3JzPC93dHg6Y2F0ZWdvcnk+CiAgICA8d3R4OnZhbHVlLz4KICAgIDx3dHg6bGFiZWwvPgogICAgPHd0eDpzcGljZS8+CiAgICA8d3R4OmZsaXA+dHJ1ZTwvd3R4OmZsaXA+CiAgICA8d3R4Om1vZGVsLz4KPC93dHg6cGFydD4KPC9tZXRhZGF0YT4gIDxyZWN0IHZpc2liaWxpdHk9ImhpZGRlbiIgaGVpZ2h0PSI0MCIgd2lkdGg9IjQwIiB5PSIwIiB4PSIwIiBmaWxsPSJub25lIi8+CiAgPHBhdGggZmlsbD0ibm9uZSIgZD0iTTE5Ljg3NywxMi4wOHoiLz4KICA8dGV4dCBmb250LXNpemU9IjguMTkwMzEyMzlweCIgZm9udC1mYW1pbHk9IkJpdHN0cmVhbSBWZXJhIFNhbnMiIHk9IjE4LjExMzc5NCIgeD0iMS4wNzg2NDYyIiBzdHJva2Utd2lkdGg9IjBweCIgZm9udC1zdHlsZT0ibm9ybWFsIiBmaWxsPSJibGFjayI+RzwvdGV4dD4KICA8dGV4dCBmb250LXNpemU9IjguMDAwODMxNnB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iNy40MjA4MzIyIiB4PSIzMi4wNzI3MjEiIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5EPC90ZXh0PgogIDx0ZXh0IGZvbnQtc2l6ZT0iOC4wNDg0NTcxNXB4IiBmb250LWZhbWlseT0iQml0c3RyZWFtIFZlcmEgU2FucyIgeT0iMzkuNDE0OTc4IiB4PSIzMi4zMzM0ODciIHN0cm9rZS13aWR0aD0iMHB4IiBmb250LXN0eWxlPSJub3JtYWwiIGZpbGw9ImJsYWNrIj5TPC90ZXh0PgogIDxwYXRoIGQ9Im0yMCwxMi45MjUsMTAsMCwwLTEzIiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDI2LjkyNSwxMCwwLDAsMTMiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMTkuOTI1LDEwLDAsMCw3IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0ibTIwLDE2LjkyNSwwLDYiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMjAsMjMuOTI1LDAsNiIgZmlsbD0ibm9uZSIvPgogIDxwYXRoIGQ9Ik0yMCwxNS45MjUsMjAsOS45MjU1IiBmaWxsPSJub25lIi8+CiAgPHBhdGggZD0iTTE3LDkuOTI1NSwxNywyOS45MjUiIGZpbGw9Im5vbmUiLz4KICA8cGF0aCBkPSJtMTcsMTkuOTI1LTE3LDAiIGZpbGw9Im5vbmUiLz4KIDxwYXRoIGQ9Im0yMSwxOS45MjUsMy0yLDAsNC0zLTJ6IiBmaWxsPSJub25lIi8+CjwvZz48Y2lyY2xlIGN4PSI2MCIgY3k9IjEwMCIgcj0iMyIgc3Ryb2tlPSJibGFjayIgZmlsbD0iYmxhY2siLz48Y2lyY2xlIGN4PSI2MCIgY3k9IjIwIiByPSIzIiBzdHJva2U9ImJsYWNrIiBmaWxsPSJibGFjayIvPjxjaXJjbGUgY3g9IjcwIiBjeT0iNjAiIHI9IjMiIHN0cm9rZT0iYmxhY2siIGZpbGw9ImJsYWNrIi8+PHRleHQgeD0iMTcuMzM4NDM5OTQxNDA2MjUiIHk9IjEwMy4zODYwNzc4ODA4NTkzOCIgZm9udC1zaXplPSIxMiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMHB4Ij5CPC90ZXh0Pjx0ZXh0IHg9IjE3Ljk2NjM2OTYyODkwNjI1IiB5PSI2My4xOTgzMzM3NDAyMzQzNzUiIGZvbnQtc2l6ZT0iMTIiIGZpbGw9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjBweCI+QTwvdGV4dD48dGV4dCB4PSIxOTkuNjYyNDE0NTUwNzgxMjUiIHk9IjEwNC43MDY2NDk3ODAyNzM0NCIgZm9udC1zaXplPSIxMiIgZmlsbD0iYmxhY2siIHN0cm9rZS13aWR0aD0iMHB4Ij5GPC90ZXh0Pjwvc3ZnPg==">XOR gate</a></p>
<p>Basically, what happens is that <span class="math">\(A\)</span> turns on the top transmission gate and turns off the bottom transmission gate when it is low, and turns on bottom transmission gate and turns off the top transmission gate when it is high.</p>
<p>In other words, if <span class="math">\(A\)</span> is low, the output is set to <span class="math">\(B\)</span>. If <span class="math">\(A\)</span> is high, the output is set to <span class="math">\(\overline B\)</span>.</p>
<p>This is an <strong>XOR gate that only takes 8 transistors</strong>.</p>
<p>A CMOS circuit always follows a specific form: there is a pull-down network that tries to pull down the output for some inputs (NMOS circuitry), connected to ground, and a pull-up network that tries to pull up the output for all the other inputs, connected to power (PMOS circuitry).</p>
<p>The K-map for a 4-input XOR gate appears as follows:</p>
<table>
<thead>
<tr class="header">
<th align="left"><span class="math">\(x_3 x_4\)</span>$x_1 x_2$</th>
<th align="left">00</th>
<th align="left">01</th>
<th align="left">11</th>
<th align="left">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>00</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left"><strong>01</strong></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left"><strong>11</strong></td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left"><strong>10</strong></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<p>If we implemented this with AND/OR/NOT logic, this would be the largest possible 4-input combinatorial circuit we can have - the worst case scenario for a K-map, where it is not possible to optimise.</p>
<p>With XOR, we can make the resulting circuit much simpler than with a SOP. Mathematically, we are finding expressions of the form <span class="math">\(\overline a b + a \overline b\)</span>, factoring them out, and then replacing them with <span class="math">\(a \oplus b\)</span>. For example, <span class="math">\(\overline{x_1} x_2 (\overline{x_3 \odot x_4}) + (x_1 + \overline{x_2})(x_3 \oplus x_4) = \overline{x_1} x_2 (\overline{x_3 \odot x_4}) + (\overline{\overline{x_1} x_2})(x_3 \oplus x_4) = (\overline{x_1} x_2) \oplus x_3 \oplus x_4\)</span></p>
<p>The telltale sign of XOR in a circuit is the 2x2 square with 1's in the top right and bottom left corner. When this appears multiple times, there is almost certainly a way to lower costs using an XOR gate.</p>
<p>Also, when we have a wire with a slash through it, labelled <span class="math">\(n\)</span>, that wire actually represents <span class="math">\(n\)</span> parallel wires. So a wire with a slash labelled 3 as the only input to an AND gate means that the AND gate has 3 inputs.</p>
<p>A PLA/PAL/SPLD (programmable logic array/programmable array logic) is a chip that has programmable fuses that can be programmed to represent a variety of circuits. It basically has an array of AND gates and OR gates, and can make connections from any input or inverted input to any AND gate, and from any AND gate to any OR gate, with the connections being programmable. This lets us represent a variety of functions (though not all, since the number of AND gates is usually relatively limited) using just a single chip. In practice, these can help save a lot of chip space, since these days we generally build circuits with chips instead of fabricating them from raw transistors.</p>
<h1 id="section-9">23/1/15</h1>
<h2 id="decompositionfactoring">Decomposition/Factoring</h2>
<p>We have to this point basically always measured cost in terms of number of gates plus number of gate inputs. However, in practice a better cost function might be to count the number of transistors, or the number of actual chips we will need.</p>
<p>By using Boolean algebra on the two-level SOP resulting from a K-map, we turn the 2-level circuit into a 3-level circuit that is also no longer a SOP, but in the process it is possible that this might make the circuit cheaper as a whole.</p>
<p>If we are using something known as a <strong>K-LUT</strong>, we basically have a couple of <span class="math">\(k\)</span>-input blocks that can implement any <span class="math">\(k\)</span>-input functions. So a 3-lut can implement any 3-input function, and so on. These often have less inputs than the functions we need to implement.</p>
<p>When we use these, our cost function becomes the number of K-LUTs we are using. As a result, to minimise the number of K-LUTs we are using, for a function <span class="math">\(f\)</span> we want to find a function <span class="math">\(g\)</span> such that <span class="math">\(g\)</span> is an input to <span class="math">\(f\)</span> (replacing the inputs that <span class="math">\(g\)</span> has that originally went into <span class="math">\(f\)</span>) and we can split the set of inputs into those for <span class="math">\(f\)</span> and those for <span class="math">\(g\)</span>. We are basically imposing a structure onto the function in an attempt to make the function smaller, but that smaller function might not exist.</p>
<p>Suppose the split we choose for a 5-input function <span class="math">\(f = \overline d c + d \overline c b + d \overline c a + e d \overline b \overline a + e c \overline b \overline a\)</span> is <span class="math">\(e, b, a\)</span> for <span class="math">\(f\)</span> and <span class="math">\(d, c\)</span> for <span class="math">\(g\)</span>.</p>
<p>From this, we can draw a <strong>decomposition chart</strong>:</p>
<table>
<thead>
<tr class="header">
<th align="left">eba/dc</th>
<th align="left">00</th>
<th align="left">01</th>
<th align="left">10</th>
<th align="left">11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">000</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">001</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">010</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">011</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">100</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">101</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">110</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">111</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<p>Note that there are only 2 unique rows in the table. Wherever there are duplicated rows, we could possibly have a function <span class="math">\(g\)</span> that selects which unique row is being used to possibly simplify the logic. In our case, we will let <span class="math">\(g\)</span> be a function that returns 1 when the row is 0110 and 0 when the row is 1101. Clearly, this is <span class="math">\(g = e + b + q\)</span>.</p>
<p>Now, the function depends only on <span class="math">\(g\)</span> and <span class="math">\(d, c\)</span>. We can now draw a K-map:</p>
<table>
<thead>
<tr class="header">
<th align="left">g/dc</th>
<th align="left">00</th>
<th align="left">01</th>
<th align="left">11</th>
<th align="left">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>The new minimized function is now <span class="math">\(f = \overline g \overline d + \overline g c + \overline d c + g d \overline c\)</span>. We could also try to further minimise it using an XOR or similar. Clearly, <span class="math">\(g\)</span> and <span class="math">\(f\)</span> both have 3 inputs each, so we can implement it with just 2 3-LUTs, which is the minimum possible amount since a 5-input function cannot be implemented with just 1 3-LUT.</p>
<p>How did we choose the split that resulted in this structure? Mostly by brute force with some heuristics. There are <span class="math">\(\sum_{i = 1}^{m - 1} {n \choose i}\)</span> where <span class="math">\(n\)</span> is the number of inputs and <span class="math">\(m\)</span> is the number of inputs on our K-LUTs. Basically, there is no simple way to determine what split of variables to use, so we just need to try promising candidates.</p>
<p>This technique is a way to find a common subfunction of a function in order to reduce the number of inputs.</p>
<p>The idea is that the cheapest function possible will depend on the cost function, which depends on the technology that we are using. Different functions will be cheaper for CMOS vs. K-LUTs vs. logic gates, and so on.</p>
<h1 id="section-10">26/1/15</h1>
<p>;wip: get the notes for this class, missed due to sick</p>
<p>;wip: apparently we talked about representing numbers in different bases, like the week 4 content</p>
<p>;wip: <span class="math">\(r\)</span>'s complement and all that</p>
<h1 id="section-11">27/1/15</h1>
<h2 id="addition">Addition</h2>
<p>The <strong>half adder</strong> (HA) is a circuit that can add two one-bit numbers. It is represented by <span class="math">\(S, C_{out} = x \oplus y, x \wedge y\)</span>.</p>
<p>In order to fully add two numbers of any size, we need to be able to add two 1-bit numbers, plus a carry in - basically, add three 1-bit numbers.</p>
<p>We can do this with two half adders - a <strong>full adder</strong> (FA): <span class="math">\(S, C_{out} = x \oplus y \oplus C_{in}, x \wedge y + C_{in}(x \oplus y)\)</span>. Basically, we connect the output of the half adder adding <span class="math">\(x\)</span> and <span class="math">\(y\)</span> to the input of a half adder that adds the carry in. The resulting carry out is the carry out of each half adder OR'd together. The full adder is an example of <strong>heirarchichal design</strong>.</p>
<p>This is only one representation - there are multiple ways to make full adders, including 2-level repesentations like <span class="math">\(S, C_{out} = x \oplus y \oplus C_{in}, x \wedge C_{in} + y \wedge C_{in} + x \wedge y\)</span>, since <span class="math">\(x \wedge C_{in} + y \wedge C_{in} + x \wedgey = C_{in} (x + y) + xy = C_{in} (x \oplus y) + x \wedge y\)</span>.</p>
<p>With this, we can chain them together to add <span class="math">\(n\)</span>-bit numbers, by connecting the <span class="math">\(C_{out}\)</span> of one full adder to the <span class="math">\(C_{in}\)</span> of the next, and corresponding bits of the addends for inputs to each full adder. This is called an <span class="math">\(n\)</span>-bit <strong>ripple adder</strong>, because the carry-outs ripple through the circuit from the least significant bit to the most. This takes <span class="math">\(5n\)</span> (<span class="math">\(5(n - 1) + 2\)</span> if using half adder for first bits) gates, which is pretty much the smallest possible.</p>
<p>Adding two <span class="math">\(n\)</span>-bit numbers requires <span class="math">\(n\)</span> adders (technically, <span class="math">\(n - 1\)</span> full adders and 1 half-adder for the least significant bit, or <span class="math">\(n\)</span> full adders with the least significant bit's carry in connected to 0). Using a full adder for the least significant bit allows us to easily add 1 at any time, which is useful for certain things like subtraction.</p>
<p>When we add two <span class="math">\(n\)</span>-bit numbers, we know that the output is potentially <span class="math">\(n + 1\)</span>-bits. In our circuits, this manifests as the carry out of the last full adder. The sum actually overflows after <span class="math">\(2^n - 1\)</span> back to 0 for unsigned numbers, and after <span class="math">\(2^{n - 1} - 1\)</span> back to <span class="math">\(-2^{n - 1}\)</span> for signed numbers.</p>
<p>Every time we change the input to a gate, we need to wait 1 time unit before we read the result in order to make sure that it is stable. This is the gate's <strong>propagation delay</strong>.</p>
<p>The <strong>longest combinational path/critical path</strong> is the longest path of logic gates and other combinational components through the circuit from one input to one output, and determines how long we need to wait before the output is stable and we can read it expecting valid results. We can represent this by drawing the full adder circuit as a box with arrows inside from each input to every output, each labelled with the longest combinational path from that input to that output. For example, the critical path from carry in to carry out is 2 for a full adder.</p>
<p>The ripple gate is relativey slow. Note that the last sum's output depends on every input before it - as the number of bits increases, the longest combinational path of gates through the circuit gets proportionally longer. As a result, as <span class="math">\(n\)</span> increases, the amount of time we need to wait before the output of the ripple adder finally stabilizes also increases as <span class="math">\(2n - 1\)</span> gate delays.</p>
<h1 id="section-12">28/1/15</h1>
<p>;wip: quiz this coming wednesday Feb 4 9:30am-10:20am at MC1085 (last name A-Mar) EV3-1408 (last name Mc-Z), if there is interview conflict alternate timeslot is 5:30pm-6:20pm at EIT3145, provide proof, 3 questions with equal weight</p>
<p>There is no such thing as a subtractor - while adding was easy because carrying always went leftward, borrowing might need us to move an arbitrary amount of spaces left. Instead, we simply add the negation of the number using the <span class="math">\(r\)</span>'s complement: <span class="math">\(M + (r^n - N) = r^n + (M - N)\)</span>. Note the presence of the <span class="math">\(r^n\)</span> term, which simply represents the carry/borrow bit past the most significant bit of the number.</p>
<p>If we represent signed integers using two's complement, we don't need to do anything at all to the answer - just add <span class="math">\(M\)</span> to the two's complement of <span class="math">\(N\)</span>. When we do this, the carry/borrow bit is 1 if <span class="math">\(M \ge N\)</span> and 0 otherwise.</p>
<p>Since the two's complement is equivalent to a bitwise NOT followed by addition of 1, we can very quickly find the two's complement of any number. In a ripple adder, if we use a full adder in the least significant bit of the adder, we can very easily add the two's complement for an operand by inverting its bit inputs, and setting the carry in of the full adder to 1 in the least significant bit.</p>
<p>So to make a subtractor, we simply add a control line input to the adder that we XOR with every bit of the second addend and is connected to the carry in of the full adder for the least significant bit. When this is off, the bits of the second addend are XOR'd with 0 (which does nothing) and the carry in is 0 as before - this is addition, as before. When this is on, the bits of the second addend are XOR'd with 1 (inverting them) and the carry in is 1, adding 1 to the sum - this results in subtraction.</p>
<h1 id="section-13">30/1/15</h1>
<p>;wip: missed first half of this due to interview</p>
<p>Signed arithmetic we will represent using two's complement. See CS241 notes for reference.</p>
<p>For signed numbers, addition overflows if and only if the carry in and carry out of the full adder for the most significant bit are different. In order to detect overflows in hardware, we simply add an XOR gate connected to the carry in and carry out of the last full adder.</p>
<p>The ripple adder is small and simple, but slow. We want to make a better adder. There is a design that uses quadratic space, but can add in constant time with respect to the number of bits - the <strong>carry-lookahead adder</strong> (CLA).</p>
<p>Consider the carry line of the ripple adder. As we go left, we have more and more gates in the critical path. However, each carry-out is theoretically a function of each of the inputs of the previous gates. If we write a truth table and minimise, we can get a two-level circuit for any of the carry-outs.</p>
<h1 id="section-14">2/2/15</h1>
<p>The basic idea is that we can compute the carry in of each adder independently without having to wait for it to propagate through all the previous adders. Since it is always possible to write any boolean function as a 2-level SOP or POS, we know that this is possible.</p>
<p>Consider an <span class="math">\(n\)</span>-bit ripple adder. Let <span class="math">\(p_i\)</span> (propagate) and <span class="math">\(g_i\)</span> (generate) be the sum and carry from the first half adder (the one with the non-carry inputs) in the <span class="math">\(i\)</span>th full adder. Let <span class="math">\(c_i\)</span> be the carry-in of the <span class="math">\(n\)</span>th full adder.</p>
<p>Clearly, <span class="math">\(c_1 = g_0 + p_0 c_0\)</span>, <span class="math">\(c_2 = g_1 + p_1 c_1 = g_1 + p_1 g_0 + p_1 g_0 c_0\)</span>, and <span class="math">\(c_3 = g_2 + p_2 c_2 = g_2 + p_2 g_1 + p_2 p_1 g_0 + p_2 p_1 p_0 c_0s\)</span>.</p>
<p>Since every <span class="math">\(c_i\)</span> is in terms of only <span class="math">\(x\)</span> and <span class="math">\(y\)</span>, we can compute all of them in parallel, using a SOP for each carry in. That means that no matter how big the adder is, we can just use 2-level circuits to get the carries, and we can get the sum after just 4 gate delays.</p>
<p>The tradeoff of the carry-lookahead adder is that its area increases quadratically with the number of bits - each successive carry-in expression has one more term than the previous.</p>
<p>In practice, the carry-lookahead adder is a little bit too bulky in terms of area. We can combine the CLA and ripple adding concepts together in a hybrid design to get the best of both worlds - a reasonably compact, fast adder.</p>
<p>For example, for a 16-bit number, we might have 4 carry-lookahead adders with their carry-ins and carry-outs chained together like a ripple adder. This would have much less of a delay than a ripple adder, but also have a much smaller area than an equivalent carry-lookahead adder.</p>
<h2 id="common-logical-operations">Common Logical Operations</h2>
<p>A very common operation is to compare two unsigned numbers. We want a circuit that, given <span class="math">\(n\)</span>-bit numbers <span class="math">\(A = a_n \cdots a_1, B = b_n \cdots b_1\)</span>, outputs whether the numbers are equal, or whether one is greater than another.</p>
<p>Potentially, we could just subtract the two numbers and compare the sign of the result. However, this is a bit excessive - subtraction is a much more complex operation than we actually need for this purpose.</p>
<p>Equality is easy - two numbers are equal if all their bits are the same. We can just XNOR corresponding bits together and AND those results all together.</p>
<p>Comparison is also simple - we first compare the most significant bit, and if they are equal, we compare the second most, and so on. Mathematically, <span class="math">\(A &gt; B \equiv a_n \overline{b_n} + e_{n - 1} a_{n - 1} \overline{b_{n - 1}} + e_{n - 1} e_{n - 2} a_{n - 2} \overline{b_{n - 2}} + \ldots + e_{n - 1} \cdots e_1 a_1 \overline{b_1}\)</span>, where <span class="math">\(e_i = \overline{a_{i + 1} \overline{b_{i + 1}}}\)</span> - whether the lower bit is enabled by the bit one higher than it. <span class="math">\(A &lt; B\)</span> can be calculated in a similar way, or by using the fact that <span class="math">\(A &lt; B \equiv \overline{A &gt; B \vee A = B}\)</span>.</p>
<p>This is analogous to a carry-lookahead adder - we are making decisions for each output bit based on all the bits of the inputs that correspond to or come before it, and it has a constant height with respect to the number of bits. We could also implement this as something like a ripple adder by writing the expression as <span class="math">\(A &gt; B \equiv a_n \overline{b_n} + e_{n - 1} (a_{n - 1} \overline{b_{n - 1}} + e_{n - 2} (a_{n - 2} \overline{b_{n - 2}} + \ldots + e_1 a_1 \overline{b_1}) \ldots ))\)</span>.</p>
<h1 id="section-15">4/2/15</h1>
<p>Got #rekt by the quiz.</p>
<h1 id="section-16">6/2/15</h1>
<p>An <span class="math">\(n\)</span> bit number has <span class="math">\(2^n\)</span> possible distinct values. Figuring out what each pattern represents is known as <strong>decoding</strong>. An <span class="math">\(n\)</span> to <span class="math">\(m\)</span> <strong>decoder</strong> is a device that recognizes <span class="math">\(n\)</span>-bit patterns and outputs <span class="math">\(m\)</span>-bit patterns in response.</p>
<p>Basically, a decoder has <span class="math">\(m\)</span> separate functions of those <span class="math">\(n\)</span> input bits that are 1 for certain minterms of <span class="math">\(n\)</span>. A decoder generally also has an enable line - the decoder functions as described when this is 1, and the output is always 0 when this is 0.</p>
<p>An example of a decoder is a 7-segment hex decoder, which accepts a 4-bit unsigned binary number and outputs the 7-bit values for the hex digits on the display. A selector is also a decoder - it has one output for each input number, and turns one on for each recognized number.</p>
<p>In this course, after this point when we say decoder we refer to a selector - a device with <span class="math">\(n\)</span> inputs and <span class="math">\(2^n\)</span> outputs (or fewer, if the input cannot reach certain states). One of the <span class="math">\(2^n\)</span> outputs is on for each of the <span class="math">\(2^n\)</span> possible distinct values for the <span class="math">\(n\)</span>-bit input - there is exactly one output (distinct) that is 1 for each minterm. This circuit can be made with just NOT and AND gates.</p>
<p>Smaller decoders can be used together to make bigger decoders in decoder trees, in a tree-like structure. Some of the bits would be decoded and used to select the right second stage decoder to use, which then decodes the rest of the bits, or enables even more stages. Decoders can also implement functions, by ORing together multiple minterm outputs.</p>
<p>An <span class="math">\(m\)</span> to <span class="math">\(n\)</span> <strong>encoder</strong> is the counterpart to an <span class="math">\(n\)</span> to <span class="math">\(m\)</span> decoder. An encoder has <span class="math">\(2^n\)</span> or fewer inputs and <span class="math">\(n\)</span> outputs. The output is always a binary code corresponding to which input line is on (1 and only 1 input may be on at a time). This circuit can be made with just OR gates.</p>
<p>A <strong>priority encoder</strong> is an encoder that does allow multiple input lines to be on at the same time, and even none at all. The output is always the binary code corresponding the highest-indexed input that is on. There is also an output that is on if and only if at least one of the inputs are on. THis circuit can be implemented using only OR gates.</p>
<p>An <span class="math">\(n\)</span>-bit <strong>multiplexer</strong> (MUX) is a device that has <span class="math">\(2^n\)</span> or fewer inputs (of equal size) based on an <span class="math">\(n\)</span>-bit selection input, and outputs one of the inputs based on the value of the selection input. For example, a 1-bit multiplexer outputs the first input if the selection input is 0, and the second input if the selection input is 1. Multiplexers can easily be implemented using tri-state buffers.</p>
<p>A 2-input multiplexer can therefore simply be written as <span class="math">\(\overline s x_1 + s x_2\)</span>. A 4-input multiplexer can be written as <span class="math">\(\overline{s_1} \overline{s_2} x_1 + \overline s_1 s_2 x_2 + s_1 \overline s_2 x_3 + s_1 s_2 x_4\)</span>. Larger multiplexers can also be built up from smaller multiplexers, in a tree structure.</p>
<p>Any <span class="math">\(n\)</span>-input function can be implemented using an <span class="math">\(n-1\)</span>-bit multiplexer by looking at the truth table. This is done by using the first <span class="math">\(n - 1\)</span> bits of the input into the multiplexer as the select lines, and the last bit as an input as one of <span class="math">\(x, \overline x, 0, 1\)</span>.</p>
<p><strong>Shannon decomposition</strong> is the process of decomposing functions for implementation using multiplexers. We can implement logic gates using just small multiplexers, so we can also implement functions using just small multiplexers.</p>
<p>Given any function <span class="math">\(f(x_0, \ldots, x_n)\)</span>, we can always factor it into two functions <span class="math">\(\overline{x_0} f(0, x_1, \ldots, x_2) + x_0 f(1, x_1, \ldots, x_n)\)</span>. Note that these two functions (known as the <strong>cofactors</strong>) are now <span class="math">\(n - 1\)</span> input functions, and that they are the inputs to a 1-bit multiplexer. By applying this repeatedly we can implement the entire function using just 2-bit multiplexers.</p>
<p>A <strong>demultiplexer</strong> is the counterpart of the multiplexer. It is exactly the same thing as a decoder/selector, but with the meanings of the pins changed 0- the enable line is actually the data input, and the data inputs are actually the select lines. The demultiplexer sets the output selected by the select lines to the value of the data inputs. The data input can also be multiple bits, unlike a decoder.</p>
<p>Tri-state buffers are very useful for making bus-like circuits (a bus is just a bundle of wires that carry data around), when we want to drive a wire from different sources at different times (for example, the data bus on a computer). We can have all the outputs of the tri-state buffer feed into the same wire, and if we ensure that only one enable bit is on at a time, the wire will only be driven by one source at a time.</p>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2014 Anthony Zhang.
</div>
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>