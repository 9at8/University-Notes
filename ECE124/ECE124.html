<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>ECE124 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso.light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>
function highlight() { // highlight all code blocks using HighlightJS
  var code_blocks = document.getElementsByTagName("code");
  for (var i = 0; i < code_blocks.length; i++)
    hljs.highlightBlock(code_blocks[i]);
}
</script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body onload="highlight()">
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/Résumé.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="http://www.linkedin.com/pub/anthony-zhang/8b/aa5/7aa" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.mesecons.net/">mesecons</a></li>
    <span class="divider"></span>
    <li><a href="http://www.autohotkey.net/~Uberi/">autohotkey.net</a></li>
  </ul>
<h1 id="ece124">ECE124</h1>
<p>Digital circuits and systems.</p>
<pre><code>Instructor: Andrew Kennings
Website: http://sifaka.uwaterloo.ca/~akenning/courses/ece124/</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}_P)}
\]</span></p>
<h1 id="section">5/1/15</h1>
<p>The assignments and other course resources can be found on the course website. They will not be posted to LEARN.</p>
<h2 id="boolean-algebra">Boolean Algebra</h2>
<p>See the CS245 notes for description of Boolean algebra.</p>
<p>Binary functions are defined using a truth table, or a Boolean logic formula. An example of a binary function is <span class="math">\(f = f(x, y)\)</span>. Problem with truth tables is that they're big, and hard to manipulate.</p>
<p>Boolean AND is represented with <span class="math">\(x \cdot y\)</span>, <span class="math">\(xy\)</span>, or <span class="math">\(x \wedge y\)</span>. The schematic symbol for this operation is a rectangle with one side completely rounded into a semicircle with the output wire, and the other flat and with input wires.</p>
<p>Boolean OR is represented with <span class="math">\(x + y\)</span>. The schematic symbol for this operation is a rectangle with one side completely rounded into a semicircle with the output wire, with the other side curved inward and has input wires leading into it.</p>
<p>Boolean NOT is represented with <span class="math">\(\overline x\)</span>, <span class="math">\(!x\)</span>, <span class="math">\(x&#39;\)</span>, or <span class="math">\(\neg x\)</span>. The schematic symbol for this operation is a triangle with a circle on the pointed end, which has the output wire, and the input wire is on the other end.</p>
<p>There is also an order of operations for these operations. From highest precedence to lowest, the operators are NOT, AND, and OR.</p>
<h1 id="section-1">7/1/15</h1>
<h2 id="mintermsmaxterms">Minterms/Maxterms</h2>
<p>A <strong>minterm</strong> is a particular Boolean expression for a particular input to an <span class="math">\(n\)</span>-input function. The minterm is special because it is easy to construct algorithmically from a truth table.</p>
<p>The minterm <span class="math">\(m_i\)</span> of a truth table's row <span class="math">\(i\)</span> is the an OR expression with an operand for each function input where each operand is <span class="math">\(x_i\)</span> if <span class="math">\(x_i = 1\)</span> for that row and <span class="math">\(\neg x_i\)</span> if <span class="math">\(x_i = 0\)</span>.</p>
<p>Given a truth table, we can construct an expression that is equivalent to the function it represents as follows:</p>
<ol style="list-style-type: decimal">
<li>Create an empty expression <span class="math">\(m\)</span>.</li>
<li>For each row <span class="math">\(x_0, \ldots, x_n, f\)</span> in the truth table:</li>
<li>Create an empty expression <span class="math">\(m_i\)</span>.</li>
<li>For all <span class="math">\(1 \le i \le n\)</span>:
<ol style="list-style-type: decimal">
<li>If <span class="math">\(x_i = 0\)</span>, let <span class="math">\(m_i\)</span> become <span class="math">\(m_i \cdot \neg x_i\)</span>.</li>
<li>If <span class="math">\(x_i = 1\)</span>, let <span class="math">\(m_i\)</span> become <span class="math">\(m_i \cdot x_i\)</span>.</li>
</ol></li>
<li>If and only if <span class="math">\(f = 1\)</span>, let <span class="math">\(m\)</span> become <span class="math">\(m \vee m_i\)</span>. Note that <span class="math">\(m_i\)</span> is true if and only if the inputs match those in the current row of the truth table.</li>
<li>Note that <span class="math">\(m\)</span> is true if and only if <span class="math">\(f = 1\)</span>, since there is an <span class="math">\(m_i\)</span> term for all the rows in the truth table that are true, and none of them match any rows in the truth table that are not true.</li>
</ol>
<p>Here, each <span class="math">\(m_i\)</span> is a minterm. <span class="math">\(m\)</span> is the sum of minterms/canonical sum of products, defined below.</p>
<p>The <strong>canonical sum of products/sum of minterms</strong> is when we OR all the minterms (<span class="math">\(m_i\)</span>) that have <span class="math">\(f = 1\)</span> for their corresponding truth table rows, in order.</p>
<p>The <strong>maxterms</strong> of a function are the duals of the minterms - similar to the minterms, but with AND instead of OR, and <span class="math">\(\neg x\)</span> and <span class="math">\(x\)</span> where we used to have <span class="math">\(x\)</span> and <span class="math">\(\neg x\)</span>.</p>
<p>The maxterm <span class="math">\(M_i\)</span> of a truth table's row <span class="math">\(i\)</span> is the an OR expression with an operand for each function input where each operand is <span class="math">\(x_i\)</span> if <span class="math">\(x_i = 1\)</span> for that row and <span class="math">\(\neg x_i\)</span> if <span class="math">\(x_i = 0\)</span>.</p>
<p>The maxterm is true if and only if the inputs <em>do not match the inputs in the corresponding row in the truth table</em>. This is the opposite of a minterm being true if and only if the inputs do match the inputs.</p>
<p>The <strong>canonical product of sums/product of maxterms</strong> is when we AND all the maxterms that have <span class="math">\(f = 0\)</span> for their corresponding truth table rows, in order. In other words, it is an expression that ensures that the inputs do not match the first row resulting in 0, and do not match the second row resulting in 0, and so on.</p>
<p>The sum of minterms and product of maxterms are special because it is exactly equivalent to the original function. The term <strong>canonical</strong> means that they are unique - there is only one way to write it correctly.</p>
<p>Minterms determine when we need to turn the function on. Maxterms determine when we need to turn the function off.</p>
<p>A <span class="math">\(n\)</span>-level expression is an expression that has a maximum tree depth of <span class="math">\(n\)</span>. <span class="math">\(xy + z\)</span> is a 2-level expression, and when we draw the circuit, it has 2 levels of gates - the depth of the circuit tree. The level of a circuit is the length of the longest path from a circuit input to an output.</p>
<p>For example, if a 2-input function has the following truth table:</p>
<table>
<thead>
<tr class="header">
<th align="left">x</th>
<th align="left">y</th>
<th align="left">f</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">0</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>The minterms are <span class="math">\(\neg x \neg y\)</span> and <span class="math">\(x y\)</span>, and the maxterms are <span class="math">\(x \neg y\)</span> and <span class="math">\(\neg x y\)</span>. As a result, we can write <span class="math">\(f\)</span> as <span class="math">\(\neg x \neg y + x y\)</span> (sum of minterms) or <span class="math">\((x + \neg y)(\neg x + y)\)</span> (product of maxterms).</p>
<p>Our goal is to use the simplest possible circuits. We can choose whether to use the sum of minterms or product of maxterms, but we can also use Boolean algebra to further simplify any expression.</p>
<h2 id="boolean-algebra-1">Boolean Algebra</h2>
<p>Axioms of Boolean algebra:</p>
<ol style="list-style-type: decimal">
<li>Closure over operations: given <span class="math">\(x, y \in \set{0, 1}\)</span>, <span class="math">\(x \cdot y, x + y, \neg x \in \set{0, 1}\)</span>.</li>
<li>Operation identities: given <span class="math">\(x \in \set{0, 1}\)</span>, <span class="math">\(x + 0 = x\)</span> and <span class="math">\(x \cdot 1 = x\)</span>. <span class="math">\(0\)</span> is the OR identity and <span class="math">\(1\)</span> is the AND identity.</li>
<li>Commutativity: given <span class="math">\(x, y \in \set{0, 1}\)</span>, <span class="math">\(x + y = y + x\)</span> and <span class="math">\(x \cdot y = y \cdot x\)</span>.</li>
<li>Distributivity: <span class="math">\(x + y \cdot z = (x + y) \cdot (x + z)\)</span> (distributivity over OR) and <span class="math">\(x \cdot (y + z) = x \cdot y + x \cdot z\)</span>.</li>
<li>Negation existance: given <span class="math">\(x \in \set{0, 1}\)</span>, there must exist an element <span class="math">\(\neg x\)</span> such that <span class="math">\(x + \neg x = 1\)</span> and <span class="math">\(x \cdot \neg x = 0\)</span>.</li>
<li>Unique elements: there must exist <span class="math">\(x, y \in \set{0, 1}\)</span> such that <span class="math">\(x \ne y\)</span>.</li>
</ol>
<p>We can now prove theorems using truth tables, or using axioms:</p>
<p>Additional theorems:</p>
<ol style="list-style-type: decimal">
<li><span class="math">\(x + x = x\)</span> and <span class="math">\(x \cdot x = x\)</span></li>
<li><span class="math">\(x + 1 = 1\)</span> and <span class="math">\(x \cdot 0 = 0\)</span></li>
<li><span class="math">\(\neg \neg x = x\)</span> (double negation)</li>
<li><span class="math">\(x + (y + z) = (x + y) + z\)</span> and <span class="math">\(x \cdot (y \cdot z) = (x \cdot y) \cdot z\)</span> (associativity)</li>
<li><span class="math">\(\neg (x + y) = \neg x \cdot \neg y\)</span> and <span class="math">\(\neg (x \cdot y) = \neg x + \neg y\)</span> (De Morgan's Law)</li>
<li><span class="math">\(x + x \cdot y = x\)</span> and <span class="math">\(x \cdot (x + y) = x\)</span> (adsorption)</li>
</ol>
<h1 id="section-2">9/1/15</h1>
<p>Simplify <span class="math">\(\overline{\overline{cd} + a} + a + cd + ab\)</span>:</p>
<blockquote>
<p><span class="math">\[
\begin{align*}
\overline{\overline{cd} + a} + a + cd + ab &amp;= \overline{\overline{c}}d\overline{a} + a + cd + ab = cd\overline{a} + a + cd + ab \\
&amp;= cd(\overline{a} + 1) + a + ab = cd + a + ab = cd + a(1 + b) = cd + a
\end{align*}
\]</span><br />Note that this is still a <strong>sum of products</strong> (SOP), although it isn't necessarily unique. A product of sums (POS) is what we would get if we worked with maxterms. A sum of products is always a 2-level circuit.</p>
</blockquote>
<p>We can use Boolean algebra to convert the sum of minterms or product of maxterms into a simplified expression. This allows us to convert a truth table into a sinple Boolean expression.</p>
<p>We can also represent a sum of minterms like <span class="math">\(m_{a_1} + \ldots + m_{a_n}\)</span> using the shorthand notation <span class="math">\(\sum(a_1, \ldots, a_n)\)</span>. For example, <span class="math">\(f = m_3 + m_5 + m_6 + m_7\)</span> can also be written as <span class="math">\(\sum(3, 5, 6, 7)\)</span>.</p>
<p>Likewise, maxterms have a shorthand as well: <span class="math">\(M_{a_1} + \ldots + M_{a_n}\)</span> can be written as <span class="math">\(\prod(a_1, \ldots, a_n)\)</span>.</p>
<p>Each logical operation has a physical cost when we build the circuit in real life. For us, each gate costs 1 unit, each gate input costs 1 unit, and the inverters at inputs are free. For example, <span class="math">\(xy + yz\)</span> has a 2-input OR, and two 2-input ANDs, so it has a cost of <span class="math">\((1 + 2) + 2 \cdot (1 + 2) = 9\)</span>.</p>
<p>To convert between a sum of products and a product of sums, invert it twice and apply De Morgan's laws. For example, let <span class="math">\(f = \sum(1, 4, 7)\)</span>:</p>
<blockquote>
<p>Clearly, <span class="math">\(f = m_1 + m_4 + m_7 = \overline{\overline{f}}\)</span>.<br />Clearly, <span class="math">\(\overline{f} = m_0 + m_2 + m_3 + m_5 + m_6\)</span>, the minterms that are not part of the function.<br />So <span class="math">\(f = \overline{m_0 + m_2 + m_3 + m_5 + m_6} = \overline{m_0}\overline{m_2}\overline{m_3}\overline{m_5}\overline{m_6}\)</span>, by De Morgan's laws.<br />Note that <span class="math">\(\overline{m_i} = M_i\)</span> - a maxterm is the negation of its corresponding minterm.<br />So <span class="math">\(f = \overline{m_0}\overline{m_2}\overline{m_3}\overline{m_5}\overline{m_6} = M_0 M_2 M_3 M_5 M_6\)</span>, a product of sums, as required.</p>
</blockquote>
<h1 id="section-3">12/1/15</h1>
<h2 id="other-logic-gates">Other Logic Gates</h2>
<p>The NAND gate is an AND gate with an inverted output, written <span class="math">\(x \uparrow y\)</span>. The NOR gate is an OR gate with an inverted output, written <span class="math">\(x \downarrow y\)</span>.</p>
<p>When we invert an input or an output, we can just put a hollow small bubble/circle inline with the wire, conventionally touching the gate.</p>
<p>Note that NAND and NOR are not associative, so two NAND/NOR gates chained together is different from a three-input NAND/NOR gate.</p>
<p>These gates are extremely useful for circuits built using technology such as CMOS. In CMOS, the cheapest construct is the NAND gate, so we tend to make other constructs in terms of NAND gates.</p>
<p>However, we generally want to work with normal gates like AND and OR, and convert it into NAND at the end. Since NAND and NOR are universal, any combinatorial circuit can be represented using just one of these gates.</p>
<p>To convert sums of products into NAND logic, simply negate the whole thing twice and apply De Morgan's law. For example, <span class="math">\(f = a \overline b + \overline b + c = \overline{\overline f} = \overline{\overline{a \overline b} \overline{\overline a b} \overline c}\)</span>, and the final result is all NAND gates. This can also be done recursively on subexpressions. This also works for converting products of sums into NOR logic.</p>
<p>Alternatively, we can also just replace each individual gate with its NAND equivalent. For reference, <span class="math">\(x + y = (x \uparrow x) \uparrow (y \uparrow y)\)</span>, <span class="math">\(xy = (x \uparrow y) \uparrow (x \uparrow y)\)</span>, and <span class="math">\(\overline x = x \uparrow x\)</span>.</p>
<p>This also works graphically. In a circuit schematic, simply insert two back-to-back inverters inline to wires, until it is possible to see NAND forms. By moving one of a pair of inserted inverters into the output for an AND gate, for example, we can replace the AND and NOT with a NAND gate.</p>
<p>Essentially, we first insert pairs of inverters until all gates have been converted into NAND, then remove any remaining back-to-back inverters (since they cancel each other out) and replace any remaining single inverters with their NAND forms.</p>
<h1 id="section-4">13/1/15</h1>
<p>Boolean XOR is represented with <span class="math">\(x \oplus y\)</span>. The schematic symbol for this operation is an OR gate, but with the concave side having two lines.</p>
<p>Boolean XOR essentially is true if and only if there are an odd number of operands that are true. For two inputs this is useful as an inequality operator <span class="math">\(\ne\)</span>.</p>
<p><span class="math">\(x \oplus y = \overline x y + x \overline y\)</span>. This pattern appears quite often in practical Boolean algebra, and so using XOR can often simplify formulas quite a bit. Plus, in technologies like CMOS, XOR can be implemented significantly cheaper than its long, SOP form, so we can save on cost too by using this.</p>
<p>Boolean NXOR (also known as XNOR) is simply XOR inverted. For two inputs this is useful as an equality operator <span class="math">\(=\)</span>.</p>
<p>A <strong>buffer</strong> is a special identity gate, <span class="math">\(f = x\)</span>, which has the same output as it does input. It has the same symbol as the inverter, but without the circle at the output.</p>
<p>This is useful for amplifying signals and supplying current when there are a lot of branches. Additionally, it can act as a diode (in 3-level logic) when placed in a real circuit. Plus, sometimes we use it for slowing down a signal slightly to improve timing synchronocity. Mathematically, it does not serve any purpose.</p>
<p>A tri-state buffer is similar, but has another input called Enable coming out of one side. When the Enable wire is high, the output is the same as the input. When enable is low, the output is disconnected from the input - the value of the output is not specified.</p>
<p>Tri-state buffers are useful if we want to connect multiple sources to the same destination. For example, in RAM we might have one per RAM cell, and selectively connect and disconnect the RAM cell such that only one cell is actually connected to the destination at a given time. This is important, since if we have two RAM cells connected at the same time, one with 0's and one with 1's, there would be a short circuit.</p>
<h2 id="karnaugh-maps">Karnaugh Maps</h2>
<p>Karnaugh maps (K-maps) are a way of describing Boolean functions with around 5 or less inputs (for larger inputs, it becomes impractical, as the number of table cells grows with <span class="math">\(2^n\)</span>).</p>
<p>K-maps are also useful because they can be used to minimise functions by graphically performing Boolean algebra.</p>
<p>Consider K-map for the function <span class="math">\(f = \overline x \overline y + \overine x y + x y\)</span>:</p>
<table>
<thead>
<tr class="header">
<th align="left"><span class="math">\(y\)</span>$x$</th>
<th align="left">0</th>
<th align="left">1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>0</strong></td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left"><strong>1</strong></td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<p>Note that each normal box (rectangle) corresponds to a row in the truth table for the function, and each 1 in a normal box corresponds to a minterm.</p>
<p>Note that the bottom two are both 1. That means that the value of <span class="math">\(x\)</span> does not influence the bottom row, so we can draw a rectangle around the bottom two, which represents <span class="math">\(y\)</span>.</p>
<p>Note that we can do the same for the leftmost row of two 1's, a rectangle around the two representing <span class="math">\(\overline x\)</span>.</p>
<p>If we want to minimise a function, the goal of K-mapping is to find the smallest possible number of the largest possible rectangles that cover all the 1 boxes and do not cover any 0 boxes (floating boxes don't matter). In each step, we try to draw a rectangle that encloses as many 1's as possible without enclosing any 0's.</p>
<p>This implies that there may be multiple optimal minimal versions of the function, with the same cost. This is represented by multiple minimal rectangle possibilities in the table, or multiple factoring possibilities in the Boolean expression</p>
<p>All rectangles must have side lengths that are powers of 2.</p>
<p>Mathematically, when we draw a rectangle we are duplicating a term and then factoring an input out. The boxes we drew above corresponded to the operations <span class="math">\(f = \overline x \overline y + \overline x y + xy = \overline x \overline y + \overline x y + xy + \overline x y = \overline x(\overline y + y) + y(x + \overline x) = \overline x + y\)</span>.</p>
<p>Basically, every rectangle duplicates and factors two terms, repeatedly for larger rectangles. This is the reason rectangles need to have dimensions that are powers of 2. Larger rectangles result in products with fewer factors. Fewer rectangles result in fewer products.</p>
<p>The above technique resulted in a sum of products. To get a product of sums, draw maximum rectangles that cover all 0's but no 1's. Rather than a product, each rectangle has a corresponding sum, made up of the inputs that actually matter in making the function 0. The minimized product of sums is simply the product of the sum associated with each rectangle.</p>
<p>Also, the sides are labelled using grey code, and the rectangles can wrap around the sides of the table.</p>
<h1 id="section-5">14/1/15</h1>
<p>When doing K-maps, we can read off the answer from the rectangles by looking at which variables did not change within the minterms in a given rectangle. If all the minterms in a rectangle have <span class="math">\(x_1\)</span> equal to 0, but all other variables may change, then the rectangle represents the term <span class="math">\(\overline x_1\)</span>.</p>
<p>If we look at the table and see that no rectangles can be expanded, that means that in the Boolean expression, there is no more factoring or collapsing left to be done.</p>
<p>For K-maps of larger dimensions, we label the rows and columns using grey code - a binary counting system in which only one bit changes when incrementing or decrementing a value. The grey code is recursively defined. The 1-bit grey code is <code>grey_code(1) = [0, 1]</code>. The <span class="math">\(n\)</span>-bit grey code is <code>grey_code[n] = map(grey_code[n - 1], lambda code: 0 .. code) + map(reversed(grey_code[n - 1]), lambda code: 1 .. code)</code>.</p>
<p>In other words, to get the next grey code, we prepend a 0 to every binary string in the current grey code, and prepend a 1 to the reversed version of the current grey code, then put these two together.</p>
<p>Every variable splits the output space of a function in half. Let <span class="math">\(f(x_1, \ldots, x_n)\)</span> be a Boolean function. Let <span class="math">\(f_0\)</span> represent <span class="math">\(f(0, x_2, \ldots, x_n)\)</span> and</p>
<p>The 5-input K-map is 3-dimensional. ;wip: why?</p>
<p>As a result, it is difficult to visualize. Instead, what we can do is <span class="math">\(f = \overline x f_0 + x f_1\)</span>, and then do a K-map for <span class="math">\(f_0\)</span> and <span class="math">\(f_1\)</span>.</p>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2014 Anthony Zhang.
</div>
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>