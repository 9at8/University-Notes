<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CS246 | Anthony Zhang</title>
  <style type="text/css">
  body {
    font-family: "Segoe UI", Verdana, Arial, Helvetica, sans-serif;
    background: #fffefe;
    padding: 5em;
  }
  
  pre {
    margin-left: 2em;
  }
  
  code {
    border: solid 1px black;
    background: #665555;
    color: white;
    padding: 0.1em;
    border-radius: 0.3em;
    display: inline-block;
  }
  
  pre code {
    padding: 1em;
    border-radius: 0.5em;
  }
  
  h1 {
    font-size: 4em;
  }
  
  table {
    margin: 0 auto;
  }
  
  td, th {
    padding: 0.5em;
    border: 1px solid grey;
  }
  
  tr {
    padding:: 0;
  }
  
  blockquote {
    margin-left: 0;
    padding-left: 0.5em;
    border-left: solid 0.3em grey;
  }
  
  .figure {
    border: solid 0.1em grey;
    display: inline-block;
    padding: 1em;
    text-align: center;
  }
  
  .figure .caption {
    margin: 0;
    font-size: 80%;
  }
  
  a.button {
    display: inline-block;
    padding: 1em;
    font-family: monospace;
    color: black;
    text-decoration: none;
    border: 0.2em solid black;
    border-radius: 0.5em;
    background: white;
  }
  
  a.button:hover, a.button:focus, a.button:active {
    background: black;
    color: white;
  }
  </style>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>
<body>
<a class="button" href="..">&#8666; Return to University Notes index</a>
<h1 id="cs246">CS246</h1>
<p>Object-oriented development.</p>
<pre><code>Instructor: Nomair Naeem
Office: DC 3548 (lab, by appointment), room B
Email: nanaeem@uwaterloo.ca
Website: https://www.student.cs.uwaterloo.ca/~cs246/
TA: Richard Wallace, cs246@student.cs.uwaterloo.ca</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}_P)}
\]</span></p>
<h1 id="section">6/5/14</h1>
<p>Five assignments, final assignment is worth more. Each assignment has two due dates - the first one we submit test cases, and the second is a week later and we submit code.</p>
<p>;wip: do assignment 0</p>
<p>This course focuses on object oriented programming and the tools and techniques of software development, with a specific focus on C++.</p>
<h2 id="linux-shell">Linux Shell</h2>
<p>The shell is an interface to the computer. The two main categories are graphical or command-line.</p>
<p>Graphical interfaces are easy to use, but makes it difficult to do complex tasks. They are available on almost every OS.</p>
<p>The command line accepts commands that are typed at the prompt. Windows has a DOS shell, while UNIX has a command line shell. It is possible to do more complex tasks with a command prompt, but it also has poor discoverability and a steep learning curve.</p>
<p>The first shell is Bourne shell, and then Cshell (and its descendent, Turbo shell) and Korn shell came along. Finally, there is Bourne Again Shell, or BASH. Bash is what we use in this course.</p>
<p>We can tell if a shell is Bash by the presence of the <code>$</code> before the input prompt. <code>echo $0</code> should print out the type of prompt, like &quot;bash&quot; or &quot;sh&quot;.</p>
<h1 id="section-1">8/5/14</h1>
<h2 id="filesystem">Filesystem</h2>
<p>The Linux filesystem consists of programs, code, and data.</p>
<p>There are files and directories. Directories can contain other directories and files. The filesystem is similar to a tree. However, directories are simply another type of file.</p>
<p>Within a directory, filenames must be unique. Filenames are case sensitive. For example, we can have <code>/bin</code> and <code>/usr/bin</code>.</p>
<p>The filesystem is often thought of as a tree, where nodes represent files. A standard Linux installation will usually have the following structure:</p>
<ul>
<li><code>/</code>
<ul>
<li><code>bin</code>
<ul>
<li><code>bash</code></li>
<li><code>ls</code></li>
<li><code>...</code></li>
</ul></li>
<li><code>etc</code>
<ul>
<li><code>shells</code></li>
<li><code>...</code></li>
</ul></li>
<li><code>home</code>
<ul>
<li><code>ahzhang</code>
<ul>
<li><code>USER_FILES_GO_HERE</code></li>
</ul></li>
<li><code>OTHER_USERS_GO_HERE</code></li>
</ul></li>
<li><code>usr</code>
<ul>
<li><code>bin</code></li>
<li><code>include</code></li>
<li><code>share</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="relativeabsolute-paths">Relative/Absolute Paths</h3>
<p><code>/</code> is always the <strong>root directory</strong>. All paths must be relative to some reference path.</p>
<p>When we have a path relative to a fixed directory such as <code>/</code> or <code>/home</code>, this is an <strong>absolute path</strong>. For example, <code>/home/ahzhang/DropBox/School/Schedule.png</code>, or <code>~/DropBox/School/Schedule.png</code>.</p>
<p>Any other path is a <strong>relative path</strong>. What it actually is the path to depends on what it is relative to. For example, <code>bin/bash</code> could represent <code>/bin</code> or <code>/usr/bin</code>. How the path is resolved depends on the current/working directory.</p>
<p>The <strong>current/working directory</strong> is always available, and is the directory that all relative paths are relative to. For example, if the current working directory is <code>/home/ahzhang/DropBox/School</code>, then the relative path <code>Schedule.png</code> will resolve to <code>/home/ahzhang/DropBox/School/Schedule.png</code>.</p>
<p>The <code>pwd</code> (present working directory) command will display the current directory.</p>
<p>The <code>cd DIRECTORY_GOES_HERE</code> (change directory) command will change the current directory to <code>DIRECTORY_GOES_HERE</code>.</p>
<p><code>.</code> is a special directory that always represents the current directory.</p>
<p>For example, <code>cd .</code> changes the current directory to the current directory, which does nothing.</p>
<p><code>..</code> is a special directory that always represents the parent of the current directory.</p>
<p>For example, to change the current directory to the grandparent of the current directoy, we can use <code>cd ../..</code>.</p>
<p><code>~</code> is a special directory that always represents the current user's home directory, like <code>/home/ahzhang</code>. This is an absolute path because it does not depend on the current directory.</p>
<p>For example, <code>cd ~</code> will change the current directory to the current directory. In fact, this is used so often that <code>cd</code> by itself will do the same as <code>cd ~</code>.</p>
<p>Also, <code>cd -</code> will change the current directory back to the last current directory - to the directory before we changed it with <code>cd DIRECTORY_GOES_HERE</code>.</p>
<p><code>~USER_ID_GOES_HERE</code> is a special directory that always represents the home directory of the user <code>USER_ID_GOES_HERE</code>. This works as long as the referenced user has given permission to access it. This is an absolute path because it does not depend on the current directory.</p>
<p>Linux does not enforce the concept of file extensions. It is still followed by convention, however, since it is convenient.</p>
<h3 id="globs">Globs</h3>
<p>The <code>ls PATTERN_GOES_HERE</code> command will list the contents of <code>PATTERN_GOES_HERE</code>, or if not specified, then it lists the contents of the current directory.</p>
<p>It simply shows a list of information about the files in the directory.</p>
<p>This command does not show certain files - <strong>dotfiles</strong>. These are simply files/directories that have names that begin with a <code>.</code>. This is a convention that allows for somewhat hidden files, which are useful for things like configuration.</p>
<p>To show these files anyways, we can use <code>ls -a PATTERN_GOES_HERE</code>, which works the same way but also shows dotfiles.</p>
<p>The parameter given to <code>ls</code> does not have to simply be a path. It also supports <strong>wildcards</strong>. Wildcard patterns are known as <strong>globbing patterns</strong> or <strong>globs</strong>. In globs, <code>*</code> means match any one file or directory name, and <code>?</code> means match any one character of a file or directory name.</p>
<p>For example, <code>ls *.txt</code> lists all the text files in the current directory, and <code>ls pictures-??-??-??-*</code> matches all files of the form <code>pictures-TWO_DIGIT_NUMBER-TWO_DIGIT_NUMBER-TWO_DIGIT_NUMBER-ANYTHING</code>.</p>
<p>When we have a globbing pattern, the shell itself actually does the matching, not the command (like <code>ls</code>). The shell matches all the files, then passes all the matched files on the command line. The advantage of this approach is that each command does not have to implement globbing itself.</p>
<p>Globs are matched relative to the current directory.</p>
<p>Also, <code>rm PATTERN_GOES_HERE</code> removes all files matching <code>PATTERN_GOES_HERE</code>.</p>
<p>We can even do things like <code>echo *.txt</code>, which will print out all the text files in the current directory. Hwoever, to literally print <code>*.txt</code>, we simply use quotes, like <code>echo '*.txt'</code> or <code>echo &quot;*.txt&quot;</code>.</p>
<p>Also, globbing patterns do not work inside quotes - they must appear directly.</p>
<h3 id="file-operations">File Operations</h3>
<p>Also, if a command is taking too long, then we can use <code>Ctrl + C</code> to kill it. This is often written as <code>^C</code>. There is also <code>Ctrl + D</code>, which sends the end-of-file symbol to the program, which allows it to gracefully terminate.</p>
<p>The <code>cat PATTERN_GOES_HERE</code> (concatenate) command is an extremely commonly used command that simply prints out the contents of all given files.</p>
<p>If the pattern is not specified, so we used <code>cat</code>, then the input is taken from the standard input. If we type some words, they will be pritned out again at the standard output. This continues until we stop the command using <code>^D</code> or similar. This mode is useful if we can capture the output somewhere.</p>
<p>All files given to <code>cat</code> are concatenated together. Running <code>cat A.txt B.txt</code> outputs the value of both files right after one another.</p>
<h3 id="inputoutput-redirection">Input/Output Redirection</h3>
<p>The <code>COMMAND&gt;FILE</code> operator redirects the standard output of <code>COMMAND</code> into the file <code>FILE</code>, overwriting any existing contents of the file. For example, <code>cat &gt; entered_text.txt</code> allows the user to type in some text and have it saved to <code>entered_text.txt</code></p>
<p>The <code>COMMAND&lt;FILE</code> operator redirects the standard input of <code>COMMAND</code> to the file <code>FILE</code>, so it is almost as if it was typed directly as input. For example, <code>cat &lt; input.txt</code> will display the contents of <code>input.txt</code> on the screen.</p>
<p><code>cat FILE</code> is exactly equivalent to <code>cat &lt; FILE</code>.</p>
<p>The <code>wc FILE</code> command counts the number of lines, words, or characters in a given file, or in the standard output if not specified. For example, <code>wc test.txt</code> gives <code>LINE_COUNT WORD_COUNT CHARACTER_COUNT FILE</code>.</p>
<p>However, <code>wc &lt; FILE</code> gives <code>LINE_COUNT WORD_COUNT CHARACTER_COUNT</code> - there is no <code>FILE</code> in the output since it is simply given from the standard input.</p>
<p>Every process has a standard input (stdin) and output (stdout) - the default place to get input and print output. The standard input is usually connected to the keyboard and the standard output is usually connected to the screen.</p>
<p>Input redirection changes stdin, and output redirection changed stdout.</p>
<p>Standard output is <strong>buffered</strong> - characters to be sent to the output are stored up until there is a large enough amount to send to the screen. This sending process is known as <strong>flushing</strong> the buffer.</p>
<p>Every process also has a standard error (stderr) - the default place to print out errors. This is intended to avoid cluttering the output. Also, stderr is not buffered - all errors will show up right away, not whenever the buffers are flushed.</p>
<p>We can redirect stderr using <code>2&gt;</code>, in a way similar to <code>&gt;</code>.</p>
<p>We can also do all types of redirection at the same time: <code>cat &lt; input.txt &gt; output.txt 2&gt; error.txt</code> reads the contents of <code>input.txt</code> and then writes it to <code>output.txt</code>, and any errors are written to <code>error.txt</code>.</p>
<p>There are also <strong>pipes</strong>, which allow the output of one program to become the input of another. <code>COMMAND_A|COMMAND_B</code> connects the stdout of <code>COMMAND_A</code> to the stdin of <code>COMMAND_B</code>.</p>
<h1 id="section-2">13/5/14</h1>
<p>The <code>head -NUMBER_OF_LINES FILE</code> command will read the first <code>NUMBER_OF_LINES</code> lines from <code>FILE</code>. If <code>FILE</code> is not specified, the lines are read from stdin.</p>
<p>So if we wanted to get the number of words in the first 20 lines of <code>sample.txt</code>, we might use <code>cat sample.txt | head -20 | wc -w</code> or simply <code>head -20 sample.txt | wc -w</code>.</p>
<p>The <code>uniq</code> command removes duplicate lines, but <strong>only if they occur next to each other</strong> - only adjacent duplicates are removed. It is therefore often used together with the <code>sort</code> command, which sorts its input by lines.</p>
<p>It is also possible to send the output of a program as a parameter to another program, using the backquotes/backticks notation. For example, <code>echo &quot;Today is \</code>date` and I am `whoami`&quot;<code>might display something like</code>Today is Tue May 13 08:50:24 EDT 2014 and I am Anthony`.</p>
<p>The shell will first evaluate the command in the backquotes, substitute its output for it, and then execute the original command. This works even if the parameter is inside quotes, as in the example above. An alternative syntax is <code>$(COMMAND)</code> instead of <code>\</code>COMMAND``, which is slightly easier to read. This is often used to format strings.</p>
<p>We now want to search inside text files. For this we can use <code>grep PATTERN FILE</code> or <code>egrep PATTERN FILE</code> (recommended, equivalent to <code>grep -E</code>). This prints out every line in <code>FILE</code> that contains <code>PATTERN</code>. Here, <code>PATTERN</code> is an extended regular expression. If <code>FILE</code> is not specified, input is taken from the standard input.</p>
<h3 id="regular-expressions">Regular Expressions</h3>
<p>Regular expressions are concise ways to express a set of strings, which may possibly be arbitrarily large. For example, <code>a?b?c?</code> denotes the set containing the strings &quot;&quot;, &quot;c&quot;, &quot;b&quot;, &quot;bc&quot;, &quot;a&quot;, &quot;ac&quot;, &quot;ab&quot;, and &quot;abc&quot;.</p>
<p>Regular expressions consist of characters and operators. Characters like &quot;e&quot; and &quot;5&quot; simply denote themselves in the set. Operators like <code>*</code> modify strings with operations like &quot;zero or more of the preceding&quot;.</p>
<p>For example, <code>a*</code> matches zero or more &quot;a&quot; instances, like &quot;&quot; and &quot;aaaaaaaaaaaaaaaaaaaaaaaaa&quot;. It denotes the set of all strings consisting entirely of &quot;a&quot; and the empty string.</p>
<p>So to match either &quot;CS246&quot; or &quot;cs246&quot;, we might use <code>egrep &quot;CS246|cs246&quot;</code> (the quotes are necessary because otherwise it is a pipe), or simply <code>egrep &quot;(CS|cs)246&quot;</code>. Alternatively, to do it without case sensitivity we might use <code>egrep [cC][sS]246</code>. The <code>[...]</code> operation is called a character class, and matches one of the characters inside it. Also, the <code>[^...]</code> matches anything that is not one of the characters inside it.</p>
<p><code>?</code> means &quot;zero or one of the preceding&quot;. So <code>egrep (abc)?d?</code> matches &quot;&quot;, &quot;abc&quot;, &quot;d&quot;, and &quot;abcd&quot;. <code>*</code> means &quot;zero or more of the preceding&quot;, while <code>+</code> means &quot;one or more of the preceding&quot;.</p>
<p><code>{A, B}</code> means &quot;between <code>A</code> and <code>B</code> inclusive of the preceding&quot;. If <code>B</code> is blank, then it is assumed to be infinity. Clearly, <code>?  is equivalent to</code>{0, 1}<code>and</code>+<code>is equivalent to</code>{1,}`.</p>
<p><code>.</code> means &quot;any character&quot;. For example, <code>egrep ...</code> will match any three characters. <code>^</code> matches the beginning of a line, and <code>$</code> matches the end.</p>
<p>For example, to list all files in the current directory with exactly one &quot;a&quot;, we might use <code>ls | egrep &quot;^[^a]*a[^a]*$&quot;</code>.</p>
<h1 id="section-3">15/5/14</h1>
<h2 id="permissions">Permissions</h2>
<p><code>ls -l</code> displays more information about files, such as the owner and permissions.</p>
<p>For example, <code>ls -l</code> might give <code>-rwxr--r-- 1 nanaeem staff 11K 2014-05-12 20:27 index.shtml</code>.</p>
<p><code>2014-05-12 20:27</code> is the last date/time the file was modified. <code>11K</code> is the file size, <code>staff</code> is the group, <code>nanaeem</code> is the owner, <code>1</code> (the first one) is the number of links, <code>rwxr--r--</code> is the permissions, and <code>-</code> (the first one) is the file type (<code>d</code> for directory, <code>-</code> for file).</p>
<p>Groups facilitate sharing of files. Every file belongs to one group, and users can belong to multiple groups (this can be listed using the <code>groups</code> command). To share files, all involved users must be in the same group.</p>
<p>The permissions are simply 3 groups of 3 letters, with 9 letters in total. Each letter is either <code>-</code> or an alphabetical character, and represents a binary bit. The groups are:</p>
<ol style="list-style-type: decimal">
<li>User bits: three bits that determine what permissions the owner of the file has</li>
<li>Group bits: three bits that determine what permissions the members of the file's group has.</li>
<li>Other bits: three bits that determine what permissions everyone else has.</li>
</ol>
<p>The first letter (bit) of each group is the read bit, and is <code>r</code> if set, or <code>-</code> otherwise. If set, we would be able to read the file, or if it is a directory, we can list its contents.</p>
<p>The second letter (bit) of each group is the write bit, and is <code>w</code> if set, or <code>-</code> otherwise. If set, we would be able to modify the file contents, or if it is a directory, we can add or remove files.</p>
<p>The third letter (bit) of each group is the execute bit, and is <code>x</code> if set, or `<code>otherwise. If set, we would be able to execute the file like a program, or if it is a directory, we can navigate into it, like with</code>cd`.</p>
<p>So if a file has execute but not read permissions, then we could go into it but not list its contents. But if we happen to know one of the file paths, we can still access that file by path.</p>
<h3 id="changing-permissions">Changing Permissions</h3>
<p>Only the owner of a file can change its permissions. It is not possible to give this ability to anyone else, and it is always possible for the owner to change permissions.</p>
<p>We do this using the <code>chmod MODE FILE</code>. <code>MODE</code> is a string of the form <code>OWNERSHIP_CLASS OPERATOR PERMISSIONS</code>, with no spaces.</p>
<p><code>OWNERSHIP_CLASS</code> is the set of bits to apply the operations to. This value can be <code>u</code> for the user/owner bits, <code>g</code> for the group bits, <code>o</code> for the other bits, and <code>a</code> for all bits.</p>
<p><code>OPERATOR</code> is an operation to perform with the permissions. This value can be <code>+</code> for adding a permission, <code>-</code> for removing a permission, or <code>=</code> to clear all the permissions and add the new one (set the permissions exactly).</p>
<p><code>PERMISSIONS</code> is simply the permissions to be modified. This value is a string consisting of the characters <code>r</code> for read, <code>w</code> for write, and <code>x</code> for execute.</p>
<p><code>FILE</code> is the file that the permission changes should apply to.</p>
<p>For example <code>chmod o+r sample.txt</code> gives the owner permission to read <code>sample.txt</code>.</p>
<h2 id="shell-scripting">Shell Scripting</h2>
<h3 id="variables">Variables</h3>
<p>In Bash, we can set variables using things like <code>x=1</code> or <code>x=&quot; a b c &quot;</code>. It is important that <strong>there are no spaces around the equal sign</strong>. If there are, the shell would interpret the <code>x</code> or <code>1</code> as a command.</p>
<p>We can display the value of the variable using something like <code>echo $x</code>.</p>
<p>When we want to set a variable's value, we simply write the variable name.</p>
<p>When we want to get the value of the variable, we prefix it with a <code>$</code>, like <code>$x</code>. It is good practice to enclose the name with curly brackets: <code>${x}</code>. This can</p>
<p>Variables are expanded by the shell before the current command is executed. Variables are expanded when they appear directly, or inside double quotes. Inside single quotes, variables are not expanded. For example, <code>echo $VAR</code> and <code>echo &quot;$VAR&quot;</code> print out the value of <code>VAR</code>, but <code>echo '$VAR'</code> will literally print out, &quot;$VAR&quot;.</p>
<p>One of the most commonly used shell variables is <code>PATH</code>. This variable is a colon-separated list of paths that are searched in order when trying to execute a file. For example, if we execute <code>ls</code>, the shell will go through the paths specified in <code>PATH</code> one by one, looking for the <code>ls</code> program. If found, it stops searching, and otherwise an error is raised. This is essentially the list of places we should search for when we try to run a program specified by a relative path.</p>
<h3 id="scripts">Scripts</h3>
<p>Bash scripts are files that contain a sequence of Bash commands that can be executed as a program.</p>
<p>For example, if we want to print out the date, current user, and current directory, we might write in the <code>script</code> file:</p>
<pre><code>#!/bin/bash
date
whoami
pwd</code></pre>
<p>The <code>#!/bin/bash</code> specifies that this file should be run with the <code>/bin/bash</code> program. <code>#</code> is often called &quot;hash&quot; and <code>!</code> is often called &quot;bang&quot;, so this type of line is often called the hashbang or shebang. This must be the first line and should not have any spaces before it.</p>
<p>Single-line comments are begun with <code>#</code>, which causes the rest of the line to be ignored. Therefore, the shebang line is actually just a comment to Bash.</p>
<p>Often the current directory is not in the <code>PATH</code> variable. That means that if we try to run <code>script</code> Bash will not find it in <code>PATH</code> and will not run the script. Instead, we often specify a full path using <code>./script</code>, which is a fully given path - there is no need to search through <code>PATH</code> to resolve it because it is explicitly stated to be in the current directory. It is also possible to add <code>.</code> to the <code>PATH</code> variable to be able to directly run programs from the current directory.</p>
<p>A shell script must have execute permissions to be run. This can be done using something like <code>chmod a+x script</code></p>
<p>Shell scripts can read command line arguments using the special shell variables <code>$1</code>, <code>$2</code>, and etc., where <code>$0</code> contains the command line itself, &quot;script&quot;.</p>
<p>For example, a shell script that checks if a word is in a dictionary can be written with a hashbang and <code>egrep &quot;^$1$&quot; /usr/share/dict/words</code>.</p>
<p><code>/dev/null</code> is a file that can be written to, but simply discards whatever is written. Redirecting output to <code>/dev/null</code> means we are discarding the output.</p>
<p>If we want to check something like whether <code>egrep</code> matched something, we can use the exit code. The <strong>exit code</strong> is the value that we returned from the <code>main</code> function in C programs.</p>
<p>By convention, 0 indicates success, and a non-zero value indicates some sort of failure. In Bash, the last exit code given by a program is stored in the special shell variable <code>$?</code>.</p>
<p>In the above example, <code>egrep</code> gives exit code 1 if no matches were found and 0 otherwise:</p>
<pre><code>egrep &quot;^$1$&quot; /usr/share/dict/words
if [ $? -eq 0 ]; then
    echo Not a good password
else
    echo Maybe a good password
fi</code></pre>
<p>The spaces between <code>[</code>, <code>$?</code>, <code>-eq</code>, <code>0</code>, and <code>]</code> are all required. The body must be on its own line.</p>
<p><code>$#</code> is another special shell variable, which always contains the number of command line arguments passed in. It is 0 if none were given - the <code>$0</code> variable does not count.</p>
<p><code>if</code> is a Bash construct that takes the form <code>if PROGRAM; then BODY else BODY fi</code>. The first body is executed if the status code is 0, and otherwise the second one is executed.</p>
<p>In our example, the status code is compared against 0, and a different message is displayed depending on whether the comparison succeeded. We could also use <code>if egrep &quot;^$1$&quot; /usr/share/dict/words; then</code> instead since the exit code follows the right pattern.</p>
<p>The general pattern is as follows, with zero or any number of <code>elif</code> statements:</p>
<pre><code>if [ CONDITION ]; then
    BODY
elif [ CONDITION ]; then
    BODY
else
    BODY
fi</code></pre>
<p>When we used it in the form above, we actually executed the <code>[</code> program with the value of <code>$?</code>, <code>-eq</code>, and <code>0</code>, which sets the exit code to 0 if the expression evaluates to true (<code>$?</code> is equal to <code>0</code>), or 1 otherwise. This happens to work very well with the <code>if</code> construct.</p>
<p><code>-eq</code> is an operator for comparing integers. To compare strings, we can use <code>==</code> or <code>=</code>.</p>
<p>We can have as many <code>elif</code> statements as we need.</p>
<p>A <code>while</code> loop statement has a similar form to an <code>if</code> statement. The following prints out all the numbers from 1 to its first command line argument, inclusive:</p>
<pre><code>x=1
while [ $x -le $1 ]; do
    echo $x
    x=$((x+1))
done</code></pre>
<p><code>$((...))</code> performs arithmetic by evaluating <code>...</code> as an expression.</p>
<p>Functions in Bash have the following form:</p>
<pre><code>usage() {
    echo &quot;Usage: $0 [[password]]&quot;
}</code></pre>
<p>We often want to validate user input to ensure that we are working with valid data. We can do that by having something like the following near the beginning of the script:</p>
<pre><code>if [ $# -ne 1 ]; then
    usage
    exit 1
fi</code></pre>
<h1 id="section-4">20/5/14</h1>
<p>A <code>for</code> loop statement iterates over a given series. It has the following form:</p>
<pre><code>for name in *.cpp; do
    mv $name ${name%cpp}cc
done</code></pre>
<p>Here, <code>name</code> is the name of the variable to store the current item in the series. The <code>*.cpp</code> is a globbing pattern that gets expanded into a series. <code>${name%cpp}</code> means the ending <code>cpp</code> should be removed.</p>
<p>The basic form is <code>for x in a b c ...; do statements; done</code>. This executes <code>statements</code> for each value of <code>a b c ...</code>, where <code>x</code> stores the current value.</p>
<p>To iterate over words in a file, we can use <code>for word in $(cat $file)</code>.</p>
<p>When we have a variable with a space in it, like <code>x=&quot;a b c&quot;</code>, when we do something like <code>cat $x</code> we are actually passing in 3 arguments, <code>a</code>, <code>b</code>, and <code>c</code>. When we want to handle user input, it is usually a good idea to put the input variables in double quotes. In the above example, we change it to <code>cat &quot;$x&quot;</code> and it will attempt to read the file &quot;a b c&quot;.</p>
<h2 id="testing">Testing</h2>
<p>The goal of testing is to improve code quality. Testing is the process of trying various inputs on a program to catch errors in the output and verify seemingly correct programs are actually correct.</p>
<p>It is recommended that we write tests before beginning the coding process.</p>
<p>Guidelines for functional testing (testing the functionality of a program):</p>
<ul>
<li>Aim to have tests that check every different control flow path.</li>
<li>Check ranges of inputs, like typical negative/positive values.</li>
<li>Check boundaries at the edge of ranges, such as 0 and big numbers for integers, and also check combinations of boundaries, like testing the boundaries of two inputs at once.</li>
</ul>
<p>Regression testing is testing used to detect regressions - old bugs reintroduced into the code. We basically rerun all the old test cases again on the new code to ensure the new code does not break the old code.</p>
<h2 id="basic-c">Basic C++</h2>
<p>Invented by Bjarne Stroustrup (Byarne Stroostrup) in the 1980s, intended to bring some object oriented features into C.</p>
<p>C++ is based in C first and foremost. Many valid C programs are also valid C++ programs. This course will assume a level of proficiency developed with C over the course of CS136.</p>
<p>The current standard is C++11, which was introduced in 2011 and added many sophisticated language constructs like anonymous functions. However, support is not perfect, and C++03 is still widely used.</p>
<p>C++ source files often have the <code>*.cc</code> or <code>*.cpp</code> extension.</p>
<p>A basic C++ program might look like the following:</p>
<pre><code>#include &lt;iostream&gt; // we do not have to specify the .h extension for header files
using namespace std; // this puts the std namespace into the global namespace, so std::cout is the same as cout; without this line we have to use std::cout and std::endl
int main() { // the main function must be declared to return an integer, and for this funciton only it is not required to actually use a `return` statement (defaults to `return 0`)
    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;
}</code></pre>
<p>The syntax is similar to C. <code>cout</code> is the standard output stream, and <code>endl</code> is a constant representing the end of line (a newline on Linux, and a carriage return with a newline on Windows).</p>
<p>The <code>iostream</code> library has 3 main input/output (I/O) objects: <code>cout</code> representing standard output, <code>cerr</code> representing standard error, and <code>cin</code> representing standard input.</p>
<p>The <code>&lt;&lt;</code> is an output operator - the &quot;put to&quot; operator. It sends the right operand to the stream specified by the left operand, producing the stream again. For example, <code>cout &lt;&lt; x</code> puts <code>x</code> to stdout.</p>
<p>The <code>&gt;&gt;</code> is an input operator - the &quot;get from&quot; operator. It reads data from the stream specified by the left operand into the right operand, producing the stream again. For example, <code>cin &gt;&gt; x</code> gets <code>x</code> from stdin.</p>
<p><code>stdio.h</code> and such are still available, but should not be used because C++ has its own equivalent functionality and libraries. Marmoset will be forbidding these libraries from being used.</p>
<h3 id="compiling">Compiling</h3>
<p>We will be using g++, the equivalent of GCC for C++. A typical invocation might look like <code>g++ myprogram.cpp -o output</code>, where <code>myprogram.cpp</code> is the name of the source file and <code>output</code> is the executable (if not specified, defaults to <code>a.out</code>).</p>
<p>The following is a program that takes two numbers and adds them:</p>
<pre><code>#include &lt;iostream&gt;
int main() {
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;
    cout &lt;&lt; x + y &lt;&lt; endl;
}</code></pre>
<p>Note that <code>cin</code> waits for an integer because the right side is an integer. This is an example of overloading. <code>cin</code> will always ignore whitespace and newlines when doing this.</p>
<p>The syntax is <code>g++ OPTIONS FILE</code>.</p>
<h3 id="inputoutput">Input/Output</h3>
<p>If we type in some invalid input like <code>4 potato</code> to the above program or give an EOF, the variables are either uninitialized or set to 0 or other behaviour.</p>
<h1 id="section-5">22/5/14</h1>
<p>How do we check if the input given was invalid - if the read was successful? <code>cin.fail()</code> is true if and only if the most recent read failed (invalid or EOF). Likewise, <code>cin.eof()</code> is true if and only if the most recent read got to the end of the input.</p>
<p>We must attempt to do the reading, and if it fails, then we handle the error condition. Also, if there is an error, the failure flag stays set until we acknowledge it, and until then all subsequent reads do nothing. Upon error, the stream is not advanced and a second read will try to read the same thing.</p>
<p>Program that reads integers and prints them until a non-integer or EOF is encountered:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    int i;
    while (true) {
        cin &gt;&gt; i;
        if (cin.fail()) break;
        cout &lt;&lt; i &lt;&lt; endl;
    }
}</code></pre>
<p>When we say <code>if (!cin)</code>, <code>cin</code> is implicitly converted into a <code>void*</code>, and is truthy if the last read was successful and falsy otherwise. <code>if (cin)</code> is equivalent to <code>if (!cin.fail())</code>.</p>
<p>Also, <code>std::cin &gt;&gt; i</code> evaluates to <code>std::cin</code>, which allows us to do things like <code>cin &gt;&gt; x &gt;&gt; y</code>. This technique is known as <strong>cascading</strong>. The same thing works with the <code>&lt;&lt;</code> operator as well, which we saw in the <code>cout &lt;&lt; i &lt;&lt; endl</code> line.</p>
<p>Note that <code>a &gt;&gt; b</code> is also the right bit-shift operator, equivalent to <code>\floor{\frac a {2^b}}</code>. This operator <strong>behaes differently depending on its operands</strong>. If the left side is an IStream such as <code>std::cin</code>, it acts as the input operator, and if the left side is an int, it acts as a right bit-shift.</p>
<p>With this in mind, we can have the following shorter version:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int main() {
    int i;
    while (cin &gt;&gt; i) cout &lt;&lt; i &lt;&lt; endl;
}</code></pre>
<p>Another one that ignores non-integers and echos integers until encountering EOF:</p>
<pre><code>// the `#include &lt;iostream&gt;` and `using namespace std;` are implicit for brevity
int main() {
    int i;
    while (true) {
        if (cin &gt;&gt; i) cout &lt;&lt; i &lt;&lt; endl;
        else {
            if (cin.eof()) break;
            cin.clear(); // acknowedge that the previous read failed and reset cin so we can read again
            cin.ignore(); // ignore the next input (character) so we don&#39;t read the same invalid value over and over again
        }
    }
}</code></pre>
<h3 id="strings">Strings</h3>
<p>In C++, strings are significantly easier to use than in C. We use the type <code>std::string</code>, and literals are denoted with double quotes (<code>&quot;string&quot;</code>):</p>
<pre><code>int main() {
    std::string s;
    std::cin &lt;&lt; s;
    std::cout &lt;&lt; s &lt;&lt; endl;
}</code></pre>
<p>When we try to read a string from stdin, it first ignores all leading whitespace, stores non-whitespace characters in the variable, and stops at the first whitespace character encountered. As a result, it will only read one word at a time.</p>
<p>To actually get the entire line, we can use <code>getline(cin, s)</code>. The type of data and the exact reading/writing behavior of <code>cin</code> or <code>cout</code> depends on the type of the right operand of <code>&gt;&gt;</code>.</p>
<p>However, if we wanted to use format specifiers (like those accepted by <code>printf</code> in C), like printing out integers in hexadecimal or octal, we can I/O Manipulators.</p>
<p>I/O Manipulators look like <code>std::cout &lt;&lt; std::hex</code>. This does not print anything, but it changes the behaviour of <code>cout</code> so that it prints integers out in hexadecimal. Likewise, <code>std::cout &lt;&lt; std::dec</code> changes <code>cout</code> to print integers out in decimal again. There are many other manipulators but these are one of the most common ones.</p>
<p>The advantage of using streams for things like <code>cin</code> and <code>cout</code> is that it abstracts more than just stdin and stdout. All the behaviour associated with stdin and stdout can also be used to other stream-like data such as a file or even on a network connection.</p>
<p>To use file streams, we must have <code>#include &lt;fstream&gt;</code> to have the file stream functionality. It provides <code>ifstream</code> for input file streams and <code>ofstream</code> for output file streams. The following prompts the user for a word and writes it to a file:</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
int main() {
    ifstream f(&quot;test.txt&quot;); // declare an `ifstream` initialized with &quot;test.txt&quot;
    string s;
    f &lt;&lt; &quot;Word: &quot; &lt;&lt; endl;
    cin &gt;&gt; s;
    f &lt;&lt; s &lt;&lt; endl;
}</code></pre>
<p>Note that we didn't have to close the file - C++ automatically closes it after we are done using it.</p>
<p>Also, <code>str.length()</code> gets the length of the string <code>str</code>.</p>
<h1 id="section-6">27/5/14</h1>
<p>In C++, when we have a function that accepts arguments, we can also make an argument optional, and give it a default value when none is specified:</p>
<pre><code>// default values can be given in the declaration or definition
void printSuiteFile(int max, string filename = &quot;suite.txt&quot;) { // arbitrary numbers of optional parameters can appear after the required parameters
    ifstream suite(filename.c_str()); // we have to convert it to a C style string because that&#39;s the only thing `ifstream` accepts
}
int main() {
    printSuiteFile(5); // no argument specified, default value used
    printSuiteFile(3, &quot;something.txt&quot;); // &quot;something.txt&quot; specified, default value ignored
}</code></pre>
<p><strong>Function overloading</strong> allows us to have functions with multiple definitions, each with unique signatures. C++ will look at the different signatures, and match each function call with the right definition:</p>
<pre><code>int negate(int a) { return -a; }
bool negate(bool a) { return !a; }
negate(5); // calls the first one
negate(true); // calls the second one</code></pre>
<p>The signatures are matched based on the function name, the number of arguments, and the type of the arguments. There can only be one definition for a given combination of function name and argument types. Notice that the signature does not include the return type - a signature is something like <code>f(int x)</code>, not <code>int f(int x)</code>.</p>
<p>It is also possible to do <strong>operator overloading</strong>. For example, <code>cin &gt;&gt; INTEGER_VAR</code> reads an integer while <code>cin &gt;&gt; STRING_VAR</code> reads a string - the <code>&gt;&gt;</code> operator is overloaded to read input from streams, as well as the right bit shift operator on integers.</p>
<p>A declaration asserts the existance of an entity. A definition is the actual implementation of an entity. A definition must necessarily require a declaration. Declarations can be repeated as many times as we want, but there can only be one definition per entity.</p>
<h2 id="strings-1">Strings</h2>
<p>We can also do I/O on strings using streams, using the <code>sstream</code> library:</p>
<pre><code>#include &lt;sstream&gt;
int main() {
    std::string value = &quot;2 5&quot;;
    istringstream input(value); // string reader
    ostringstream output; // string writer
    output &lt;&lt; &quot;Enter a number between &quot; &lt;&lt; low &lt;&lt; &quot; and &quot; &lt;&lt; high;
    int low, high; input &gt;&gt; low, input &gt;&gt; high;
    std::string result = output.str();
}</code></pre>
<p>Note that we didn't have to use <code>clear</code> on the output stream, because although the failure flag was raised, we are simply making new streams every iteration of the loop.</p>
<p>The string writer is useful for formatting text and converting numbers to strings. The string reader is useful for converting strings to numbers. When using string readers, it is important that we handle EOF.</p>
<p>In C, strings were null-terminated char arrays that we had to do memory management on manually and were prone to buffer overruns. In C++, strings are part of the standard library, manage their own memory, and are much less prone to buffer overruns.</p>
<p>Consider <code>string s = &quot;hello&quot;;</code>. <code>&quot;hello&quot;</code> is simply a char array with a null terminator, while <code>string</code> is a C++ string. C++ implicitly converts C-style strings into C++ strings (instances of <code>std::string</code>).</p>
<p>However, C++ strings are not implicitly converted into C style strings. This becomes necessary for things like <code>ifstream</code>, which only accepts a C string for the file name. We can explicitly convert the C++ string into C style using <code>s.c_str()</code>.</p>
<p>In C, we used <code>strcmp(a, b)</code> to compare strings, while <code>a == b</code> only compared pointers. In C++, we can simply use <code>a == b</code> or <code>a != b</code> to compare strings.</p>
<p>We can also still use the <code>s[i]</code> notation that we can use in C. To concatenate two strings, we can use <code>a + b</code> instead of <code>strcat(a, b)</code>.</p>
<h1 id="section-7">29/5/14</h1>
<p>The reason structure declarations need a semicolon at the end is because we can actually declare variables right after:</p>
<pre><code>struct Node {
    int data;
    Node *next; // the `struct` is not necessary
    // ...
} node_var1, node_var2, *pointer_to_node;
// now `node_var1`, `node_var2`, and `pointer_to_node` are defined
Node node_var3;</code></pre>
<p>In C++, we can also simply write <code>Node</code> instead of <code>struct Node</code> in all contexts, except the declaration itself.</p>
<p>When we read type declarations, we start from the identifier and work outwards. For example, <code>int * const p</code> is a constant pointer to an integer, and <code>const int *p</code> is a pointer to a constant integer.</p>
<p>When we use an operator like <code>A &lt;&lt; B</code>, this is calling a function called <code>operator&lt;&lt;</code> with two arguments <code>A</code> and <code>B</code>.</p>
<pre><code>void inc1(int n) { n ++; }
void inc2(int *n) { (*n) ++; }
void inc3(int &amp;n) { n ++; } // here, `n` is a reference to `x`, because `x` is now being passed by reference
int main() {
    int x = 5;
    inc1(x); // this does nothing because the argument is passed by value
    inc2(&amp;x); // this works because we are passing an address by value, but requires special syntax
    inc3(x); // now we are passing a reference to `x` rather than the value
    cout &lt;&lt; x &lt;&lt; endl;
}</code></pre>
<h2 id="references">References</h2>
<p>C++ also has another pointer-like type, the <strong>reference</strong>:</p>
<pre><code>int y = 10;
int &amp;z = y;</code></pre>
<p>This means that &quot;<code>z</code> is a reference to <code>y</code>&quot;. This means that <code>z</code> is a constant pointer to <code>y</code>, but with automatic dereferencing. So whenever we write <code>z</code>, it actually means &quot;the value pointed to by <code>z</code>&quot;, so <code>y</code> in this case. Therefore, writing <code>z</code> is equivalent to writing <code>y</code> - it has no identity of its own.</p>
<p>So <code>int *p = &amp;z</code> makes <code>p</code> point to <code>y</code> and <code>z = 5</code> sets <code>y</code> to 5. Also, <code>sizeof(z)</code> is simply the size of <code>y</code>. References are more or less exactly the same as writing the variable itself - they are aliases.</p>
<p>References cannot be left uninitialized because they are actually constant pointers. Also, they must be initialized to something that has an address (an lvalue), so we can't do <code>int &amp;z = 5</code>.</p>
<p>We cannot create a pointer to a reference itself (<code>int &amp;*p = ...;</code>), only the lvalue it refers to (<code>int *p = &amp;z</code>), but we can create a reference to a pointer (<code>int *&amp;p = q;</code> after <code>int *q;</code>). However, we cannot create a reference to an array (<code>int &amp;x[] = {1, 2, 3}</code>).</p>
<p><code>cin</code> actually uses references to support things like <code>cin &gt;&gt; x</code>: <code>istream &amp;operator&gt;&gt;(istream &amp;in, int &amp;data)</code>. Here, <code>istream in</code> is <code>cin</code> and <code>data</code> is a reference to <code>x</code>. Both are being taken by reference because both are modified by reading. We return a reference because we don't want to copy the <code>istream</code> instances we returned.</p>
<p>References are often used for arguments and return values in order to avoid copies (when copying is an expensive operation, like copying a big struct, or simply not possible, like an <code>istream</code>) and allow modification of the lvalue they refer to.</p>
<p>When we have <code>int f(int x) { ... }</code> and we run <code>f(n)</code>, a copy of <code>n</code> is created and in <code>f</code>, <code>x</code> refers to that copy (this is why <code>n</code> is not modified).</p>
<h1 id="section-8">3/6/14</h1>
<p>An array is a set of homogenous values.</p>
<p>Arguments in C++ are passed by value, but we can fake passing by reference by using reference types.</p>
<p>Functions in C++ accept arrays in much the same way as in C: <code>int f(int a[])</code>.</p>
<p>THe <code>main</code> function has two possible prototypes:</p>
<pre><code>int main(); // note that we didn&#39;t need to use void
int main(int argc, char *argv[] );</code></pre>
<p>If we use the second form, <code>argc</code> is the length of <code>argv</code>, and <code>argv</code> is an array of strings representing each command line argument. <code>argc</code> is always non-zero, since there is always at least one argument.</p>
<p>The first element of <code>argv</code> is the name of the current program that is running. For example, <code>./a.out</code>.</p>
<p>;wip: heap stuff, maybe check the course outline</p>
<h1 id="section-9">5/6/14</h1>
<h2 id="preprocessor">Preprocessor</h2>
<p>The <strong>preprocessor</strong> changes the code before it actually gets to the compiler. It can do several types of manipulations to source code files.</p>
<p>The preprocessor can be used for many possible things, but is mainly used for substitution, file inclusion, and conditional inclusion.</p>
<p>The preprocessor is controlled via preprocessor directives. These are just lines that start with <code>#NAME_OF_DIRECTIVE</code> with no preceding whitespace, and are followed by the arguments to the directive.</p>
<p>The <code>#define VARIABLE ...</code> directive replaces all instances of <code>VARIABLE</code> with <code>...</code>, where <code>...</code> can be anything. To represent multiple lines, use a backslash at the end of the line.</p>
<p>The <code>-DVARIABLE=&quot;...&quot;</code> command line flag to <code>g++</code> accomplishes the same purpose without having to modify the source - these are defines that are processed before the preprocessor looks at the file. We use it as <code>g++ -DA=1 -DB=2 -DC=3 file.cc</code>.</p>
<p>That said, don't use <code>#define</code> whenever possible. For enumerations, use <code>enum</code>, and for functions that need to be fast, use the <code>inline</code> keyword to automatically inline the function: <code>RETURN_TYPE inline NAME(...)</code>. This directive is useful for debugging flags to turn on debugging features in the program.</p>
<p><code>#define VARIABLE</code> defines <code>VARIABLE</code> to be the empty string. This simply defines the variable but gives it a blank value.</p>
<p>This is often used with the <code>#ifdef VARIABLE</code> and <code>#ifndef VARIABLE</code> directives, which check if <code>VARIABLE</code> is defined and include code accordingly.</p>
<p>The <code>#include</code> directive works much line in C, but for standard library paths we can drop the <code>.h</code> suffix - it is <code>#include &lt;iostream&gt;</code> rather than <code>#include &lt;iostream.h&gt;</code>. As usual, we include relative to the current directory with <code>#include &quot;some_file.h&quot;</code>.</p>
<p>If we use <code>#include</code> on the same file twice, it will include that file twice. So if we have a file with some definitions, including it twice will result in a double definition and an error. We can avoid this by using the following pattern wherever we have a file that needs a library:</p>
<pre><code>#ifndef __LIBX__ // double underscores is standard naming convention
#include &lt;libx&gt;
#define __LIBX__
#endif</code></pre>
<p>Now whenever we include a file, it will set a preprocessor variable, so when we encounter another inclusion of the same file that uses this pattern, it is not incuded again. This is a part of good coding style and is required for all inclusions from now on.</p>
<p>The <code>#if EXPRESSION</code> directive and its corresponding <code>#else</code> and <code>#elseif EXPRESSION</code> and <code>#endif</code> operator allow us to include code depending on the value of <code>EXPRESSION</code>. <code>EXPRESSION</code> supports all of the operators as C++ source code, but the operands must be integers or characters.</p>
<p>This is often used to make code cross platform:</p>
<pre><code>#define UNIX 0
#define WINDOWS 1
#define OS UNIX

int main() {
    #if OS == UNIX
    // compatibility stuff here
    #elseif OS == WINDOWS
    //compatiility stuff here
    #else
    // default case
    #endif
}</code></pre>
<p>Also, we can use <code>#if 0</code> to make a block that will never be included. This is useful for commenting out the body of the directive, especially where block comments don't work when there are nested block comments.</p>
<p>The <code>cassert</code> library adds assertions, much like those in C. After using <code>#include &lt;cassert&gt;</code>, the <code>assert(EXPRESSION)</code> or <code>assert(DESCRIPTION_STRING, EXPRESSION)</code> function can be used.</p>
<p>A program split over multiple files can be written in such a way that each file can be compiled separately. Each module should have an interface (header file) and implementation (source file).</p>
<p>A function prototype is a signature associated with a return type. For example, <code>int v(int x, string y)</code>. A signature is the types of the arguments of a function, such as <code>v(int, string)</code> (the parameter names are optional).</p>
<p>We can overload <code>operator+</code> and other functions to implement functionality:</p>
<pre><code>struct Vector {
    int x;
    int y;
}

Vector operator+(const Vector &amp;a, const Vector &amp;b) {
    Vector v;
    v.x = a.x + b.x;
    v.y = a.y + b.y;
    return v;
}</code></pre>
<h2 id="linking">Linking</h2>
<p>For many projects, we can just compile them with <code>g++ *.cc</code>. However, this only works well if all the source files are part of the project. We can also simply specify every file to compile: <code>g++ main.cc vector.cc</code>.</p>
<p>For large projects, it can take hours just to compile all the files. Separate compilation means that we can recompile only the parts that we changed, and in this way save a lot of time.</p>
<p>The linker is the program that runs after the compiler in the compilation chain. It combines all the compiled files together into a single executable. The linker in Linux is called <code>ld</code>.</p>
<p>Compilation results in an object file, which has the code, a list of what symbols it expects, and which it provides. They are conventionally stored in &quot;*.o&quot; files. The linker resolves these names together in a way that allows all the requirements to be satisfied.</p>
<p>The <code>-c</code> command line option (used like <code>g++ -c FILE</code>) allows us to compile without linking. This results in the object file, and the linker is not invoked at all.</p>
<p>An object file can be directly linked, so we don't need to compile the source again for that file. For examplle, if we compiled &quot;vector.cc&quot; into <code>vector.o</code>, then our compilation command would change from <code>g++ main.cc vector.cc</code> to <code>g++ main.cc vector.o</code>, and G++ would use the object file instead of compiling <code>vector.cc</code> again.</p>
<p>We should never have global variables in headers (<code>global int n</code>). This is because global variables are declarations and definitions (since they reserve space for the variable), so there would be multiple definitions if we included the header more than once. Instead, we use <code>extern int n</code> to only declare and not define the variable. ;wip: C++ globals</p>
<h1 id="section-10">10/6/14</h1>
<p>Another advantage of separable compilation is the ability to compile the source file and leave the header file uncompiled</p>
<p>We should never put <code>using namespace std;</code> in a header file. This is because it brings in a lot of names into the current namespace, like <code>cin</code> and <code>endl</code>, which the client that is including the file may not want. As a result, we should only use this in programs that will not be included by clients, and use <code>std::string</code> and similar in header files.</p>
<h2 id="classes">Classes</h2>
<p>Using classes, we can put functions directly inside a struct.</p>
<p>A class is basically just a struct that can contain functions. Every struct is therefore a class.</p>
<p>The <code>class</code> keyword is also available, and it behaves a lot like <code>struct</code>, but has some slightly different behaviour that will be discussed in detail later.</p>
<p>An <strong>object</strong> is an instance of a class. A <strong>member function</strong> or <strong>method</strong> is a function inside a class. <code>grade</code> is therefore a method of <code>Student</code>.</p>
<pre><code>struct Student { // class declaration
    int assignment_grade;
    int midterm_grade;
    int final_grade;
    float grade() { // grade is a function that is associated with Student, so we want to put it inside the struct
        return assignment_grade * 0.4 + midterm_grade * 0.2 + final_grade * 0.4; // we can use the fields of the class instance just like normal variables
        // when we call this below, `assignment_grade` refers to `s.assignment_grade`, and so on
        // the fields are taken from the instance the method was called on, so if we called `some_other_student.grade()`, `assignment_grade` would refer to `some_other_student.assignment_grade` instead, and so on
    }
}

int main() {
    Student s = {80, 50, 70}; // `s` is now an instance of `Student`
    std::cout &lt;&lt; s.grade() &lt;&lt; std::endl; // call the `grade` method
}</code></pre>
<p>We saw the same dot syntax before when we used <code>some_string.length()</code> or <code>cin.ignore()</code>.</p>
<p>The difference between functions and methods is that methods have a hidden parameter called <code>this</code>. <code>this</code> is implicitly inserted before the first actual parameter, and contains a pointer to the object on which the method was called. Functions do not have this hidden parameter.</p>
<p>So in <code>grade</code>, the value of <code>this</code> is the same as <code>&amp;s</code> in <code>main</code>. As a result, we can also write the grade mthod as follows:</p>
<pre><code>struct Student {
    int assignment_grade;
    int midterm_grade;
    int final_grade;
    float grade() {
        return this-&gt;assignment_grade * 0.4 + this-&gt;midterm_grade * 0.2 + this-&gt;final_grade * 0.4;
        // when we write `assignment_grade` directly, it is exactly the same as `this-&gt;assignment_grade`
        // we might use `this-&gt;` when we have a local variable or parameter with the same name as a class variable, because the local variable or parameter would shadow the class variable and there would be no other way to refer to it
        // it is good coding style to always use `this-&gt;` to make it explicit that it is a class variable
    }
}</code></pre>
<h3 id="initializing-objects">Initializing Objects</h3>
<p>In C-style initialization, we initialize objects in a certain way: <code>Student someone = {A, B, C};</code>. The disadvantage is that this is very inflexible, and we can't really add any custom behaviour associated with object initialization. For example, if we created a database object, we probably also want it to open a database connection.</p>
<p>In C++, we have a <strong>constructor</strong> (&quot;ctor&quot; for short) method that is used to initialize an object. For example:</p>
<pre><code>struct Student { // class declaration
    int assignment_grade;
    int midterm_grade;
    int final_grade;
    Student(int a_g = 0, int m_g = 0, int f_g = 0) { // the constructor is the function that has the same name as the class
        // the constructor has no return type because it should always return a new instance of `Student`
        this-&gt;assignment_grade = a_g;
        this-&gt;midterm_grade = m_g;
        // we can now do anything here to initialize things
    }
    float grade() {
        return assignment_grade * 0.4 + midterm_grade * 0.2 + final_grade * 0.4;
    }
}

int main() {
    Student s(90, 80, 70); // this calls the constructor instead of initializing the struct directly
    Student other = Student(90, 80, 70); // this is exactly equivalent to the definition above
    Student *heapy = new Student(90, 80, 70); // this allocates the `Student` object on the heap and gives a pointer to it, so we can do `heapy-&gt;grade()` and such
    
    // this is the same syntax we saw before with `ifstream` objects.
    // we also cannot call the constructor of an object that is already created, so `other.Student(1, 2, 3)` is invalid
    
    Student someone(); // THIS IS A FUNCTION DEFINITION, NOT A STRUCTURE DEFINITION - WE CANNOT USE PARENTHESES WHEN THERE ARE NO ARGUMENTS TO THE CONSTRUCTOR
    Student someone; // this is how we use default values for all the arguments instead
}</code></pre>
<p>The advantage of contructors is that we can associate arbitrary behaviour with the creation of an object. Also, we can use default values for parameters of constructors, or even function overloading on constructors, to allow different ways to initialize the object.</p>
<h1 id="section-11">12/6/14</h1>
<p>If no constructor is specified in a class, then there is a default constructor that calls the default constructor for each of the fields, if they exist. Most of the time, this doesn't do anything. This is just a constructor that accepts no arguments.</p>
<p>So if we define any of our own constructors, the default constructor will no longer exist. To get the same behaviour, we can define a zero-argument constructor.</p>
<p>If we specify our own constructor for a class, we can no longer use C-style initialization on it - <code>Vec v = {1, 2}</code> will give an error.</p>
<p>Initializers are not allowed for structure fields - we can't initialize a field directly inside a struct.</p>
<p>Objects are created on the stack if they are defined with <code>Vector v(5, 6);</code> or <code>Vector v = Vector(5, 6)</code>, and on the heap if we use <code>Vector v = new v(5, 6)</code>.</p>
<p>Whenever we create an object, first the memory is allocated for it in the heap or stack depending on how it is created. Then, the fields are initialized using the default constructors for the fields (for things like <code>int</code>, often by setting them to 0), and finally the constructor body runs.</p>
<p>We can initialize constant and reference values using a <strong>member initialization list</strong>. This is a list that comes after a constructor declaration and a colon that allows us to bypass initializing the specified fields using the default constructors, and call the default constructors with the arguments we want:</p>
<pre><code>struct Something {
    int normal; // this is just a normal struct field
    const int some_constant; // this must be initialized, because we can&#39;t change it later
    int &amp;some_reference; // this also must be initialized, because it must always refer to something
    Something(int c, int &amp;r): normal(5), some_constant(c), some_reference(r) { // member initialization list calls the default constructors, but with values that we specify
        // it is too late to initialize them in the constructor body, because they should be initialized (and for constants, made fixed) as soon as they are defined
    }
}</code></pre>
<p>This is also useful for shortening constructors, because we can just initialize the fields of a structure using a member initialization list and leave the body blank.</p>
<p>In a member initialization list, the name outside the parentheses must be a field, and the value inside the parentheses can be any valid expression, like globals and scope variables, or fields that have already been initialized.</p>
<pre><code>struct S {
    int n;
    Something(int n): n(n) {} // in the member initialization list, it is valid to use the same name because the name outside the parentheses is searched for in the fields, not as an expression
} // it is also more efficient to use these member initialization lists than to assign them values inside the constructor body, because we don&#39;t need to call the default constructors any more</code></pre>
<p>We use member initialization lists because they are the only way to initialize constants/references, because they are shorter and cleaner than assigning in the constructor body, and because it can be more efficient.</p>
<p>Fields are initialized in the order that they are declared in the struct, regardless of their order in the member initialization list. However, we should generally keep them in the same order to avoid a compiler warning.</p>
<p>There is also a <strong>copy constructor</strong> that is called when we make a copy of a struct:</p>
<pre><code>Student a(60, 70, 80);
Student b = a; // this calls the default copy constructor</code></pre>
<p>There is a default copy constructor, which just makes a shallow copy of <code>a</code> (a field-for-field copy).</p>
<p>We can define a custom copy constructor as follows:</p>
<pre><code>struct Student {
    int assignment_grade;
    int midterm_grade;
    int final_grade;
    float grade() {
        return this-&gt;assignment_grade * 0.4 + this-&gt;midterm_grade * 0.2 + this-&gt;final_grade * 0.4;
    }
    Student(const Student &amp;other): assignment_grade(other.assignment_grade), midterm_grade(other.midterm_grade), final_grade(other.final_grade) {} // the reference should be constant since it usually doesn&#39;t need to be modified
}</code></pre>
<p>The custom copy constructor is often useful when we have dynamic memory or want a deep copy. For example, we want a deep copy for a linked list to avoid sharing the same linked list nodes for multiple starting lists, which would make freeing the memory very difficult:</p>
<pre><code>struct Node {
    int data;
    Node *next;
    Node(const Node &amp;other): data(other.data), next(other.next ? new Node(other.next) : NULL) {};
}</code></pre>
<p>So every class has a default constructor, a default copy constructor, a copy assignment operator, and a destructor.</p>
<h1 id="section-12">18/6/14</h1>
<p>The <code>delete</code> keyword can be used to destroy an object on the heap given its pointer. If we defined something like <code>int *x = new int(5)</code> (a pointer to an integer on the heap), then afterwards we can destroy it using <code>delete x;</code>.</p>
<p>If we have an array on the heap like <code>int *a = new int[20]</code>, then we must use <code>delete [] a</code> to properly destroy the array. Using <code>delete</code> without the <code>[]</code> might result in the wrong thing being destroyed.</p>
<p><code>delete</code> cannot be used with stack memory. It wworks in a way conceptually similar to the <code>free</code> function in C.</p>
<p>An object on the stack is destroyed when it goes out of scope (for example, an object created inside a function would be destroyed when the function returns, unless it is returned).</p>
<p>An object on the heap is destroyed when we explicitly destroy it using <code>delete</code>. Otherwise the object remains in memory.</p>
<p>Objects have methods called <strong>destructors</strong> that get called when an instance of the object gets destroyed. We can specify a custom destructor as follows:</p>
<pre><code>struct Node {
    int data;
    Node *next;
    Node(const Node &amp;other): data(other.data), next(other.next ? new Node(other.next) : NULL) {};
    ~Node() {
        delete next; // since `next` is on the heap, the default destructor wouldn&#39;t destroy it and there would have been a memory leak
        // a destructor should never throw any exceptions
        // we can do other cleanup stuff here, like closing database connections, destroying heap objects, or other things
    }
}</code></pre>
<p>There is also a default destructor, which just calls the destructors on the individual fields of the object.</p>
<p>Header files should contain function declarations, structure declarations, and things like constants. Source files should actually implement the functions.</p>
<p>Up to this point we have been defining the whole class in one big struct declaration and putting implementation together with declarations. This is not the ideal way to go about it - it is possible to separate the two. The following would go into the header file:</p>
<pre><code>#ifndef __NODE_H__
#define __NODE_H__
struct Node {
    int data;
    Node *next;
    Node(int data, Node *next); // constructor
    Node(const Node &amp;other); // copy constructor
};
#endif</code></pre>
<p>And the following would go in the source file:</p>
<pre><code>#include &quot;Node.h&quot;

Node::Node (int data, Node *next) : data(data), next(next) {}

Node::Node (const &amp;other) : data(other.data), next(other.next ? new Node(*other.next) : 0);</code></pre>
<p>The <code>a::b</code> is the <strong>scope resolution operator</strong>. It resolves the identifier <code>b</code> in the context of <code>a</code>. For example, if <code>a</code> is a struct, then <code>b</code> would be resolved as a field of <code>a</code>. So <code>Node::Node</code> would let us define functions inside the <code>Node</code> struct, even though we are lexically outside of the struct declaration.</p>
<p>When we do an assignment <code>a = b</code>, we are actually using the <code>=</code> operator on <code>a</code> and <code>b</code>. This works a lot like the copy constructor, but the <code>operator=</code> is now a method of <code>a</code> rather than an overloaded function. We can use this to provide custom behaviour when someone assigns to an instance of a particular class:</p>
<pre><code>struct Node {
    int data;
    Node *next;
    Node(int data, Node *next); // constructor
    Node(const Node &amp;other); // copy constructor
};

Node &amp;Node::operator=(const Node &amp;other) {
    delete this-&gt;next; // delete the rest of the list to prevent memory leaks
    this-&gt;data = other.data; // set this node to be the new node
    this-&gt;next = other.next ? new Node(*other.next) : 0;
    return *this; // the return value is a pointer to what the new value of the variable is
    // we might also assign `this.next` to a pointer variable and delete it last in case the copying of `other.next` failed for whatever reason
}</code></pre>
<h1 id="section-13">19/6/14</h1>
<p>The copy and swap technique is a way of implementing assignment that uses the copy constructor to simplify assignment</p>
<pre><code>struct Node {
    void swap(Node &amp;other) { // this swaps the values of this instance and a specified other instance
        int *data = this-&gt;data;
        this-&gt;data = other.data;
        other.data = data;
        Node *next = this-&gt;next;
        this-&gt;next = other.next;
        other.next = next;
    }
    
    Node &amp;operator=(Node other) {
        Node t = other; // using the default copy constructor to make a copy of `other`
        this-&gt;swap(t); // set the fields to the temporary value
        return *this;
        // this does not leak memory because `t` is on the stack and the destructor is called when it goes out of scope
    }
}</code></pre>
<p>The rule of 3 states that if we need any one of the copy constructor, desctructor, or <code>operator=</code>, we probably need to write all three.</p>
<p>Whenever we declare one of the <code>operator+</code> or similar member functions, we get the <code>this</code> parameter inserted implicitly and <code>this</code> acts as the left hand side of the operation. This allows us to implement a lot of different functionality:</p>
<pre><code>struct Vec {
    int x, y;
    Vec operator+(const Vec &amp;o) { return Vec(this-&gt;x + other.x, this-&gt;y + other.y); }
    Vec operator*(const int k) { return Vec(this-&gt;x * k, this-&gt;y * k); } // this works for expressions of the form `SOME_VEC * SOME_INT`
}

Vec operator*(const int k, const Vec &amp;v) { // to allow things like `SOME_INT * SOME_VEC`, we must use another function
    return v * k; // this calls the member function
}</code></pre>
<p>Most operators can be implemented as either standalone functions (like the second <code>operator*</code> in the above example), or as member functions (like <code>operator+</code> in the above example).</p>
<p>Some operators can only be implemented as methods: <code>operator=</code> (assignment), <code>operator[]</code> (subscripting), <code>operator-&gt;</code> (dereferencing field reference), <code>operator()</code> (function call), <code>operator T()</code> (<code>T</code> is a type, and defines implicit conversion, like <code>operator void*</code> allows us to implicitly convert the object to a void pointer). <code>operator=</code> must be a member function because there is already a default <code>operator=</code> member function, so we must override the member function itself.</p>
<p>The following code results in a compilation error:</p>
<pre><code>struct Vec {
    int x, y;
    Vec(const int x, const int y): x(x), y(y) {}
}

int main() {
    Vec v[3]; // this is an error because we didn&#39;t initialize the vectors in `v`
    Vec v[3] = {Vec(0, 1), Vec(1, 2), Vec(2, 3)}; // this is correct
    Vec *w = new Vec[5]; // we cannot use the above technique because it is on the stack
    // we could implement a default constructor in `Vec`, or we could just deal with pointers to objects instead
    Vec **w = new Vec *[10];
}</code></pre>
<p>Suppose we have a constant argument: <code>void f(const Student &amp;s) { BODY }</code>. Inside of <code>BODY</code>, we cannot modify the fields of <code>s</code> or assign a new value to it. Additionally, we cannot call any methods on <code>s</code> unless those methods specify that they do not modify fields too.</p>
<p>We can specify that a method will not change its instance by using <code>const</code>: <code>float Student::grade const () { BODY }</code>. If specified, the compiler checks that the method does no modify fields, and if it doesn't, we can call the methods when their instances are constant, in addition to when their instances are not.</p>
<p>We can also define that a field is exempt from the compiler checking for fields being modified in a <code>const</code> object. If we define a field like <code>mutable int x;</code>, then we can actually change it even when its instance is constant.</p>
<p>A <strong>static field</strong> is a field of a class rather than a method of an instance of a class. So all instances of the class would share the same static field, so modifying it would change its value for all instances. For example:</p>
<pre><code>struct Vec {
    static std::string __doc__; // static field
    int assignment_grade, midterm_grade, final_grade;
    
    static something() { // static method
        // we can access static fields or call other static methods here, but not instance fields or methods
    }
}

std::string Vec::__doc__ = &quot;Information about this class&quot;; // we still cannot define values in the declaration of a structure</code></pre>
<p>A static method does not depend on instances, so it has no <code>this</code> parameter. The difference between a function and a method is that a method has a <code>this</code> parameter. Since a static method is not, it is technically a static member function rather than a method.</p>
<p>Inside a function, <code>static</code> in a variable declaration means that the variable keeps its value in between function calls, like a global variable that can only be accessed within the function.</p>
<h2 id="design-patterns">Design Patterns</h2>
<p>Design patterns are commonly occurring patterns of problems and good solutions to these problems in object oriented programming.</p>
<h3 id="singleton-pattern">Singleton pattern</h3>
<p>Problem: we have a class <code>c</code>, and we want only one instance of <code>c</code> to ever be created no matter how many times we attempt to create an instance.</p>
<p>We can do this by declaring a static field of <code>c</code> as a flag, and in the constructor, setting the flag to prevent future instances from being created:</p>
<pre><code>struct Student {
    static Student *instance = NULL;
    Student() {
        //wip
    }
}

bool Student::created = false;</code></pre>
<hr>
<p>Copyright 2013 Anthony Zhang</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>