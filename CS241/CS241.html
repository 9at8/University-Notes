<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>CS241 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso.light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>
function highlight() { // highlight all code blocks using HighlightJS
  var code_blocks = document.getElementsByTagName("code");
  for (var i = 0; i < code_blocks.length; i++)
    hljs.highlightBlock(code_blocks[i]);
}
</script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body onload="highlight()">
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/Résumé.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="http://www.linkedin.com/pub/anthony-zhang/8b/aa5/7aa" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.mesecons.net/">mesecons</a></li>
    <span class="divider"></span>
    <li><a href="http://www.autohotkey.net/~Uberi/">autohotkey.net</a></li>
  </ul>
<h1 id="cs241">CS241</h1>
<p>Foundations of Sequential programs.</p>
<pre><code>Instructor: Bradley Lushman
ISA: Sean Harrap
Email: CS241@uwaterloo.ca
Web: http://www.student.cs.uwaterloo.ca/~cs241</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}_P)}
\]</span></p>
<h1 id="section">6/1/15</h1>
<p>Weekly assignments, 11 total.</p>
<p>A sequential program is an &quot;ordinary&quot; program - one that is not concurrent, parallel, or so on. Sequential programs only do one thing at a time - they are signle threaded.</p>
<p>As this course focuses on the foundation, we will be starting from the hardware, and figure out how sequential program works from there.</p>
<p>This course uses a simulated MIPS machine for the assignment. At the end we will be able to run a relatively complex C-like language that can run on the MIPS machine.</p>
<h2 id="binary-and-hexadecimal-numbers">Binary and Hexadecimal Numbers</h2>
<p>Refer to earlier notes for background.</p>
<p>A bit is a binary digit - a 0 or a 1. A nibble is a collection of 4 bits. A byte is a collection of 8 bits, although historically it could be any number needed to hold a signle character - sometimes 7. A word is the a machine-specific grouping of bits - the number of bits in an address on the computer.</p>
<p>In this course we will be using a 32-bit architecture.</p>
<p>Data in a computer's memory could mean anything - it is simply data.</p>
<p>There are a number of conventions for representing negative numbers in binary. The <strong>sign magnitude</strong> convention has the leftmost bit of a binary number represent whether it is negative. Although this system is simple, it's difficult to do math with since we have to treat the first bit separately for a lot of operations. Plus, there's two representations for the number 0 - <code>00...00</code> and <code>10...00</code>.</p>
<p>The <strong>one's complement</strong> convention has positive numbers written normally, and negative numbers are their magnitude with their bits flipped. This works better for certain operations, but there is still two 0 representations, which complicates things unnecessarily.</p>
<p>The <strong>two's complement</strong> convention has positive numbers written normally, and the negative numbers are simply their magnitude with their bits flipped and 1 added. The advantage of this system is that the first bit still denotes the sign. Plus, there is only one representation for 0, and operations like addition work as usual, modulo <span class="math">\(2^n\)</span>.</p>
<p>To find the numerical value of a number represented using <span class="math">\(n\)</span>-bit two's complement, we first check the sign bit. If 0, then we simply convert binary to a non-negative number as usual. Otherwise, we convert the binary to a non-negative number as usual, and subtract <span class="math">\(2^n\)</span> from that result to get a negative number as a result.</p>
<p>To quickly negate a binary number in two's complement quickly, flip all the bits and add 1. This allows us to quickly convert negative numbers to binary and hex.</p>
<p>For 3-bit numbers, each binary string, in ascneding order, represents 0, 1, 2, 3, -4, -3, -2, -1.</p>
<p>A byte could also potentially be a character. Characters have multiple possibble encodings, such as unicode and ASCII. ASCII is a 7-bit code (for historical reasons, in order to avoid sending expensive bits) that has representations for most America-centric characters, although there are 8-bit extensions like those by IBM that add multilingual characters. In an 8-bit byte world, the eighth bit is 0 in standard ASCII. We will be using ASCII in this course to represent characters.</p>
<p>A byte could also be part of a data structure, or even part of an instruction. In this course, we have 32-bit instructions. A byte could also just be garbage - memory that isn't currently being used for anything and has no meaning.</p>
<p>The idea is that the meaning of a byte is whatever meaning we assign to it, and we have to remember what each little chunk of memory we're using actually means.</p>
<h1 id="section-1">8/1/15</h1>
<h2 id="the-machine">The Machine</h2>
<p>Computer programs operate on data, and are theselves data. Historically, the program code was stored in special memory such as punch cards or switches, and it operated on separate data memory. This was known as the Harvard architecture.</p>
<p>John Von Neumann proposed that we could just put the program code in the same memory as the rest of the data. This is known as the Von Neumann architecture. The result of program code being treated as just a program was that we can now write programs that operate on programs, even themselves. For example, operating systems, compilers, and viruses that modify existing code to do what it wants.</p>
<p>Machine language is specific to a particular processor type, like MIPS, ARM, and x86. In this course we will be using a simplified version of MIPS.</p>
<h3 id="architecture">Architecture</h3>
<p>The MIPS machine consists of a CPU and main memory (RAM), connected via a bus. The CPU contains the ALU, the registers, and the control unit.</p>
<p>The ALU (arithmetic logic unit) is responsible for doing arithmetic and logic, for doing things like addition and subtraction.</p>
<p>Registers are simply small pieces of memory that are really fast to work with since they are so close to the CPU - they are the fastest pieces of memory we have, ad we have relatively little of it. Most instructions can actually only work directly on registers, so we usually need to bring data from the main memory into registers before we work on them.</p>
<p>There are the 32-bit <strong>general purpose registers</strong> R00 to R31, which can be used for general purpose data storage. In our assembly code, we refer to them with $0, $1, $2, and so on, until $31. However, R00 is always 0, and R30 (stack pointer/frame pointer) and R31 (return pointer) have other purposes in control flow by convention.</p>
<p>The <strong>program counter register</strong> is responsible for keeping track of where we are in the main memory for executing code. It holds an address to the next instruction to run while the current instruction is running. Some commands manipulate this register, so we can actually do control flow by modifying this in a certain way.</p>
<p>By convention, we guarantee that a certain address in memory like 0 always starts off with valid code, and then we initialize PC to that location. So when we start the machine, it will start executing instructions from that location and go onwards.</p>
<p>The <strong>instruction register</strong> IR is closely related to PC. Instead of holding the address of the next instruction, it holds the current instruction itself (not its address).</p>
<p>The HI/LO registers are a pair of registers that are useful for storing the output of operations like division, which results in the quotient and the remainder, stored in this pair of registers. They cannot be accessed directly, but are implicitly used by certain instructions.</p>
<p>The <strong>memory address register/memory data register</strong> MAR and MDR are used for working with memory. MAR is used to store the desired address for us to load, and MDR is used to store the loaded value.</p>
<p>MAR/MDR, PC, and IR are all hidden registers - they are not visible to our programs.</p>
<p>The control unit decodes instructions, and dispatches them to the rest of the computer to actually execute them.</p>
<p>There are many types of memory, such as registers, CPU cache, main memory, disk memory, and network memory, in order of increasing distance from the CPU. The closer the memory to the CPU, the faster it is to work with.</p>
<p>The main memory (RAM) is a large amount of memory stored away from the CPU, and communicates with the CPU over the bus (physically, a bunch of wires). It can be thought of as a huge array of <span class="math">\(n\)</span> bytes. Each byte in the RAM has an address, one of <span class="math">\(0, \ldots, n - 1\)</span>.</p>
<p>Since a word in MIPS is 32 bits (4 bytes), and we can only access memory on word boundaries, we can only get or set addresses that are multiples of 4.</p>
<p>RAM access is much slower than register access - as much as three orders of magnitude. Usually, data in RAM must be transferred to registers before it can be used.</p>
<h3 id="instructions">Instructions</h3>
<p>It takes 5 bits to encode the 32 general purpose registers (we can't directly use the other registers as memory). Therefore, we need 15 bits to encode two source registers and a destination register. That means we have 17 bits left to encode the rest of our instruction.</p>
<p>There are actually only two instructions for working with RAM - load word and store word.</p>
<p>If we do something invalid like dereferencing an invalid address, our machine will simply crash. Real-world machines have machine exceptions to deal with this.</p>
<p>The CPU essentially works as follows:</p>
<pre><code>PC &lt;- 0
loop:
    IR &lt;- MEM[PC]
    PC &lt;- PC + 4
    decode and execute the instruction in IR</code></pre>
<p>A program gets executed by getting called by a <strong>loader</strong>, which puts the program into memory (from somewhere like the hard drive) and sets PC to the first instruction in the program. This is the role of the operating system when opening a program.</p>
<p>When our program wants to end, we want to return control flow back to the loader. This is done by setting PC to the next instruction of the loader after the one that started our program.</p>
<p>Conventionally, R31 is set to the address of the next instruction in the loader, by the loader - the address we need to jump to in order to return to the loader. Therefore, in our program code, we simply set PC to R31 in order to jump back to the loader. This looks something like <code>jr $31</code> in MIPS assembly.</p>
<p>Example code to add value in register 5 to register 7, then return:</p>
<pre><code>RAM LOCATION  BINARY                                   HEX         MEANING
------------  ---------------------------------------  ----------  --------------
00000000      0000 0000 1010 0111 0001 1000 0010 0000  0x00A71820  add $3, $5, $7
00000004      0000 0011 1110 0000 0000 0000 0000 1000  0x03e00008  jr $31</code></pre>
<p>The resulting code is therefore the binary representation of the hex value <code>00A7182003e00008</code>.</p>
<p>To store a literal value into a register, we can use the <strong>load immediate and skip</strong> (<code>lis</code>) instruction. Essentially, ;wip</p>
<p>Note that ASCII is a mapping between characters and binary, and ASCII values are not binary. For example, <code>0010000100110101</code> is simply an ASCII string of 1 and 0, while <code>!5</code> would be the ASCII encoding the previous string would result in if encoded in binary.</p>
<p>To read the ASCII representation of a given binary file, use <code>xxd &lt;filename&gt;</code> or <code>hexdump -Cv &lt;filename&gt;</code>, where <code>&lt;filename&gt;</code> is the path to the file to represent. <code>xxd -bits</code> shows binary, and <code>xxd -cols n</code> shows <code>n</code> bytes per line.</p>
<h1 id="section-2">13/1/15</h1>
<h2 id="assembly-language">Assembly Language</h2>
<p>Instead of writing in hex or binary, which is very tedious to convert, we can simply use the mnemonics like <code>add</code> and <code>lis</code>, and have a program (the <strong>assembler</strong>) translate it to binary for us. This reduces our chances of error and makes programming much simpler.</p>
<p>Essentially, one line of assembly is one word, generally one machine instruction like <code>jr</code>. There are also lines that are <strong>directives</strong>, which are instructions to the assembler to do something, rather than the machine. For example, the <code>.word X</code> directive tells the assembler that at the current point, we want the resulting binary output to have the specified literal value <code>X</code>.</p>
<p>The above code example could therefore be written as:</p>
<pre><code>add $3, $5, $7
jr $31</code></pre>
<p>Some instructions unconditionally modify PC, like <code>jr</code> - these are known as jumps. Some instructions conditionally modify PC, like <code>bne</code> - these are known as branches. Generally, the modification is given in terms of the number of words to move by. Note that it is possible to give negative values.</p>
<p>A quick way to zero a register is <code>add X, $0, $0</code>, where <code>X</code> is a register. <code>lw A, i(B)</code> loads the value in memory at address specified by register <code>B</code> with offset specified by literal number <code>i</code>, storing the result in register <code>A</code>. <code>sw A, i(B)</code> does the opposite - writing the value of <code>A</code> in memory instead of reading from it.</p>
<p>The <code>mult A, B</code> instruction has a somewhat unusual form - it only has the multiplicands, and no output parameter. Instead, since multiplication can result in a 64-bit number, the answer is is stored in the HI and LO registers, the LO bits having the lower 32 bits and the rest in HI. To get values out of HI and LO, we have <code>mflo A</code>, which gets the value of LO and stores it in the register <code>A</code>, and <code>mfhi A</code>, which does the same thing, but for HI.</p>
<p>Division is similar. After dividing, the quotient is in LO, and the remainder is in HI.</p>
<p>Counting the number of instructions to jump by is tedious and error-prone. We can mitigate this using <strong>labels</strong>. For example:</p>
<pre><code>some_label: add $1, $2, $3
add $4, $5, $6
some_other_label: .word 0x12345678</code></pre>
<p>Labels are assembler features that allow us to specify a specific location and use it later on. In any jump or branch instruction, we can simply write the label name rather than the offset, like <code>bne, $2, $0, some_label</code>, which will jump to the location specified by <code>some_label</code> if and only if <code>$2</code> is non-zero.</p>
<h1 id="section-3">15/1/15</h1>
<p>We want to be able to write functions in MIPS assembly - blocks of reusable code that we can call with parameters and have control returned to us afterward.</p>
<p>Our procedures need to guarantee that the registers will remain unchanged - after calling the function, the values of registers will be guaranteed to be as they were before calling. Otherwise, subfunctions will clobber their caller's register values.</p>
<p>The MIPS loader initializes R30 to the address of the word just past the last word in memory - this is the stack pointer, and we are using the end of the memory as a stack that grows downward. This convention allows us to use RAM as a stack for storing our calling contexts - by decreasing the stack pointer, we reveal more memory we can use, and by increasing the stack pointer, we can deallocate that memory.</p>
<p>We will allocate blocks of memory on the stack that we use as stack frames. Stack frames store register values and the return address.</p>
<p>When we call a function, we allocate a frame and store all our register values in it for safekeeping, after which we can use the registers as we want in the function. When the function returns, we restore the values of the registers, and then jump back to the return address.</p>
<p>When we want to return from a function, we need to set the value of PC to after the jump that called the function - the very next instruction after the function call. Since functions can be called from multiple places, the caller must give the return address.</p>
<p>There is a &quot;jump and link register&quot; instruction <code>jalr $s</code> that sets R31 to the next instruction (PC), and jumps to the specified address (setting PC to <code>$s</code>). This allows us to store the return address in R31, and jump to the function, all in one operation.</p>
<p>However, we also need to save R31 since <code>jalr</code> will overwrite it. In other words, we will need to store R31 on the stack.</p>
<p>To pass parameters to functions, we can just use registers (documenting what each parameter register is for is very important). If there are more parameters than available registers, it is also possible to store parameters on the stack.</p>
<p>We can also pass back the return value via an agreed-upon register. We might specify that the return value is in R2, for example.</p>
<p>A template for functions can now be defined:</p>
<pre><code>some_func:
; store the registers we will be using on the next free spaces on the stack
sw $2, -4($30)
sw $3, -8($30)

; decrement the stack pointer by the number of bytes used by our stack frame
lis $2 ; $2 is free to use now that we have saved its former value
.word 8
sub $30, $30, $2

; body of the function

; increment the stack pointer again to restore it to its previous value, assuming we didn&#39;t change $3
add $30, $30, $3

; make sure to pop the registers off in reverse order
lw $3, -8($30)
lw $2, -4($30)

jr $31 ; return to the instruction after the one we called the function from</code></pre>
<p>And we can call it as follows:</p>
<pre><code>main:
; body before the function call

; save the value of $31 on the stack to keep our return address
sw $31, -4($30)
lis $31 ; $31 is free to use now that we have saved its former value
.word 4
sub $30, $30, $31

; jump to the function with $31 as the return address
lis $31
.word some_func
jalr $31 ; store the value of PC into $31 as the next instruction, and set PC to $31 - we are storing the return address in $31

; restore the value of $31 back to its original value
lis $31
.word 4
add $30, $30, $31
lw $31, -4($30) ; we do this after we&#39;re done using $31 as a temporary variable

; body after the function call

jr $31 ; return back to the loader</code></pre>
<p>Example procedure:</p>
<pre><code>; sum_1_to_N: adds natural numbers from 1 to N
; Registers:
;     $1 - Value of N
;     $2 - Output sum
sum_1_to_N:
; save the register values on the stack
  sw $1, -4($30)
  sw $3, -8($30)
  lis $1
  .word 8
  sub $30, $30, $1
  
  ; function body
  add $2, $0, $0 ; zero out the output register
  lis $3 ; set R3 to 1
  .word 1
  sum_1_to_N_loop:
    add $2, $2, $1 ; add the current value to the output
    sub $2, $2, $3 ; decrement the value
    bne $2, $0, sum_1_to_N_loop ; break out of the loop if the value is 0
  
  ; restore the values of the registers
  lis $1
  .word 8
  add $30, $30, $1
  lw $3, -8($30)
  lw $1, -4($30)
  jr $31</code></pre>
<h2 id="inputoutput">Input/Output</h2>
<p>To do output, write a word to 0xFFFF000C. The least significant byte will be printed as an ASCII character:</p>
<pre><code>; prints a newline
lis $1
.word 0xFFFF000C
lis $2
.word 65
sw $2, 0($1)</code></pre>
<h1 id="section-4">20/1/15</h1>
<h2 id="the-assembler">The Assembler</h2>
<p>The assembler is a translater, from assembly code to machine code. Any translation process will involve two phases, analysis (understanding the input) and synthesis (producing the output from the understanding of the input).</p>
<p>Our approach is to first group the characters into meaningful tokens, like a label, a hex number, a register, a directive, or so on. Tokenization is done by something known as a <strong>lexer</strong>, which accepts source code and outputs a stream of tokens.</p>
<p>We already have a tokenizer available to us in <code>asm.ss</code> and <code>asm.cc</code>. Our goal is to group tokens into actual instructions if possible - the analysis phase. If there is an error, we must output the string &quot;ERROR&quot; to stderr. The assembled MIPS code is printed to stdout.</p>
<p>To parse labels, occasionally we will have the label definition occur after their usages. To properly assemble this, we need to do things like make an extra pass beforehand to create a symbol table, or put in a placeholder value and fix it after parsing all the labels.</p>
<p>Also note that it is also possible to label the address just past the end of the program, and a line may have more than one label associated with it.</p>
<p>Instructions in MIPS start with a 6 bit opcode, followed by their parameters that specify things like registers and offsets.</p>
<h1 id="section-5">22/1/15</h1>
<p>An OS can be as simple as the following:</p>
<pre><code>repeat:
    p &lt;= the next program to run
    $2 &lt;= loader(p)
    jalr $2
beq $0, $0, repeat</code></pre>
<p>Note that the OS itself is just a program, which means it needs to be in memory as well. Since execution starts at 0x00000000, we need to put the OS at the very beginning of the memory. That means our program cannot occupy the first location in memory.</p>
<p>That also means that the addresses of the labels will not be correct if we load them directly, since the assembler created the machine code assuming addresses start from the beginning of the program (a label at the very beginning of the assembly should result in a value of 0x00000000). If we load our program at offset <span class="math">\(d\)</span>, then we must add <span class="math">\(d\)</span> to the value of each label or reference to a label, like <code>.word some_label</code>. This process is called <strong>relocation</strong> and allows us to load the code anywhere in memory and have it run properly.</p>
<p>Since the machine code is just a stream of bytes, we don't know which words are labels and which are not - the assembler has to give us additional information about what type of thing each word is.</p>
<p>As a result, what most assemblers output is not actually just machine code, but actually <strong>object code</strong> - machine code with additional metadata that lets us load and run the program in a clean way. These assemblers are called <strong>relocatable assemblers</strong>.</p>
<p>Basically, the metadata needed in object files includes the addresses of words that represent label addresses in the code so we can relocate it, plus ;wip</p>
<p>The object file format we will be using is called <strong>MIPS executable relocatable linkable</strong> (MERL), and often has a filename of the form <code>*.merl</code>. It looks like this:</p>
<ol style="list-style-type: decimal">
<li>The literal word 0x10000002, which is the MIPS instruction for <code>beq $0, $0, $2</code>, and skips two words ahead, past the rest of the header.</li>
<li>this means that the object file can also be run as a normal MIPS program, since this value causes it to jump past the header and straight to the code if loaded at address 0x00000000.</li>
<li>It also acts as a sanity check to make sure the file is really a MERL file.</li>
<li>The length of the entire module in bytes as a word - this is the length of the header (12), the machine code, and the relocation table.</li>
<li>The address of the end of the code section in bytes as a word, which is the length of the header (12) and the machine code.</li>
<li>The actual MIPS machine code.</li>
<li>The <strong>relocation table</strong>, which appears after the code returns and has a sequence of entries for different types of relocatables. An entry in the relocation table consists of two words:</li>
<li>The format code - a word representing the type of entry this is. For example, a value of 1 represents that this entry is a relocation entry.</li>
<li>The actual address, which, if this entry is a relocation entry, is the address of a word holding the address of a label. This is relative to the beginning of the header.</li>
</ol>
<h1 id="section-6">27/1/15</h1>
<p>The MERL format could also be written as follows:</p>
<pre><code>; MERL header
beq $0, $0, 2
.word end_of_module
.word end_of_code

;code goes here
add $1, $2, $0

; MERL footer - relocation table
end_of_code:
.word 0x1 ; relocatable address
.word SOME_ADDRESS
; ...
.word 0x1
.word SOME_OTHER_ADDRESS
end_of_module:</code></pre>
<p>The <code>cs241.merl</code> tool accepts a MERL file and a relocation address and outputs MIPS machine code relocated at the desired address, ready to be loaded starting at that offset. The <code>mips.twoints</code> and <code>mips.array</code> tools also support an optional second argument that specifies the address to load the code at.</p>
<p>Relocation is typically done by the loader, automatically. The loader usually has the following structure:</p>
<pre><code>verify(read_word()) # check cookie
end_of_module = read_word()
code_length = read_word() - 12

# load code
p = allocate_RAM(code_length + stack_space)
for i in range(0, code_length, 4):
    RAM[p + i] = read_word()

relocation_table = code_length + 12 # start of relocation table
for i in range(relocation_table, end_of_module, 8):
    format = read_word()
    if format == 1: # we only support format 0x1 for now
        offset = read_word() - 12
        RAM[p + offset] += p - 12 # we subtract 12 since in MERL addresses are relative to the start of the header, and the header wasn&#39;t loaded</code></pre>
<p>When we have multiple files, we might have a function that calls a function in another file. However, the assembler can't assemble this directly since the label of the function isn't defined in the file it's being called from.</p>
<p>We could just append all the code together and then assemble them, which works but is not very good, since that requires the assembly code to be available (in practice, people just want to distribute MERL), and we would need to assemble it possibly multiple times in larger projects.</p>
<p>A better solution is a program that accepts multiple MERL files and properly puts them together into one - the <strong>linker</strong>. We want to put MERL files together without ever forcing it to know about ASM.</p>
<p>First, what we could do is have the assembler ignore unknown labels, leaving them to be resolved to actual values later. This is done by simply using a placeholder value like 0, and then storing a list of these addresses in the relocation table along with the labels we want to assign to them.</p>
<p>To make this easier for the assembler, we add the <code>.import IDENTIFIER</code> directive, which does not result in any output, but tells the assembler that <code>IDENTIFIER</code> is an identifier that is external to the current file and will be linked in later. This allows us to catch typos in our label names more easily - we can give an error if a label isn't defined and isn't imported.</p>
<p>In the MERL files, we define a new format code for the relocation table - 0x11, the <strong>external symbol reference</strong> (ESR) format. The table entry then contains the address of the label reference, and the name of the label:</p>
<pre><code>; ESR relocation table entry
.word 0x11
.word ADDRESS # location where the label was used
.word LENGTH # number of words/chars that make up the label name
.word C[0] # first character of the label as ASCII value
; ...
.word C[LENGTH - 1] # last character of the label as ASCII value</code></pre>
<h1 id="section-7">29/1/15</h1>
<p>However, we also need a way for a module to say what labels it has, so other modules can actually import it. We don't want to just export all the labels in a MERL module - labels are often duplicated, expecially when we start having compilers generating them automatically.</p>
<p>Instead, we have a <code>.export LABEL</code> directive, which makes a new entry in the relocation table, in the <strong>external symbol definition</strong> (ESD) format. This contains the address where the label is defined, and the name of the label:</p>
<pre><code>; ESD relocation table entry
.word 0x05
.word ADDRESS # location where the label was defined
.word LENGTH # number of words/chars that make up the label name
.word C[0] # first character of the label as ASCII value
; ...
.word C[LENGTH - 1] # last character of the label as ASCII value</code></pre>
<p>In programming languages like C, each function gets its own <code>.export</code> entry, which is how the linker can link C object files together. A <code>static</code> function doesn't get an ESD entry, which is why it can't be imported from other files.</p>
<p>Now we can write a linker:</p>
<pre><code># Given MERl files m1 and m2 as binary blobs, and we want to make a single MERL file with m2 linked in after m1
# `get_imports` and `get_exports` get the ESRs and ESDs, respectively, as a dictionary mapping label names to addresses

a &lt;- len(m1) - 12
relocate m2 higher by `a`
add `a` to every address in m2&#39;s symbol table
assert(set_conjunction(get_exports(m1).keys(), get_exports(m2).keys()) == empty_set)

# link imports and exports together
for address1, label in get_imports(m1):
    if label in get_exports(m2):
        m1[address1] = get_exports(m2)[label]
        delete the ESR entry `label` from m1&#39;s relocation table
        add relocation entry `address1` to m1&#39;s relocation table
for address2, label in get_imports(m2):
    if label in get_exports(m1):
        m1[address1] = get_exports(m1)[label]
        delete the ESR entry `label` from m2&#39;s relocation table
        add relocation entry `address1` to m2&#39;s relocation table
    # we don&#39;t have an else because this linker only links two MERL files at a time, so it&#39;s possible that we run this multiple times for three or more files

# make the final relocation table
relocations = set_disjunction(get_relocations(m1), get_relocations(m2))
imports = set_disjunction(get_imports(m1), get_imports(m2))
exports = set_disjunction(get_exports(m1), get_exports(m2))

# output MERL file
output MERL cookie
output total code length plus relocation table size plus 12 (header size)
output total code length plus 12 (header size)
output m1
output m2
output relocations, exports, and imports</code></pre>
<h2 id="high-level-languages">High Level Languages</h2>
<p>The compiler is responsible for converting a high level language to assembly. Unlike an assembler, the compiled result is not unique - there are multiple possible ways to convert high level languages to assembly.</p>
<p>We want a formal theory of string recognition - general principles that work in the context of any programming language.</p>
<p>An <strong>alphabet</strong> is a finite set of symbols, generally denoted <span class="math">\(\Sigma\)</span> (<span class="math">\(\Sigma = \set{a, b, c}\)</span>, for example). Symbols can be anything we want, and might not even be strings.</p>
<p>A <strong>string/word</strong> is a finite sequence of symbols, each symbol belonging to <span class="math">\(\Sigma\)</span> (<span class="math">\(abaabbcca\)</span>, for example).</p>
<p>The length of a string <span class="math">\(s\)</span> is <span class="math">\(\abs{s}\)</span>. The empty string is usually denoted <span class="math">\(\epsilon\)</span>. This should not be confused with any symbols in the alphabet - <span class="math">\(\abs{\epsilon} = 0\)</span>.</p>
<p>Given a string <span class="math">\(s\)</span>, <span class="math">\(s^n\)</span> is equivalent to <span class="math">\(s\)</span> repeated <span class="math">\(n\)</span> times - <span class="math">\(s^n = s \ldots s\)</span>.</p>
<p>A <strong>language</strong> is a set of strings (<span class="math">\(\set{a^{2n}b \mid n \ge 0}\)</span>, for example, which is an even number of <span class="math">\(a\)</span> followed by a <span class="math">\(b\)</span>). The empty language is just an empty set <span class="math">\(\emptyset\)</span> - a language with no words. This is different from <span class="math">\(\set{\epsilon}\)</span>, which is a language with one word, the empty word.</p>
<p>We want to determine if a given string belongs to a given language. How difficult this is depends on the language. For infinite sets of strings, like the set of all valid MIPS or C programs, things get a little trickier. In fact, there exist languages where this is impossible.</p>
<p>Therefore, we want to characterize languages by how hard they are to recognize. Noam Chomsky came up the Chomsky heirarchy to deal with this. The following is based on that, and lists language classes in ascending order of difficulty recognizing:</p>
<ul>
<li>The <strong>finite languages</strong> are the easiest to recognize - there are a finite number of strings, so we can just check each one.</li>
<li>The <strong>regular languages</strong>.</li>
<li>The <strong>context-free languages</strong>.</li>
<li>The <strong>context-sensitive languages</strong>.</li>
<li>The <strong>recursive languages</strong>.</li>
<li>There are other types that are more difficult to recognize, and they are all impossible to recognize.</li>
</ul>
<p>Our goal is to use as easy a level as possible on the heirarchy, since then the compiler will be simpler.</p>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2014 Anthony Zhang.
</div>
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>