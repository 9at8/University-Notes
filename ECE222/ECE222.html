<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>ECE222 | Anthony Zhang</title>
  <link rel="stylesheet" href="../css/base.css" type="text/css">
  <link rel="stylesheet" href="../css/note.css" type="text/css">
  <link rel="stylesheet" href="../highlight/styles/default.css">
  <link rel="stylesheet" href="../highlight/styles/paraiso.light.css">
  <script src="../highlight/highlight.pack.js"></script>
  <script>
function highlight() { // highlight all code blocks using HighlightJS
  var code_blocks = document.getElementsByTagName("code");
  for (var i = 0; i < code_blocks.length; i++)
    hljs.highlightBlock(code_blocks[i]);
}
</script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</head>
<body onload="highlight()">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-68271407-1', 'auto');
    ga('send', 'pageview');

  </script>
  <h1>Lecture Notes by <a href="/">Anthony Zhang</a>.</h1>
  <ul class="site_links">
    <li><a href="/blog/" class="page">blog</a></li>
    <span class="divider"></span>
    <li><a href="http://uberi.github.io/University-Notes" class="page">notes</a></li>
    <span class="divider"></span>
    <li><a href="/resume.pdf" class="page">résumé</a></li>
    <span class="divider"></span>
    <li><a href="https://github.com/Uberi" class="contact">github</a></li>
    <span class="divider"></span>
    <li><a href="http://www.linkedin.com/pub/anthony-zhang/8b/aa5/7aa" class="contact">linkedin</a></li>
    <span class="divider"></span>
    <li><a href="mailto:azhang9@gmail.com" class="contact">email</a></li>
    <span class="divider"></span>
    <li><a href="https://www.facebook.com/anthony.zhang.user" class="contact">facebook</a></li>
    <span class="divider"></span>
    <li><a href="https://twitter.com/anthony926535" class="contact">twitter</a></li>
  </ul>
<h1 id="ece222">ECE222</h1>
<p>Section 001 (mixed engineering)</p>
<pre><code>Andrew Morton
arrmorto@uwaterloo.ca</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\tup}[1]{\left\langle #1 \right\rangle}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\newcommand{\formlp}{\operatorname{Form}(\mathcal{L}^P)}
\]</span></p>
<h1 id="section">14/9/15</h1>
<p>Computer architecture and assembly language programming.</p>
<p>There's a single Saturday lecture to make up for Thanksgiving Monday, sometime on the 1:30-2:20 slots. There are 6 make-up lecture slots on Fridays at 1:30 PM-2:20 PM.</p>
<p>Midterm on October 28 at 8:30 AM, 75 minutes. Textbook is optional but recommended.</p>
<p>No tutorials for the first week. Tentative office hours for this section are Wednesdays at 12:30 PM.</p>
<p>Finding the magnitude of a negative two's complement number is done by flipping all of the bits and adding one, but a better way is to flip all the bits left of the rightmost 1, and interpreting the resulting number as the unsigned binary magnitude.</p>
<h1 id="section-1">16/9/15</h1>
<p>Continuation of number sysytems and binary - see CS241 and ECE214e notes for reference.</p>
<p>Overflow occurs when the result cannot be represented using the given number of bits, such as when two excessively large unsigned values are added together to get a value larger than <span class="math">\(2^n - 1\)</span>. It is always important to check for overflow when doing arithmetic. In computers, there is usually an overflow flag in a status register.</p>
<p>For subtraction, the overflow/borrow bit represents whether the sign of the result differs from the sign of either operand - if there are both positive and negative values as the operands and result.</p>
<p><strong>Sign extension</strong> is the replication of the leftmost bit to make a binary number of a particular width larger. For example, sign extending 1010 to 8 bits results in 11111010.</p>
<p>Computers can be general purpose or application-specific. Types of computers include personal computers, workstations, mainframes, supercomputers, embedded computers.</p>
<h1 id="section-2">18/9/15</h1>
<p>Hack the North starts today at 6PM! Lab 0 is done individually but you should still have a partner.</p>
<p>A <strong>programmable computer</strong> is a device that can store a sequence of instruction, execute a stored sequence of instructions, and conditionally select a path of execution (control transfer). One of the first computers programmable computers designed was mechanical - the analtyical engine by Charles Babbage.</p>
<p>Some of the tehnologies used for programmable omputers are mechanical, vacuum tube, transistors, integrated circuits, VLSI, and nanotechnological integration.</p>
<p>The Harvard Mark I (1944) was the first computer to implement the Harvard architecture (separate code and data). The Manchester Baby (1948) was the first to implement the von Neumann architecture (code in same memory as data).</p>
<p>A <strong>digital computer</strong> uses digital electronic circuits to implement a programmable computer. Generally, these consist of input/output (keyboards, monitors, and network cards), memory, and the CPU (the ALU and control unit), as well as the interconnection network that connects these all together.</p>
<p>For this course, memory will be represented as an array of bytes. The <strong>word length</strong> of the computer depends on the processor, and these days is generally 16, 32, or 64 bits. A computer with word length <span class="math">\(n\)</span> has words of <span class="math">\(n\)</span> bits - a word would be an <span class="math">\(n\)</span> bit binary number. A <strong>long word</strong> is a <span class="math">\(2n\)</span> bit binary number.</p>
<p>A memory unit has a clock, read enable, write enable, and address inputs, and has data output. Most computers have multiple levels of memory, from closer to the processor (fastest) to farthest from the processor (slower):</p>
<ul>
<li>Registers are the fastest memory, being built into the processor, but are very small, storing only a few bytes.
<ul>
<li>These generally are just implemented with flip-flops.</li>
</ul></li>
<li>Caches are also generally built into the processor further away, and can store several kilobytes or megabytes.
<ul>
<li>There are often separate instruction and data caches.</li>
<li>Caches implement temporal locality (recently accessed data can be retrieved again faster) and spatial locality (fetch nearby memory faster, such as fetching the next few instructions to execute).</li>
<li>There can also be multiple levels of caches, from L1 (fastest/smallest) to L3 (slowest/largest).</li>
<li>Caches use SRAM for memory, which is basically just a series of flip-flops.</li>
</ul></li>
<li>Primary memory (RAM) is a lot slower, but can store gigabytes.
<ul>
<li>This is generally implemented with DRAM, which is basically just a transistor switching the high voltage to a capacitor that is also connected to ground.</li>
<li>DRAM is much smaller, but needs to be refreshed and works slower.</li>
</ul></li>
<li>Secondary memory (hard drives/SSDs) are extremely slow, and can store gigabytes and terabytes of data.</li>
</ul>
<p>In each level, we can store exponentially more data, but it takes an exponentially longer time to read or write.</p>
<h1 id="additional-lecture">16/9/15 - Additional Lecture</h1>
<p>Modern CISC CPUs translate complex machine code into microcode/microops first, then execute those simpler instructions. CPUs have to fetch the operation, fetch the operands, perform the operaion, then store the result.</p>
<p>The current instruction is stored in the <strong>instruction register</strong> (IR), and the address of the next instruction is always the value in the <strong>program counter</strong> (PC). The <strong>memory address register</strong> (MAR) contains the current memory address to read or write to if applicable. The <strong>memory data register</strong> (MDR) contains the current data to read or write to memory if applicable. The general purpose registers hold data and addresses.</p>
<p>The control unit drives the ALU to execute instructions.</p>
<p>A <strong>bus</strong> is a set of wires that can have different writers and readers at different times. One unit may write to the bus at a time, but many can read from it at any time. Writing to a bus is called <strong>bus driving</strong>. Since short circuits can occur if two units drive the bus at the same time, the control unit in CPUs manages which unit is allowed to drive at any time. Buses are often implemented using tri-state buffers.</p>
<p>A CPU is connected to memory and I/O via a bus. Nowadays, however, the limitation that only one unit can write at a time is too restrictive, so we use multiple buses. Modern bus standards include PCI, PCIe, and USB.</p>
<p>Since the CPU's connection to memory and I/O is both over a bus, I/O is generally treated a lot like memory. This allows techniques such as <strong>memory-mapped I/O</strong>, where I/O listens on the bus for reads and writes to certain addresses, and dispatches actions based on that. This allows simpler I/O access from the CPU by simply using the standard memory manipulation instructions.</p>
<p>An <strong>instruction</strong> is a command tha tells the CPU to do something like move data, transfer control flow, or do math. A <strong>program</strong> is a sequence of instructions.</p>
<p>For every instruction, the CPU must fetch the instruction, decode which one it is, fetch the operands if applicable, perform the operation, then store the results if applicable.</p>
<p>We access memory by address - each address represents a unit of memory. For most computers, each byte is assigned an address - this is <strong>byte addressable memory</strong>. Some systems assign one address per word instead - this is <strong>word addressable memory</strong>. For example, MIPS has an address for each byte, but memory can only be accessed if it's aligned to a word boundary.</p>
<p>In SI, a kilobyte is <span class="math">\(10^3\)</span> bytes, or 1 kB, and a kibibyte is <span class="math">\(2^{10}\)</span>, or 1 KiB. The same goes for megabyte (<span class="math">\(10^6\)</span> bytes, or 1 MiB) vs. mebibyte (<span class="math">\(2^{20} bytes\)</span>), gigabyte vs. gibibyte, terabytes vs. tibibytes, petabytes vs. pebibytes, and exabytes vs. exbibytes. This is because the standard SI prefixes should always refer to powers of 10, while the powers of 2 get different prefixes. KB is an incorrect unit, since uppercase K represents Kelvin.</p>
<h1 id="section-3">21/9/15</h1>
<p>For most computers, and especially for the computers in our course, word sizes are 32 bits, and characters are 1 byte. The default text encoding we will use is ASCII. We will also assume our systems are byte addressable.</p>
<p>The <strong>byte ordering/endianness</strong> of the computer determines how the bytes of numbers are ordered physically in memory. The <strong>little endian</strong> byte ordering is the most common, and assigns the less significant digits in the number to the bytes at smaller addresses, and the more significant digits to the bytes at larger addresses. For example, 0x1234 is represented as consecutive bytes 0x04, 0x03, 0x02, and 0x01. The <strong>big endian</strong> byte ordering is the opposite order, and 0x1234 is represented wth the consecutive bytes 0x01, 0x02, 0x03, and 0x04. While big endian looks more like the human representation of the number, little endian is more logical for things like arrays of numbers. Some architectures like PowerPC support switching between either convention.</p>
<p>The endianness of numbers is very important if transferring data between computers. The same bytes read on a big endian machine will result in a different number than one read on a little endian machine. Most networking stacks will handle this automatically, but sometimes it is necessary to read/write the bytes in an explicit, fixed byte order to ensure all computers can read it the same.</p>
<p>Lowercase and uppercase letters in ASCII differ only by one bit. In order to make this work, though, the lowercase and uppercase characters are not adjacent in the ASCII table.</p>
<p>What the Control key does is it hides the top nibble of the character - for example, Ctrl + C hides the top bits of C (0x43), to get 0x03, the end of text character.</p>
<p>An address on a byte-addressible computer is <strong>aligned</strong> if it is a multiple of the word size. For example, on a 32-bit computer an address is aligned if it is a multiple of 4. Unaligned addresses may take longer to access, or even be forbidden by the architecture - ARM, for example, will raise an exception/interrupt upon unaligned accesses.</p>
<p>Every processor will have instructions for data transfer between memory and registers, arithmetic/logic, braching/jumping/control flow, and I/O (generally memory mapped, so these can just be the same as for data transfer between memory and registers).</p>
<p>The <strong>instruction set architecture</strong> (ISA) specifies how a processor works - the instructions of a processor (the operations and their format), the registers, control registers, memory layout (like memory banks), exceptions, and so on. Examples of ISAs are ARM, x86, MIPS, and SPARC. There are often variations and flavors of each ISA, like the 64-bit variant of x86, x86-64.</p>
<p>A <strong>reduced instruction set computer</strong> (RISC) ISA has a fixed size for each instruction (each instruction takes the same number of bits), and have a load/store architecture (memory is accessed only via load/store instructions, and all other operations work on registers). RISC ISAs are simpler to construct and understand - for example, the fixed sized instructions mean decoding is a lot easier.</p>
<p>In contrast, a <strong>complex instruction set computer</strong> (CISC) ISA can have variable length instructions, and many instructions can also do things like accessing memory. These are harder to construct, but we can do more with each instruction - each instruction is harder to decode, because we have to read some of it first to know how much to keep reading.</p>
<h1 id="section-4">23/9/15</h1>
<p>Assemly language is a symbolic representation of machine code. It uses mnemonics to represent operations/instructions. See CS241 notes for basic overview of language format.</p>
<p>Assembly language uses <strong>register transfer level</strong> notation:</p>
<ul>
<li><code>R0</code> through to <code>R15</code> are names for general purpose registers.</li>
<li>Control registers/signals are reserved bare words, like <code>T1</code> and <code>T2</code>.</li>
<li>Other bare identifiers are memory locations (like labels) - <code>some_label</code>.</li>
<li>Square brackets around a memory location or register represent the value at that memory location or memory address - <code>[R0]</code> means &quot;value of <code>R0</code>&quot; while <code>[LOCATION]</code> means <code>*R0</code> in C.</li>
<li>Square brackets can be nested - <code>[[LOCATION]]</code> means <code>**LOCATION</code>.</li>
</ul>
<p>RTL notation is not standardized and may differ between texts.</p>
<p>RTL notation can represent instructions in terms of how they manipulate data, like <span class="math">\(R1 \leftarrow [LOCATION]\)</span>, or <span class="math">\(\text{if } [R0] == 1 \text{ then } R0 = 50\)</span>. Notation like <span class="math">\(R1 \leftarrow [R1] + [LOCATION]\)</span> makes it immediately obvious what the instruction does.</p>
<p>RTL notation can also be used to describe instructions in assembly language in a more comprehensible way. For example, <code>ADD R0, R1, R2</code> can be written as <span class="math">\(R0 \leftarrow [R1] + [R2]\)</span>, <code>LOAD R0, LOCATION</code> can be written as <code>R0 \leftarrow [LOCATION]</code>, and <code>STORE R0, LOCATION</code> can be written as <code>LOCATION \leftarrow [R0]</code>.</p>
<p>Since registers don't have addresses, they will never appear on the right side of the <span class="math">\(\leftarrow\)</span> in square brackets.</p>
<p>Some instructions can have literal values as well, called <strong>immediate values</strong>. For example, <code>SUBTRACT R2, R2, 5</code>, which can be written as <span class="math">\(R2 \leftarrow [R2] - 5\)</span>, has the immediate value 5.</p>
<p>Branching in RTL notation simply sets the control register <code>PC</code>. For example, <code>BRANCH_IF_ZERO R0, LOOP</code> can be written as <span class="math">\(\text{if } [R0] == 1 \text{ then } PC \leftarrow LOOP\)</span>.</p>
<p><strong>Addressing modes</strong> are different ways to specify where to find the operand of an instruction. The location/type of operand results in an <strong>effective address</strong>, when applicable. The effective address is where we would write to if that operand is an output, and is similar to the address of an lvalue in C.</p>
<h1 id="section-5">25/9/15</h1>
<p>A good resource for learning ARM is the <a href="http://www.davespace.co.uk/arm/">Davespace ARM reference</a>.</p>
<p>The <strong>immediate</strong> addressing mode means that the operand is a constant - we simply put the constant directly in the instruction. For example, the <code>#2</code> (<span class="math">\(2\)</span>) in <code>MOVE R0, #2</code> <span class="math">\(R0 \leftarrow 2\)</span>. Since the constant is inside the instruction, and the instruction itself needs to take up some bits, the constants must be smaller than the word size.</p>
<p>The <strong>register</strong> addressing mode means that the operand is a register. For example, the <code>R0</code> (<span class="math">\([R1]\)</span>) in <code>MOVE R0, R1</code> (<span class="math">\(R0 \leftarrow [R1]\)</span>). The effective address here is <span class="math">\(R1\)</span>.</p>
<p>The <strong>absolute/direct</strong> addressing mode means that the operand is a known, fixed address in memory. For example, the <code>LABEL</code> (<span class="math">\(LABEL\)</span>) in <code>JUMP LABEL</code> (<span class="math">\(PC \leftarrow LABEL\)</span>). The effective address here is <span class="math">\(LABEL\)</span>. Note that this addressing mode is generally only supported for control flow instructions like JUMP - for MOVE, we would use something like <code>MOVE R0, #LABEL</code> to store the address of the label itself.</p>
<p>The <strong>register indirect</strong> addressing mode means that the operand is the contents of the memory address specified by a register, like dereferencing a pointer. For example, the <code>[R1]</code> (<span class="math">\([[R1]]\)</span>) in <code>LOAD R0, [R1]</code> (<span class="math">\(R0 \leftarrow [[R1]]\)</span>). The effective address here is <span class="math">\(R0\)</span>. This is also sometimes denoted<code>(R1)</code> (parentheses rather than square brackets).</p>
<p>Here is an assembly program to sum an array of numbers and store it in ARRAY_SUM, in a pseudo-assembly language:</p>
<pre><code>LOAD R2, ARRAY_LENGTH
CLEAR R3
MOVE R4, #ARRAY_START
LOOP: LOAD R5, [R4]
ADD R3, R3, R5
ADD R4, R4, #4
SUBTRACT R2, R2, #1
BRANCH_IF_NONZERO R2, LOOP
STORE R3, ARRAY_SUM</code></pre>
<p>The <strong>index</strong> addressing mode is a useful extension of indirect addressing, where the operand is the contents of the memory address specified by a register plus a constant address. For example, the <code>5(R1)</code> (<span class="math">\([[R0] + 5]\)</span>) in <code>MOVE R0, 5(R1)</code> (<span class="math">\(R0 \leftarrow [[R1] + 5]\)</span>). The effective address here is <span class="math">\([R1] + 5\)</span>. Note that in the code, all constants are generally decimal. This addressing mode is very useful for working with structs.</p>
<p>The <strong>base with index</strong> addressing mode is an even more flexible extension of indirect addressing, where the operand is the contents of the memory address specified by a register (specifying the base address) plus another (specifying an offset). For example, the <code>[R1, R2]</code> (<span class="math">\([[R1] + [R2]]\)</span>) in <code>MOVE R0, [R1, R2]</code> (<span class="math">\(R0 \leftarrow [[R1] + [R2]]\)</span>). The effective address here is <span class="math">\([R1] + [R2]\)</span>. This addressing mode is very useful for working with arrays.</p>
<h1 id="section-6">28/9/15</h1>
<p>The <strong>base with index and offset</strong> addressing mode combines the above two, where there is a base address and an offset. For example, the <code>5(R1, R2)</code> (<span class="math">\([R1] + [R2] + 5\)</span>) in <code>MOVE R0, 5(R1, R2)</code> (<span class="math">\(R0 \leftarrow [R1] + [R2] + 5\)</span>). The effective address here is <span class="math">\([R1] + [R2] + 5\)</span>.</p>
<p>The <strong>PC-relative</strong> addressing mode is similar to the index addressing mode, but the offset is always added to the program counter. For example, the <code>5(PC)</code> (<span class="math">\([PC] + 5\)</span>) in <code>MOVE R0, 5(PC)</code> (<span class="math">\(R0 \leftarrow [PC] + 5\)</span>). The effective address here is <span class="math">\([PC] + 5\)</span>. When a PC-relative operand is a label, the assembler will generally convert that into the <code>OFFSET(PC)</code> form automatically - <code>SOME_LABEL BRANCH_IF_ZERP R0, SOME_LABEL</code> gets translated to <code>SOME_LABEL BRANCH_IF_ZERP R0, -4(PC)</code>. This is very useful for branch instructions.</p>
<p>The <strong>auto-increment</strong> addressing mode is similar to register indirect addressing, but the register is incremented by the number of bytes to read after the read occurs. For example, the <code>[R1]+</code> (<span class="math">\([[R1]]\)</span> then <span class="math">\(R1 \leftarrow [R1] + 4\)</span>) in <code>LOAD R0, [R1]+</code> (<span class="math">\(R0 \leftarrow [R1] + 4\)</span> then <span class="math">\(R1 \leftarrow [R1] + 4\)</span>). This is very useful for working with stacks and queues, especially in combination with auto-decrement addressing.</p>
<p>There is also the <strong>auto-decrement</strong> addressing mode, which is simply <code>-[R1]</code> rather than <code>[R1]+</code>. The register is decremented by the amount to be read before the read occurs. There are also the <code>[R1]-</code> and <code>+[R1]</code> modes, which do the writing in the opposite order as <code>-[R1]</code> and <code>[R1]+</code>.</p>
<p>The <strong>call stack</strong> is used for many things, such as subroutine parameters, return addresses, and local variables. The stack starts at the highest memory address, and grows downward. The top element of the stack is always pointed to by the <code>SP</code> register. To push onto the stack, we decrement SP and write in the data we want to push onto the stack. To pop off the stack, we read out the top element, and then increment SP.</p>
<p>A subroutine is a block of instructions that can be executed repeatedly - this is good for deduplication and modularity. Subroutines can be called using the <code>CALL</code> instruction, and return using the <code>RETURN</code> instruction.</p>
<p>When we do a call, we need to save the return address somewhere. We may store it on the stack, but starting with MIPS, RISC processors started putting the return address in the link register (<code>LR</code>). x86, on the other hand, stores the return address on the call stack.</p>
<h1 id="section-7">30/9/15</h1>
<p>On our ARM machines, R13 is the stack pointer, R14 is the link register, and R15 is the program counter.</p>
<p>To make a call, we use the <code>CALL SOME_SUBROUTINE</code> instruction, which stores the value of PC in the link register, and branch to the target of the call. To return, we use the <code>RETURN</code> instruction to jump back to the address saved in that link register.</p>
<p>If we call a subroutine and within that subroutine, call another subroutine, the link register's value (the return address) gets overwritten by the inner call. To retain the return addresses, we push the link register contents to the stack before calling the inner subroutine, and pop it off ino the link register again after calling it. This can fail if there is a stack overflow or the stack is managed incorrectly.</p>
<p><strong>Parameters</strong> can be passed using registers, memory locations, and on the stack.</p>
<p>Parameters are passed using registers if and only if there are few parameters, the subroutine is non-recursive, and the subroutine does not call other subroutines that use those same registers. Passing by registers is the fastest option, since it avoids main memory accesses.</p>
<p>Passing parameters using memory locations is rarely used - it's analogous to passing values using global variables.</p>
<p>In all other situations, parameters are passed on the stack, by pushing the last parameter to the first parameter, calling the subroutine, and then popping off all the parameters again - the caller manages the parameter pushing and popping.</p>
<p>Using registers:</p>
<pre><code>; N is the array length, NUM_1 to NUM_N are the elements of the array
LOAD R2, N
MOVE R4, #NUM1
CALL LISTADD ; call LISTADD subroutine
STORE R3, SUM

LISTADD:
; R2 is the array length, R4 is the address of the first element - we pass parameters in registers
; push R5 on the stack so we can restore it later
STORE R5, -(SP)

CLEAR R3 ; R3 stores the result
LOOP:
; we can freely modify the parameters as we want to
LOAD R5, (R4)+
ADD R3, R3, R5
SUBTRACT R2, R2, #1
BRANCH_IF_NONZERO R2, LOOP

; restore R5 and return - R3 contains the result by this point
LOAD R5, (SP)+
RETURN</code></pre>
<p>Using the stack:</p>
<pre><code>; N is the array length, NUM_1 to NUM_N are the elements of the array
MOVE R2, #NUM1
STORE R2, -(SP) ; second parameter
LOAD R2, N
STORE R2, -(SP) ; first parameter
CALL LISTADD ; call LISTADD subroutine
ADD SP, SP, #4 ; pop the first parameter off
LOAD R2, (SP)+ ; pop the second parameter off - the result is stored in this space
STORE R2, SUM ; save the result to SUM

LISTADD:
; push R2, R3, R4, R5 on the stack so we can restore it later
STORE R2, -(SP)
STORE R3, -(SP)
STORE R4, -(SP)
STORE R5, -(SP)

CLEAR R3 ; R3 stores the temporary result
LOOP:
LOAD R5, (R4)+
ADD R3, R3, R5
SUBTRACT R2, R2, #1
BRANCH_IF_NONZERO R2, LOOP
STORE R3, 20(SP) ; store the result in the space originally used for the first parameter passed on the stack

; restore R2, R3, R4, R5 and return - top of stack contains the result by this point
LOAD R2, (SP)+
LOAD R3, (SP)+
LOAD R4, (SP)+
LOAD R5, (SP)+
RETURN</code></pre>
<h1 id="section-8">2/10/15</h1>
<p>When we enter a subroutine, we push the <strong>frame pointer</strong> (<code>FP</code>), followed by spaces for the local variables, followed by saved registers - together, these form a <strong>stack frame</strong>.</p>
<p>The frame pointer is used as a convenient way to refer to local variables and saved registers - even as the stack pointer changes as we're using it, the frame pointer doesn't change. The parameters are at a positive offset from the frame pointer, while local variables and saved registers are at a negative offset.</p>
<pre><code>LOAD R2, PARAM2
STORE R2, -(SP)
LOAD R2, PARAM1
STORE R2, -(SP)
CALL SUB1
LOAD R2, (SP) # obtain return value
ADD SP, SP, #8 # pop all parameters off the stack

SUB1:
# save registers
STORE LINK_REG, -(SP)
STORE FP, -(SP)
MOVE FP, SP # initialize frame pointer to between parameters and local variables
STORE R2, -(SP) # local variable for parameter
STORE R3, -(SP) # local variable for parameter
STORE R4, -(SP) # local variable
STORE R5, -(SP) # local variable
LOAD R2, 8(FP) # get first parameter
LOAD R3, 12(FP) # get second parameter

; do stuff
; we can use -4(FP) to -16(FP) to refer to the local variables

; call another subroutine
LOAD R4, PARAM3
STORE R4, -(SP)
CALL SUB2
LOAD R4, (SP)+ # obtain return value

; do other stuff

# save the result onto the stack
STORE R5, 8(FP) # the space used by the first parameter

# restore registers
LOAD R5, (SP)+
LOAD R4, (SP)+
LOAD R3, (SP)+
LOAD R2, (SP)+
LOAD FP, (SP)+
LOAD LINK_REG, (SP)+
RETURN

SUB2:
# save registers
# we don&#39;t have to store LINK_REG because we aren&#39;t making any other subroutine calls
STORE FP, -(SP)
MOVE FP, SP # initialize the frame pointer to between parameters and local variables
STORE R2, -(SP) # local variable for parameter
STORE R3, -(SP) # local variable
LOAD R2, 4(FP) # get the parameter

; do stuff
; we can use -4(FP) and -8(FP) to refer to the local variables

# save the result onto the stack
STORE R3, 4(FP) # the space used by the first parameter

# restore registers
LOAD R3, (SP)+
LOAD R2, (SP)+
LOAD FP, (SP)+
RETURN</code></pre>
<h1 id="additional-lecture-1">2/10/15 - Additional Lecture</h1>
<p>In addition to arithmetic instructions like <code>ADD</code> and <code>SUB</code>, we also have logical operations like <code>AND DEST, A, B</code>, <code>OR DEST, A, B</code>, <code>SHIFTL DEST, VALUE, AMOUNT</code>, <code>SHIFTR DEST, VALUE, AMOUNT</code>, <code>ROTATEL DEST, VALUE, AMOUNT</code>, <code>ROTATER DEST, VALUE, AMOUNT</code>. Rotating without carry rotates ignoring the carry bit, but the bit that corresponds to it is still stored in the carry bit.</p>
<h2 id="arm-isa">ARM ISA</h2>
<p>The <strong>assembler</strong> is responsible for generating the machine language program from the assembly code. The three operand instructions need to fit into a single word, while also supporting immediate values. Instructions in ARM take the following form:</p>
<p>ARM instructions have a fixed length (32 bits) and only access memory using dedicated load/store instructions, which puts them in the RISC category. However, there are also a variety of CISC-like features, such as the many addressing modes, conditionally executing instructions, and store/load of multiple registers.</p>
<p>ARM memory is byte addressable with 32-bit addresses, and supports little and big endian representations, configurable to either. It supports aligned 32-bit words, 16-bit half words, and bytes.</p>
<p>ARM has 16 data registers, R0 to R15. R15 is the program counter, R13 is conventionally used as the stack pointer, and R14 is conventionally used as the link register. The CPSR/PSR register contains various status bits, such as negative (<code>N</code>), zero (<code>Z</code>), overflow (<code>V</code>), carry (<code>C</code>), and interrupt masks. These status codes are used by instructions that explicitly specify that they access the status bits, and are also used by the condition bits on conditional instructions.</p>
<p>In ARM, all the addressing modes except for immediate/register direct are derived from indexed addressing. The offset can be specified as an immediate value, or another register.</p>
<p>The instructions we have been using so far are similar to ARM, but not the same. For example, <code>MOVE R0, R1</code> is actually <code>LDR R0, R1</code> (load register) - <code>LDR</code> supports a register or an immediate value for the value to load. This can be used to do register direct (<code>LDR R0, R1</code>), immediate value (<code>LDR R0, #123</code>), and PC-relative addressing (<code>LDR R0, SOME_LABEL</code>).</p>
<p>Arithmetic/logic instructions are largely the same, such as <code>ADD DEST, ADDEND, ADDEND</code> (addition), <code>SUB DEST, MINUEND, SUBTRAHEND</code> (subtraction), and <code>MUL DEST, MULTIPLICAND, MULTIPLICAND</code>. For these, the second source operand (a source operand is an operand that is not a destination - one that is not written to) can either be a register or an immediate value (the immediate values have some restrictions, which are managed by the assembler).</p>
<h1 id="section-9">5/10/15</h1>
<p>Addressing modes in ARM:</p>
<ul>
<li>PC-relative addressing: <code>LDR R0, LABEL</code> translates to <span class="math">\(R0 \leftarrow [PC] + offset(LABEL)\)</span>, where <span class="math">\(offset(label)\)</span> is the relative offset of the label.</li>
<li>Pre-index addressing (analogous to index addressing): <code>LDR R0, [R1, #25]</code> translates to <span class="math">\(R0 \leftarrow [[R1] + 25]\)</span>.</li>
<li>Pre-index addressing with writeback (analogous to auto-increment/auto-decrement addressing): <code>LDR R0, [R1, #4]!</code> translates to <span class="math">\(R0 \leftarrow [[R1] + 4]; R1 \leftarrow [R1] + 4\)</span>.</li>
<li>Pre-index addressing with offset: <code>LDR R0, [R1, R2]</code> translates to <span class="math">\(R0 \leftarrow [[R1] + [R2]]\)</span>, and <code>LDR R0, [R1, -R2]</code> translates to <span class="math">\(R0 \leftarrow [[R1] - [R2]]\)</span>. Also works with writeback mode.</li>
<li>Pre-index addressing with offset and index: <code>LDR R0, [R1, R2, #-5]</code> translates to <span class="math">\(R0 \leftarrow [[R1] + [R2] - 5]\)</span>, and <code>LDR R0, [R1, -R2, 5]</code> translates to <span class="math">\(R0 \leftarrow [[R1] - [R2] + 5]\)</span>. Also works with writeback mode.</li>
<li>Post-index addressing with write-back (analogous to auto-increment/auto-decrement): <code>LDR R0, [R1], #4</code> translates to <span class="math">\(R0 \leftarrow [[R1]]; R1 \leftarrow [R1] + 4\)</span>.</li>
<li>Post-index addressing with write-back and offset: <code>LDR R0, [R1], R2</code> translates to <span class="math">\(R0 \leftarrow [[R1] + [R2]]; R1 \leftarrow [R1] + [R2]\)</span>, and <code>LDR R0, [R1, -R2]</code> translates to <span class="math">\(R0 \leftarrow [[R1] - [R2]]; R1 \leftarrow [R1] - [R2]\)</span>.</li>
<li>Post-index addressing with write-back and offset and index: <code>LDR R0, [R1], R2, #-5</code> translates to <span class="math">\(R0 \leftarrow [[R1]]; R2 \leftarrow [R1] + [R2] - 5\)</span>, and <code>LDR R0, [R1, -R2, 5]</code> translates to <span class="math">\(R0 \leftarrow [[R1]]; R1 \leftarrow [R1] - [R2] + 5\)</span>.</li>
</ul>
<p>All of these addressing modes can be used each of the memory instructions.</p>
<p>Additional memory operations include <code>LDR</code>/<code>STR</code> (load/store register), <code>LDRH</code>/<code>STRH</code> (zero-extended load/store half-word), <code>LDRB</code>/<code>STRB</code> (zero-extended load/store byte), and <code>LDRSH</code>/<code>LDRSB</code> (sign-extended load half-word/byte).</p>
<p>There are also instructions to access multiple consecutive memory locations, <code>LDM R0!, {R1, R3, R5}</code>/<code>STM R0!, {R1, R3, R5}</code> (load/store multiple) means <span class="math">\(R1 \leftarrow [R0] + 0; R3 \leftarrow [R0] + 4; R5 \leftarrow [R0] + 8\)</span>. The <code>!</code> is optional in each case, and means that the address of the last value loaded should be written back into <code>R0</code>.</p>
<p>For certain arithmetic/logic/move instructions like <code>ADD</code> and <code>MOV</code>, we can also apply some operations to the second source operand before performing the operation. For example, <code>ADD, R0, R1, R2, OPERATION</code> where <code>OPERATION</code> is a value like <code>LSL #5</code>/<code>LSR #5</code> (left-shift/right-shift R2 by 5), <code>ASR #5</code> (arithmetic shift R2 right by 5 bits; basically right-shift with sign extension), <code>ROR #5</code> (rotate R2 right by 5 bits). Internally, the <code>LSL DEST, SRC, AMOUNT</code>, <code>LSR DEST, SRC, AMOUNT</code>, and other shifting instructions are translated into moves using these operations.</p>
<p>The <code>MOV R0, REGISTER_OR_VALUE</code> instruction is like a more limited but smaller version of <code>LDR R0, REGISTER_OR_VALUE</code> - it can only set a register to another register's value, or an immediate value (which has some restrictions, managed by the assembler). <code>MVN R0, REGISTER_OR_VALUE</code> is the same as <code>MVN R0, REGISTER_OR_VALUE</code>, but R0 is set to the bitwise NOT of <code>REGISTER_OR_VALUE</code> rather than the plain value. Also, MOV supports the additional operations on the second source operand (like shifting and rotating), while <code>LDR</code> does not.</p>
<p>Logical operations in ARM include <code>AND</code> (bitwise AND), <code>ORR</code> (bitwise OR), and <code>EOR</code> (bitwise XOR). These also support the operations on the second operand.</p>
<p>The test instructions are used to do comparisons, and are often used with the conditional branching instructions. <code>TST R0, #1</code> does a logical AND between R0 and 1, then sets the Z status bit according to whether the result is 0. <code>TEQ R0, 5</code> does a logical XOR between R0 and 1, then also sets Z according to the result. <code>CMP R0, R1</code> subtracts R1 from R0, then updates the Z, N, and possibly other status bits according to the result. Note that these write only to the status bits, not to the registers themselves.</p>
<p>The test instructions always write to the status registers. Arithmetic/logic/move instructions can do this too, if we use the S variant of them. For example <code>ADDS</code> does the same thing as <code>ADD</code>, but also sets status bits like carry, zero, and negative.</p>
<p>The branch instructions are used to modify control flow, often conditionally based on the status bits. There are several of these instructions, all beginning with B and having the form <code>BCONDITION LABEL</code> (the operand uses PC-relative addressing):</p>
<ul>
<li>Unconditional/always: <code>B LABEL</code>/<code>BAL LABEL</code> branches unconditionally to <code>LABEL</code>.</li>
<li>Equality: <code>BEQc LABEL</code> and <code>BNE LABEL</code> branches to <code>LABEL</code> if <code>Z</code> (zero) is 1 or 0, respectively.</li>
<li>Carry set/unset: <code>BCS LABEL</code>/<code>BHS LABEL</code> and <code>BCC LABEL</code>/<code>BLO LABEL</code> branches to <code>LABEL</code> if <code>C</code> (carry) is 1 or 0, respectively.</li>
<li>Minus/positive: <code>BMI LABEL</code> and <code>BPL LABEL</code> branches to <code>LABEL</code> if <code>N</code> (negative) is 1 or 0, respectively.</li>
<li>Overflow set/unset: <code>BVS LABEL</code> and <code>BVC LABEL</code> branches to <code>LABEL</code> if <code>V</code> (overflow) is 1 or 0, respectively.</li>
<li>Unsigned higher/lower-or-same (greater/less-or-equal-to): <code>BHI LABEL</code> and <code>BLS LABEL</code> branches to <code>LABEL</code> if <code>Z</code> and not <code>C</code> (<span class="math">\(Z \wedge \overline C\)</span>) is 1 or 0, respectively.</li>
<li>Signed greater-or-equal/less: <code>BGE LABEL</code> and <code>BLT LABEL</code> branches to <code>LABEL</code> if <code>N</code> xor <code>V</code> (<span class="math">\(N \oplus V\)</span>) is 1 or 0, respectively.</li>
<li>Signed greater/less-or-equal: <code>BGT LABEL</code> and <code>BLE LABEL</code> branches to <code>LABEL</code> if Z, or <code>N</code> xor <code>V</code> (<span class="math">\(Z \vee (N \oplus V)\)</span>), is 1 or 0, respectively.</li>
</ul>
<h1 id="section-10">7/10/15</h1>
<p>Branch statements can be used to implement any kind of control flow .</p>
<p>An <strong>assembler</strong> is a program that accept assembly language and outputs an object program in machine code - one instruction in assembly language is one machine instruction. Each line of assembly language contains labels, the operation, operands, and comments, all of which are optional.</p>
<p><strong>Assembler directives</strong> are commands to the assembler itself, rather than being translated to machine code. This allows us to do things like speifying the entry point of the program (<code>ENTRY</code>), define constants/data, and set code/data section locations (<code>AREA CODE</code>/<code>AREA DATA</code>). Directives like <code>DCW</code> (declare word) can be used to declare literal values, and often takes the form <code>SOME_LABEL DCW 0x12345678, 0x87654321</code> (two constant words that can be referenced by <code>SOME_LABEL</code>):</p>
<pre><code>AREA CODE ; code section
ENTRY ; entry point of the program

LDR R0, X ; load thevalue of X into R0

AREA DATA ; data section
X DCW 0x25 ; declare a word</code></pre>
<p>Other directives include <code>NAME EQU VALUE</code>, which can be used to define symbolic names fo numerical values (like <code>X EQU 5</code>) and <code>RN</code>, which can be used to give names to registers (<code>COUNTER RN 3</code>).</p>
<p>There are also <strong>pseud-instructions</strong>, which aren't real instructions, but get translated into real, possibly multiple instructions. For example, <code>LDR R0, =LABEL</code> loads the address of <code>LABEL</code> into R0 (as opposed to <code>LDR R0, LABEL</code>, which loads the value at <code>LABEL</code> instead). Also, <code>LDR R0, CONSTANT_VALUE</code> is translated to <code>MOV R0, CONSTANT_VALUE</code> if <code>CONSTANT_VALUE</code> is of the right form, and otherwise is translated into <code>LDR R0, CONSTANT_DEFINITION</code> and <code>CONSTANT_DEFINITION DCW CONSTANT_VALUE</code> - the constant is stored at a memory location, and is loaded from that memory location when required.</p>
<p>Summing an array:</p>
<pre><code>LDR R1, N
LDR R2, =ARRAY
MOV R0, #0
LOOP:
LDR R3, [R2], #4
ADD R0, R0, R3
SUBS R1, R1, #1
BGT LOOP
STR R0, SUM

N DCW 5 ; number of array elements
ARRAY DCW 2, 4, 6, 8, 10 ; elements of array
SUM DCW 0 ; sum of the array is output in here</code></pre>
<h1 id="section-11">9/10/15</h1>
<p><code>STM</code>/<code>LDM</code>, as mentioned earlier, can do multiple register stores/loads all in a single instruction:</p>
<ul>
<li>The FD/IA (increment after) suffix adds the final offset to the register after performing the store/load: <code>STMFD R0!, {R1, R2, R3}</code> (store R1-R3 into memory address at R0, write final address into R0)</li>
<li>The EA/DB (decrement before) suffix subtracts the final offset from the register before performing the store/load: <code>STMEA R0!, {R1, R2, R3}</code> (store R1-R3 into memory address at R0, write final address into R0)</li>
<li>This also supports conditional prefixes to run the instruction conditionally based on status bits: <code>STMFDGT R0, {R1}</code> (store R1 into memory address at R0)</li>
</ul>
<p>This is very useful for pushing multiple things onto (<code>STMFD R13!, {R1, R2, R3}</code>) or off of (<code>LDMFD R13!, {R1, R2, R3}</code>) the stack. The <code>!</code> ensures that the final address of R13 (stack pointer) is updated to represent the top element of the stack.</p>
<p>Also, <code>BL LABEL</code> is the branch and link instruction, which branches to <code>LABEL</code> and sets the address of the next line as the value of the link register - the return address. This is useful for calling subroutines.</p>
<p>This allows for a very elegant calling convention:</p>
<pre><code>LDR R0, #123 # set parameter 1
BL SUBROUTINE # call the subroutine

# accepts 1 parameter in R0, and puts the return value in R0
SUBROUTINE:
STMFD R13!, {R14, R1, R2} # push the link register and any other desired register values onto the stack
; we conventionally don&#39;t need to save the registers for the parameters (R0) since they are only used for this subroutine anyways - plus, we&#39;re reusing it for the return value

; do things with R1 and R2, since they&#39;re saved now

LDMFD, R13, {R15, R1, R2} # pop the link register&#39;s value into the program counter (to do the return) and restore the other register values</code></pre>
<p>The above saves/restores registers using only two instructions, and also does the return at the end. The return value is conventionally put in R0, though we could also push it onto the stack (if the result can't fit into just a register).</p>
<p>Without the multiple store/load instructions, we would have to manually push each register value, then at the end manually restore the register values and return using something like <code>BX R14</code>.</p>
<h1 id="section-12">14/10/15</h1>
<p>A program needs to be assembled in two passes if and only if it includes instructions that reference labels below it in the program (forward references).</p>
<p>Assemblers will assemble modules as if each one will be loaded at location 0, and then the linker relocates it as appropriate. There is position dependent and position independent machine code generated by instructions - position independent code is the same as position dependent code, but it also includes information that allows the linker to relocate it.</p>
<p>The <strong>interconnection network</strong> is the circuitry that connects the processor, memory, and I/O, like the system bus. Communication takes place over a shared address space. I/O devices are often memory mapped - they share the same address space as the memory, and in general simply appear as memory locations. As a result, we can access these I/O devices simply using the standard load/store instructions.</p>
<p>I/O devices typically have three registers exposed as memory locations - data, status, and control. Often, the control and status registers have the same address, where loading from it reads the status register and writing to it sets the control register.</p>
<p>Programs will generally interact with I/O by <strong>polling</strong> (program-controlled I/O) or with <strong>interrupts</strong> (device-controlled I/O).</p>
<p>For polling, there will generally be a bit in the status register that tells us whether the I/O device has data ready to read, and then the program repeatedly checks this and reads if necessary. This is really inefficient if the reads occur infrequently, such as reading keypresses from a keyboard - most of the time, the CPU will simply be checking status registers. We want to allow other things to run while we're waiting for I/O to get reading - to let I/O devices alert the processor when it's ready. This is the role of interrupts.</p>
<div class="license">
  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="https://uberi.github.io/" property="cc:attributionName" rel="cc:attributionURL">Anthony Zhang</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
  Copyright 2013-2014 Anthony Zhang.
</div>
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>