<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>MATH239 | Anthony Zhang</title>
  <style type="text/css">
  body {
    font-family: "Segoe UI", Verdana, Arial, Helvetica, sans-serif;
    background: #fffefe;
    padding: 5em;
  }
  
  pre {
    margin-left: 2em;
  }
  
  code {
    border: solid 1px black;
    background: #665555;
    color: white;
    padding: 0.1em;
    border-radius: 0.3em;
    display: inline-block;
  }
  
  pre code {
    padding: 1em;
    border-radius: 0.5em;
  }
  
  h1 {
    font-size: 4em;
  }
  
  table {
    margin: 0 auto;
  }
  
  td, th {
    padding: 0.5em;
    border: 1px solid grey;
  }
  
  tr {
    padding:: 0;
  }
  
  a.button {
    display: inline-block;
    padding: 1em;
    font-family: monospace;
    color: black;
    text-decoration: none;
    border: 0.2em solid black;
    border-radius: 0.5em;
    background: white;
  }
  
  a.button:hover, a.button:focus, a.button:active {
    background: black;
    color: white;
  }
  </style>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>
<body>
<a class="button" href="..">&#8666; Return to University Notes index</a>
<h1 id="math239">MATH239</h1>
<p>Combinatorics.</p>
<pre><code>Instructor: Martin Pei
Office: MC 6492
Email: mpei@uwaterloo.ca, martin31415926@gmail.com</code></pre>
<p><span class="math">\[
\newcommand{\set}[1]{\left\{ #1 \right\}}
\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\mb}[1]{\mathbb{#1}}
\newcommand{\rem}{\operatorname{rem}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\imag}{\boldsymbol{i}}
\newcommand{\dee}{\mathop{}\!\mathrm{d}}
\newcommand{\lH}{\overset{\text{l&#39;H}}{=}}
\newcommand{\evalat}[1]{\left.\left(#1\right)\right|}
\newcommand{\sech}{\operatorname{sech}}
\newcommand{\spn}{\operatorname{Span}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\prp}{\operatorname{perp}}
\newcommand{\refl}{\operatorname{refl}}
\newcommand{\magn}[1]{\left\lVert #1 \right\rVert}
\newcommand{\rank}{\operatorname{rank}}
\newcommand{\sys}[2]{\left[ #1 \mid #2\hskip2pt \right]}
\newcommand{\range}{\operatorname{Range}}
\newcommand{\adj}{\operatorname{adj}}
\newcommand{\cof}{\operatorname{cof}}
\newcommand{\diag}{\operatorname{diag}}
\]</span></p>
<h1 id="section">5/5/14</h1>
<p>;wip: do assignment 0 and get on LEARN</p>
<h3 id="sets-and-combinatorics">Sets and Combinatorics</h3>
<p>Combinatorics is a discrete mathematics. Topics include enumeration (counting) and graph theory.</p>
<p>The <strong>size/cardinality</strong> of a set <span class="math">\(A\)</span> is denoted <span class="math">\(\abs{A}\)</span>. It is the number of elements it contains, if it is finite, and some other things if it is infinite.</p>
<p><span class="math">\([n]\)</span> is the set of all positive integers from 1 to <span class="math">\(n\)</span>, inclusive.</p>
<p>The <strong>Cartesian product</strong> of two sets <span class="math">\(A\)</span> and <span class="math">\(B\)</span> is <span class="math">\(A \times B = \set{(a, b) \middle| a \in A, b \in B}\)</span>. In other words, it is the set of all pairs of elements from both sets. This can easily be extended to more than two sets: <span class="math">\(A \times B \times C\)</span>.</p>
<p>If <span class="math">\(A\)</span> and <span class="math">\(B\)</span> are finite, then <span class="math">\(\abs{A \times B} = \abs{A}\abs{B}\)</span>.</p>
<p>Consider all possible results of throwing two six-sided dice:</p>
<blockquote>
<p>Clearly, the set of all possible results for each die is <span class="math">\([6]\)</span> and <span class="math">\([6]\)</span>.<br />So the set of all possible results of both die is <span class="math">\([6] \times [6] = \set{(a, b) \middle| a, b \in [6]}\)</span>.</p>
</blockquote>
<p>Find the number of possible binary strings of length <span class="math">\(n\)</span>:</p>
<blockquote>
<p>Clearly, each digit in the string is of the set <span class="math">\(\set{0, 1}\)</span>, and there are <span class="math">\(n\)</span> digits.<br />Clearly, the number of possiblities are <span class="math">\(\abs{\set{0, 1} \times \ldots \times \set{0, 1}}\)</span> (<span class="math">\(n\)</span> times), or <span class="math">\(2^n\)</span>.<br />The set of possible binary strings is therefore <span class="math">\(\set{0, 1}^n\)</span>.</p>
</blockquote>
<p>Let <span class="math">\(S  = A \cup B\)</span>. If <span class="math">\(A \cap B = \emptyset\)</span>, then <span class="math">\(\abs{S} = \abs{A} + \abs{B}\)</span>. In other words, if two sets share nothing in common, then their disjunction has a size equal to the sum of their sizes.</p>
<p>We could say that the Cartesian product is analogous to multiplcation, and disjunction is analogous to addition.</p>
<h3 id="permutations">Permutations</h3>
<p>A <strong>permutation</strong> is the rearrangement of the elements of <span class="math">\([n]\)</span> - an ordered set. For example, all permutations of <span class="math">\([3]\)</span> are <span class="math">\(\set{1, 2, 3}, \set{1, 3, 2}, \set{2, 1, 3}, \set{2, 3, 1}, \set{3, 1, 2}, \set{3, 2, 1}\)</span>.</p>
<p>In general, <span class="math">\([n]\)</span> has <span class="math">\(n!\)</span> permutations. We find these permutations by picking each of the <span class="math">\(n\)</span> elements for the first position, and for each of these, we pick each of the <span class="math">\(n - 1\)</span> remaining elements for the second, and for each of these, we pick each of the <span class="math">\(n - 2\)</span> remaining elements for the third, and so on.</p>
<p>For example, find the permutations of <span class="math">\(\set{1, 2, 3}\)</span></p>
<blockquote>
<p>First, we choose 1 as the first position, so the remaining elements are <span class="math">\(\set{2, 3}\)</span>.<br />Now we choose each of 2 and 3 for the second position, to yield the permutations <span class="math">\(\set{1, 2, 3}\)</span> and <span class="math">\(\set{1, 3, 2}\)</span>.<br />Second, we choose 2 as the first position, so the remaining elements are <span class="math">\(\set{1, 3}\)</span>.<br />Now we choose each of 1 and 3 for the second position, to yield the permutations <span class="math">\(\set{2, 1, 3}\)</span> and <span class="math">\(\set{2, 3, 1}\)</span>.<br />Third, we choose 3 as the first position, so the remaining elements are <span class="math">\(\set{1, 2}\)</span>.<br />Now we choose each of 1 and 2 for the second position, to yield the permutations <span class="math">\(\set{3, 1, 2}\)</span> and <span class="math">\(\set{3, 2, 1}\)</span>.</p>
</blockquote>
<p>Every permutation is also a bijection, mapping elements from <span class="math">\([n]\)</span> into a different set. Formally, <span class="math">\(\sigma: [n] \to [n]\)</span>. For example, the permutation <span class="math">\(\set{2, 3, 1}\)</span> maps <span class="math">\(\set{A, B, C}\)</span> to <span class="math">\(\set{B, C, A}\)</span>. In other words, it behaves something like a function.</p>
<h3 id="combinations">Combinations</h3>
<p>A <strong>combination</strong> is a possible way of &quot;choosing&quot; <span class="math">\(k\)</span> elements of a set <span class="math">\([n]\)</span>, where <span class="math">\(k \le n\)</span>. In other words, it is a subset of size <span class="math">\(k\)</span> of the set <span class="math">\([n]\)</span>.</p>
<p>A subset of size <span class="math">\(k\)</span> is known as a <span class="math">\(k\)</span>-subset. A permutation of a <span class="math">\(k\)</span>-subset is a <span class="math">\(k\)</span>-permutation, and a combination of a <span class="math">\(k\)</span>-subset is a <span class="math">\(k\)</span>-combination.</p>
<p>We find these subsets by basically taking the first <span class="math">\(k\)</span> elements of each permutation. We then get the set containing all the possible <span class="math">\(k\)</span>-permutations, but each one is duplicated <span class="math">\((n - k)!\)</span> times because there are that many that start with those particular <span class="math">\(k\)</span> elements and are followed by all permutations of the remaining elements.</p>
<p>Therefore, there are <span class="math">\(\frac{n!}{(n - k)!}\)</span> <span class="math">\(k\)</span>-permutations of <span class="math">\([n]\)</span>. Clearly, each <span class="math">\(k\)</span>-combination corresponds to <span class="math">\(k!\)</span> <span class="math">\(k\)</span>-permutations, because combinations are basically permutations without order.</p>
<p>So the number of <span class="math">\(k\)</span>-combinations is a factor of <span class="math">\(k!\)</span> less than the number of <span class="math">\(k\)</span>-permutations, and is given by <span class="math">\(\frac{n!}{k!(n - k)!}\)</span>.</p>
<p>In general, <span class="math">\([n]\)</span> has <span class="math">\(\frac{n!}{k!(n - k)!}\)</span> combinations of size <span class="math">\(k\)</span>. This can be represented by <span class="math">\(n \choose k\)</span>. If <span class="math">\(n &lt; k\)</span>, we define <span class="math">\(n \choose k = 0\)</span>.</p>
<h1 id="section-1">7/5/14</h1>
<p>;wip: midterm on July 3</p>
<h2 id="bijections">Bijections</h2>
<p>A <strong>bijection</strong> is a function that maps a set <span class="math">\(S\)</span> to another set <span class="math">\(T\)</span>, and is one to one and onto.</p>
<p>One to one means that the function has a unique element of <span class="math">\(T\)</span> for every value of <span class="math">\(S\)</span> - no two things in <span class="math">\(S\)</span> are mapped to the same element of <span class="math">\(T\)</span>. It is possible that <span class="math">\(T\)</span> is larger than <span class="math">\(S\)</span>, so <span class="math">\(\abs{T} \ge \abs{S}\)</span>.</p>
<p>Onto means that the function has a unique element of <span class="math">\(S\)</span> for every value of <span class="math">\(T\)</span> - every thing in <span class="math">\(T\)</span> must also have an element in <span class="math">\(S\)</span> that maps to it. Because there must be one element in <span class="math">\(S\)</span> for every element of <span class="math">\(T\)</span>, so <span class="math">\(\abs{S} \ge \abs{T}\)</span>.</p>
<p>A bijection is therefore a function that maps a set's elements to the elements of another set of the same size. Every element in either set has a unique corresponding element in the other set.</p>
<p>It is often tedious to prove that it is one to one and onto. We can prove a function is a bijection very easily, by proving that it has an inverse.</p>
<h3 id="bijection-inverse-theorem">Bijection Inverse Theorem</h3>
<p>Proposition: a function is a bijection if and only if it has an inverse.</p>
<p>Proof:</p>
<blockquote>
<p>;wip</p>
</blockquote>
<p>The <strong>inverse</strong> of <span class="math">\(f: S \to T\)</span> is a function <span class="math">\(f^{-1}\)</span> such that x S, f^{-1}(f(x)) = x$ and <span class="math">\(\forall y \in T, f(f^{-1}(y)) = y\)</span>. It is basically a reverse mapping backwards from <span class="math">\(T\)</span> to <span class="math">\(S\)</span>.</p>
<p>For example, let <span class="math">\(S\)</span> be the set of all <span class="math">\(k\)</span>-subsets of <span class="math">\([n]\)</span> and <span class="math">\(T\)</span> be the set of all <span class="math">\((n - k)\)</span>-subsets of <span class="math">\([n]\)</span>:</p>
<blockquote>
<p>If <span class="math">\(n = 3, k = 1\)</span>, then <span class="math">\(S = \set{\set{1}, \set{2}, \set{3}}, T = \set{\set{1, 2}, \set{1, 3}, \set{2, 3}}\)</span>.<br />One bijection over these sets would be <span class="math">\(f: S \to T\)</span> where <span class="math">\(f(A) = [n] \setdiff A\)</span>. This is a bijection because it maps every item in <span class="math">\(S\)</span> to a unique item in <span class="math">\(T\)</span>, with no items in <span class="math">\(T\)</span> left over. ;wip: is right? Also, since <span class="math">\(\abs{A} = k\)</span> and <span class="math">\(A \subseteq [n]\)</span>, <span class="math">\(\abs{f(A)} = \abs{[n]} - \abs{A} = n - k\)</span>, as required.<br />Clearly, <span class="math">\(f^{-1}(B) = [n] \setdiff B\)</span>. Since the function has an inverse, <span class="math">\(f\)</span> is a bijection and <span class="math">\(\abs{S} = \abs{T} = n \choose k = n \choose n - k\)</span>.<br />As an aside, we proved that <span class="math">\(n \choose k = n \choose n - k\)</span>.</p>
</blockquote>
<p>Another example would be a mapping <span class="math">\(f: S \to T\)</span> where <span class="math">\(S\)</span> is all the subsets of <span class="math">\([n]\)</span> and <span class="math">\(T\)</span> is all binary strings of length <span class="math">\(n\)</span>:</p>
<blockquote>
<p>An obvious bijection would be to map all the subsets to binary strings such that each digit is 1 if and only if the index of that digit is in the set.<br />Formally, we would write that as <span class="math">\(f(A) = a_n \cdots a_1, a_i = \begin{cases} 1 &amp;\text{if } i \in A \\ 0 &amp;\text{if } i \notin A \end{cases}, i \in [n]\)</span>.<br />We can also prove this is a bijection by finding its inverse: <span class="math">\(f^{-1}(a_n \cdots a_1) = \set{i \in [n] \middle| a_i = 1}\)</span>.<br />Since it is a bijection, <span class="math">\(\abs{S} = \abs{T}\)</span>, so there are the same number of subsets as there are binary strings of length <span class="math">\(n\)</span>.<br />Since there are <span class="math">\(2^n\)</span> possible binary strings, there are also <span class="math">\(2^n\)</span> subsets of <span class="math">\([n]\)</span>.<br />This also gives us an algorithm for listing all the subsets. Since binary strings are easy to list by counting upwards, we simply apply <span class="math">\(f^{-1}\)</span> to the list of all the binary strings of length <span class="math">\(n\)</span> to get the subsets of <span class="math">\([n]\)</span>.</p>
</blockquote>
<h2 id="binomial-theorem">Binomial Theorem</h2>
<p>Proposition: <span class="math">\((1 + x)^n = \sum_{k = 0}^n {n \choose k} x^k\)</span>.</p>
<p>Clearly, <span class="math">\((1 + x)^n = (1 + x) \cdots (1 + x)\)</span>. Clearly, each term in the expansion takes either a <span class="math">\(1\)</span> or an <span class="math">\(x\)</span> from each of the factors.</p>
<p>For example, <span class="math">\((1 + x)^3 = (1 + x)(1 + x)(1 + x) = 1 \cdot 1 \cdot 1 + 1 \cdot 1 \cdot x + 1 \cdot x \cdot 1 + 1 \cdot x \cdot x\)</span>. Clearly, the factors of each term is in the Cartesian product of the set <span class="math">\(\set{1, x}^n\)</span>.</p>
<p>We can also represent this using a Cartesian product. Clearly, <span class="math">\(\set{1, x}^n = \set{(a_1, \ldots, a_n) \middle| a_1, \ldots, a_n \in \set{1, x}}\)</span>.</p>
<p>Therefore, <span class="math">\((1 + x)^n = \sum_{(a_1, \ldots, a_n) \in \set{1, x}^n} a_1 \cdots a_n\)</span>.</p>
<p>Clearly, each <span class="math">\(a_1 \cdots a_n\)</span> adds another <span class="math">\(x^k\)</span> where <span class="math">\(k\)</span> is the number of occurrences of <span class="math">\(x\)</span>. Since there are <span class="math">\(n \choose k\)</span> ways of picking <span class="math">\(k\)</span> occurrences of <span class="math">\(x\)</span>, and all possible combinations are in the Cartesian product, there are <span class="math">\(n \choose k\)</span> terms that are <span class="math">\(x^k\)</span>.</p>
<p>Since the highest power is <span class="math">\(x^n\)</span>, <span class="math">\((1 + x)^n = \sum_{k = 0}^n {n \choose k} x^k\)</span>.</p>
<h1 id="section-2">9/5/14</h1>
<p>In combinatorial proofs, we often prove that two things are equal by constructing a set such that if we count the number of elements it contains in one way it results in one side, and when we count another way it results in the other side.</p>
<p>So if we wanted to prove <span class="math">\(A = B\)</span>, then we'd have a set such that finding its size one way results in <span class="math">\(A\)</span>, and in another way results in <span class="math">\(B\)</span>.</p>
<h3 id="disjoint-sets">Disjoint Sets</h3>
<p>Two sets <span class="math">\(A\)</span> and <span class="math">\(B\)</span> are <strong>disjoint sets</strong> if they have no elements in common - <span class="math">\(A \cap B = \emptyset\)</span>. Three or more sets are disjoint if all of those sets are all disjoint to each other - they all contain unique elements.</p>
<p>If the sets <span class="math">\(S_1, \ldots, S_n\)</span> are disjoint, then <span class="math">\(\abs{S_1 \cup \ldots \cup S_n} = \abs{S_1} + \ldots + \abs{S_n}\)</span>. This is because all the elements are unique, so the union is simply the set containing all the original elements.</p>
<p>If we replace <span class="math">\(x\)</span> with 1 in the Binomial theorem, we get <span class="math">\(2^n = \sum_{k = 0}^n {n \choose k}\)</span>. The <span class="math">\(n \choose k\)</span> values are known as the <strong>binomial coefficients</strong>.</p>
<p>We want a combinatoric proof of this rather than a simple algebraic proof. What we will do is create a set, and when we count it one way, we get <span class="math">\(2^n\)</span>, and when we prove it another way, we get <span class="math">\(\sum_{k = 0}^n {n \choose k}\)</span>.</p>
<p>Let <span class="math">\(S\)</span> be the set of all subsets of <span class="math">\([n]\)</span>. Then <span class="math">\(\abs{S} = 2^n\)</span>, from the proof of bijections of binary strings.</p>
<p>Let <span class="math">\(S_k\)</span> be the set of all <span class="math">\(k\)</span>-subsets of <span class="math">\([n]\)</span>, for <span class="math">\(0 \le k \le n\)</span>. Then <span class="math">\(S = S_0 \cup \ldots \cup S_n\)</span>, and <span class="math">\(S_0, \ldots, S_n\)</span> are disjoint sets.</p>
<p>Then <span class="math">\(\abs{S} = \abs{S_1} + \ldots + \abs{S_n}\)</span>, and <span class="math">\(\abs{S_k} = {n \choose k}\)</span> (since a <span class="math">\(k\)</span>-subset is all the ways we can choose <span class="math">\(k\)</span> elements out of <span class="math">\(n\)</span>).</p>
<p>So <span class="math">\(\abs{S} = 2^n = \sum_{k = 0}^n {n \choose k}\)</span>.</p>
<p>Using this, we can draw <strong>Pascal's Triangle</strong>, a triangle listing all the binomial coefficients:</p>
<pre><code>               1
            1    1
         1    2    1
      1    3    3    1
   1    4    6    4    1
1    5   10   10    5    1
...</code></pre>
<p>The <span class="math">\(n\)</span>th row of Pascal's Triangle is all the values of <span class="math">\(n \choose k\)</span>, and each column of each row is for <span class="math">\(k\)</span> from 1 to <span class="math">\(n\)</span> inclusive.</p>
<p>From the triangle we notice that <span class="math">\({n \choose k} = {n - 1 \choose k} + {n - 1 \choose k - 1}\)</span>. However, we want to prove this:</p>
<blockquote>
<p>Let <span class="math">\(S\)</span> be the set of all <span class="math">\(k\)</span>-subsets of <span class="math">\([n]\)</span>.<br />Then <span class="math">\(\abs{S} = {n \choose k}\)</span>. Let <span class="math">\(S_1\)</span> be the set of all <span class="math">\(k\)</span>-subsets of <span class="math">\([n]\)</span> that include <span class="math">\(n\)</span>, and <span class="math">\(S_2\)</span> be the set of all subsets that do not.<br />Clearly, <span class="math">\(S = S_1 \cup S_2\)</span>, which is a disjoint set, so <span class="math">\(\abs{S} = \abs{S_1} + \abs{S_2}\)</span>.<br />Clearly, every set in <span class="math">\(S_1\)</span> contains <span class="math">\(n\)</span>, plus <span class="math">\(k - 1\)</span> elements from <span class="math">\([n - 1]\)</span>, since we can't use <span class="math">\(n\)</span> again.<br />So <span class="math">\(\abs{S_1} = {n - 1 \choose k - 1}\)</span>, since it is the set of all <span class="math">\((k - 1)\)</span>-subsets of <span class="math">\([n - 1]\)</span>.<br />Clearly, every set in <span class="math">\(S_1\)</span> contains <span class="math">\(k\)</span> elements, and we can only choose from <span class="math">\([n - 1]\)</span> elements.<br />So <span class="math">\(\abs{S_2} = {n - 1 \choose k}\)</span>, since it is the set of all <span class="math">\(k\)</span>-subsets of <span class="math">\([n - 1]\)</span>.<br />So <span class="math">\({n \choose k} = {n - 1 \choose k} + {n - 1 \choose k - 1}\)</span>.</p>
</blockquote>
<p>We can also prove it algebraically:</p>
<blockquote>
<p>If <span class="math">\(f(x)\)</span> is a power series, then let <span class="math">\([x^n]f(x)\)</span> represent the coefficient of <span class="math">\(x^n\)</span> in <span class="math">\(f(x)\)</span>.<br />So <span class="math">\([x^k](1 + x)^n = {n \choose k}\)</span>.<br />Clearly, <span class="math">\([x^k](1 + x)^n = [x^k](1 + x)(1 + x)^{n - 1} = [x^k](1 + x)^{n - 1} + [x^k]x(1 + x)^{n - 1}\)</span>.<br />Clearly, <span class="math">\([x^k](1 + x)^{n - 1} = {n - 1 \choose k}\)</span>.<br />Clearly, <span class="math">\([x^k]x(1 + x)^{n - 1} = [x^{k - 1}](1 + x)^{n - 1} = {n - 1 \choose k - 1}\)</span>, since the <span class="math">\(x\)</span> factor increases all the powers of <span class="math">\(x\)</span> in the power series by 1.<br />So <span class="math">\([x^k](1 + x)^n = [x^k](1 + x)^{n - 1} + [x^k]x(1 + x)^{n - 1} = {n \choose k} = {n - 1 \choose k} + {n - 1 \choose k - 1}\)</span></p>
</blockquote>
<p>From the above identity we know that <span class="math">\({n + k \choose n} = {n + k - 1 \choose n} + {n + k - 1 \choose n - 1}\)</span>, since we substituted <span class="math">\(n + k\)</span> for <span class="math">\(n\)</span> and <span class="math">\(n\)</span> for <span class="math">\(k\)</span>.</p>
<p>;wip: organize into headings</p>
<p>If we expand the first term of the right side using the same identity, we get <span class="math">\({n + k \choose n} = {n + k - 2 \choose n} + {n + k - 2 \choose n - 1} + {n + k - 1 \choose n - 1}\)</span>.</p>
<p>If we keep expanding the first term on the right side, we find that we get <span class="math">\({n + k - (k + 1) \choose n} + {n + k - (k + 1) \choose n - 1} + \ldots + {n + k - 1 \choose n - 1}\)</span>. Clearly, <span class="math">\(n + k - (k + 1) \choose n = 0\)</span>.</p>
<p>So by induction, we get <span class="math">\(\sum_{i = 0}^k {n + i - 1 \choose n - 1} = {n + k \choose n}\)</span>.</p>
<p>Now we want to prove this combinatorially:</p>
<blockquote>
<p>Let <span class="math">\(S\)</span> be the set of all <span class="math">\(n\)</span>-subsets of <span class="math">\([n - k]\)</span>. Then <span class="math">\(\abs{S} = {n + k \choose n}\)</span>.<br />Let <span class="math">\(S_i\)</span> be the set of all <span class="math">\(n\)</span>-subsets of <span class="math">\([n + k]\)</span> whose largest element is <span class="math">\(n + i\)</span>, where <span class="math">\(0 \le i \le k\)</span>.<br />Clearly, the largest element of each <span class="math">\(n\)</span>-subset is between <span class="math">\(n\)</span> and <span class="math">\(n + k\)</span> inclusive.<br />Clearly, <span class="math">\(S = S_0 \cup \ldots \cup S_k\)</span>, and this is a disjoint set, so <span class="math">\(\abs{S} = \abs{S_0} + \ldots + \abs{S_k}\)</span>.<br />Clearly, each set in <span class="math">\(S_i\)</span> must contain <span class="math">\(n + i\)</span> as the largest element, and all the other elements must be in <span class="math">\([n + i - 1]\)</span> (since they must be less than the largest element).<br />So there are <span class="math">\(n + i - 1\)</span> elements to choose from, out of <span class="math">\(n - 1\)</span> spots (one spot of <span class="math">\(n\)</span> was taken by the largest element). So there are <span class="math">\(n + i - 1 \choose n - 1\)</span> elements in <span class="math">\(S_i\)</span>.</p>
</blockquote>
<p>This is known as the <strong>hockey stick identity</strong>. The reason for this is because it states that in Pascal's Triangle, the value of a number in the triangle is the sum of all the numbers in either diagonal passing through the number directly above it from the outside edge of the triangle until it is diagonal to the number we want.</p>
<p>For example, the topmost and leftmost 10 in Pascal's Triangle is <span class="math">\(10 = 1 + 3 + 6\)</span>, or <span class="math">\(10 = 4 + 3 + 2 + 1\)</span>.</p>
<hr>
<p>Copyright 2013 Anthony Zhang</p>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.
<script type="text/javascript">
MathJax.Hub.Config({
  jax: ["input/TeX","output/HTML-CSS"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
</body>
</html>